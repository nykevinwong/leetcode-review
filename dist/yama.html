<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Atomic Habit</title>
    <link rel="stylesheet" type="text/css" href="prism.css" />
    <style>
      .center {
          margin: auto;
          width: 820px;
          border: 1px solid black;
          padding: 0 0 0 0;
          font-size: 11px;
          line-height: 14px;
        }

      .noscrollbar {
        overflow: hidden;
      }

      .token.number {
        color: lightblue;
      }

      
    </style>
		<script src="prism.js" type="text/javascript"></script>
		<script src="main.js" type="text/javascript"></script>

<script>


  </script>
	</head>
	<body>
	
  <!-- table of contents -->
	<ul>
    <li id="li_32" name="li_32" data-id=""><input type="checkbox" id="checkbox_32" name="checkbox_32" /><a href="#code_32">Find N Unique Integers Sum Up To Zero</a></li>
<li id="li_1" name="li_1" data-id=""><input type="checkbox" id="checkbox_1" name="checkbox_1" /><a href="#code_1">Window</a></li>
<li id="li_12" name="li_12" data-id=""><input type="checkbox" id="checkbox_12" name="checkbox_12" /><a href="#code_12">Search Matrix</a></li>
<li id="li_29" name="li_29" data-id=""><input type="checkbox" id="checkbox_29" name="checkbox_29" /><a href="#code_29">Generate Parentheses</a></li>
<li id="li_19" name="li_19" data-id=""><input type="checkbox" id="checkbox_19" name="checkbox_19" /><a href="#code_19">Nth Geometric Progression</a></li>
<li id="li_9" name="li_9" data-id=""><input type="checkbox" id="checkbox_9" name="checkbox_9" /><a href="#code_9">Substrings Of Exactly K Distinct Chars</a></li>
<li id="li_16" name="li_16" data-id=""><input type="checkbox" id="checkbox_16" name="checkbox_16" /><a href="#code_16">Partition Label</a></li>
<li id="li_14" name="li_14" data-id=""><input type="checkbox" id="checkbox_14" name="checkbox_14" /><a href="#code_14">Reorder Data In Log File</a></li>
<li id="li_7" name="li_7" data-id=""><input type="checkbox" id="checkbox_7" name="checkbox_7" /><a href="#code_7">Subtree Of Another Tree</a></li>
<li id="li_23" name="li_23" data-id=""><input type="checkbox" id="checkbox_23" name="checkbox_23" /><a href="#code_23">Merge Two Sorted List</a></li>
<li id="li_10" name="li_10" data-id=""><input type="checkbox" id="checkbox_10" name="checkbox_10" /><a href="#code_10">Subarrays With K Different Integers</a></li>
<li id="li_24" name="li_24" data-id=""><input type="checkbox" id="checkbox_24" name="checkbox_24" /><a href="#code_24">Merge Intervals</a></li>
<li id="li_20" name="li_20" data-id=""><input type="checkbox" id="checkbox_20" name="checkbox_20" /><a href="#code_20">Most Common Word</a></li>
<li id="li_8" name="li_8" data-id=""><input type="checkbox" id="checkbox_8" name="checkbox_8" /><a href="#code_8">Substrings Of Size Kwith K Distinct Chars</a></li>
<li id="li_30" name="li_30" data-id=""><input type="checkbox" id="checkbox_30" name="checkbox_30" /><a href="#code_30">Find Unique Pairs With Given Sum</a></li>
<li id="li_21" name="li_21" data-id=""><input type="checkbox" id="checkbox_21" name="checkbox_21" /><a href="#code_21">Minimum Cost To Connect Rope</a></li>
<li id="li_15" name="li_15" data-id=""><input type="checkbox" id="checkbox_15" name="checkbox_15" /><a href="#code_15">Prison Cells After N Days</a></li>
<li id="li_35" name="li_35" data-id=""><input type="checkbox" id="checkbox_35" name="checkbox_35" /><a href="#code_35">Copy Random Linked List</a></li>
<li id="li_31" name="li_31" data-id=""><input type="checkbox" id="checkbox_31" name="checkbox_31" /><a href="#code_31">Find Pair With Given Sum</a></li>
<li id="li_11" name="li_11" data-id=""><input type="checkbox" id="checkbox_11" name="checkbox_11" /><a href="#code_11">Search Suggestion System</a></li>
<li id="li_3" name="li_3" data-id=""><input type="checkbox" id="checkbox_3" name="checkbox_3" /><a href="#code_3">Treasure Island 2</a></li>
<li id="li_18" name="li_18" data-id=""><input type="checkbox" id="checkbox_18" name="checkbox_18" /><a href="#code_18">Number Of Clusters</a></li>
<li id="li_33" name="li_33" data-id=""><input type="checkbox" id="checkbox_33" name="checkbox_33" /><a href="#code_33">Favorite Genres</a></li>
<li id="li_6" name="li_6" data-id=""><input type="checkbox" id="checkbox_6" name="checkbox_6" /><a href="#code_6">Sub Tree With Maximum Average</a></li>
<li id="li_26" name="li_26" data-id=""><input type="checkbox" id="checkbox_26" name="checkbox_26" /><a href="#code_26">Longest Plaindromic Substring</a></li>
<li id="li_13" name="li_13" data-id=""><input type="checkbox" id="checkbox_13" name="checkbox_13" /><a href="#code_13">Rottin Oranges</a></li>
<li id="li_27" name="li_27" data-id=""><input type="checkbox" id="checkbox_27" name="checkbox_27" /><a href="#code_27">K Closet Pointsto Origin</a></li>
<li id="li_36" name="li_36" data-id=""><input type="checkbox" id="checkbox_36" name="checkbox_36" /><a href="#code_36">Binary Search</a></li>
<li id="li_22" name="li_22" data-id=""><input type="checkbox" id="checkbox_22" name="checkbox_22" /><a href="#code_22">Min Cost To Connect All Nodes Or Repair Edges</a></li>
<li id="li_5" name="li_5" data-id=""><input type="checkbox" id="checkbox_5" name="checkbox_5" /><a href="#code_5">Top K Frequently Mentioned Keywords</a></li>
<li id="li_4" name="li_4" data-id=""><input type="checkbox" id="checkbox_4" name="checkbox_4" /><a href="#code_4">Treasure Island</a></li>
<li id="li_25" name="li_25" data-id=""><input type="checkbox" id="checkbox_25" name="checkbox_25" /><a href="#code_25">Longest String With Three Consecutive Characters</a></li>
<li id="li_2" name="li_2" data-id=""><input type="checkbox" id="checkbox_2" name="checkbox_2" /><a href="#code_2">Union Find</a></li>
<li id="li_17" name="li_17" data-id=""><input type="checkbox" id="checkbox_17" name="checkbox_17" /><a href="#code_17">Optimal Utilization</a></li>
<li id="li_34" name="li_34" data-id=""><input type="checkbox" id="checkbox_34" name="checkbox_34" /><a href="#code_34">Critical Routers Or Connections</a></li>
<li id="li_28" name="li_28" data-id=""><input type="checkbox" id="checkbox_28" name="checkbox_28" /><a href="#code_28">Java Collections</a></li>

  </ul>
  
  
<div id="code_32" name="code_32" class="center">
<a class=".title">Find N Unique Integers Sum Up To Zero</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_32">
<code class="language-java">
import java.util.*;
class FindNUniqueIntegersSumUpToZero implements IInterviewQuestion {

    public int[] sumZero(int n) {
        
        int half = n/2;
        int[] arr = new int[n];
        for(int i=0;i&lt; half;i++)
        {
            arr[i]=-(n-i);
            arr[n-i-1]= (n-i);
        }
                    
        return arr;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_32"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_1" name="code_1" class="center">
<a class=".title">Window</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_1">
<code class="language-java">
import java.util.Map;
class Window&lt;E&gt;
{
    Map&lt;E,Integer&gt; m = new HashMap&lt;&gt;();
    int kinds = 0; // the total number of types available in the map
    
    public Window() {}
    
    public void add(E x)
    {
        m.put(x, m.getOrDefault(x,0)+1);
        if(m.get(x)==1) kinds++;
    }
    
    public void remove(E x)
    {
        m.put(x, m.get(x)-1);
        if(m.get(x)==0) kinds--;
    }
    
    public int kinds() { return kinds; }
}

</code>
</pre>
</div>

<template id="my-label-button-code_1"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_12" name="code_12" class="center">
<a class=".title">Search Matrix</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_12">
<code class="language-java">

public class SearchMatrix implements IInterviewQuestion
{
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix==null || matrix.length==0 || matrix[0].length==0 ) return false;
        int col = matrix[0].length-1;
        int row = 0;
        
        while(row &lt; matrix.length &amp;&amp; col &gt;= 0)
        {
            if(matrix[row][col]==target) return true;
            if(matrix[row][col] &lt; target) row++;
            else col--;
        }
        
        return false;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_12"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_29" name="code_29" class="center">
<a class=".title">Generate Parentheses</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_29">
<code class="language-java">
import java.util.List;
class GenerateParentheses implements IInterviewQuestion {
    
    public List&lt;String&gt; generateParentheses(int n) {
        List&lt;String&gt; res = new ArrayList&lt;&gt;();
        dfs(&quot;&quot;, n, n, res);   
        return res;
    }
    
    public void dfs(String s, int left, int right, List&lt;String&gt; res)
    {
        if(left &gt; right) return;
        if(left &lt;0 || right &lt; 0) return;
        if(left==0 &amp;&amp; right==0) res.add(s);
        
        dfs(s+&quot;(&quot;, left-1, right, res);
        dfs(s+&quot;)&quot;, left, right-1, res);
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_29"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_19" name="code_19" class="center">
<a class=".title">Nth Geometric Progression</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_19">
<code class="language-java">
class NthGeometricProgression implements IInterviewQuestion  {

    public char[] getNthGP(double secondTerm, double thirdTerm, int nth)
    {
        double r = thirdTerm/ secondTerm;
        double a = secondTerm/r;
        double result = a*Math.pow(r, nth-1);
        String str = String.valueOf(result);
        int pos = str.indexOf('.');

        if(pos &gt; 0) // trim up to 
        {
           int decimalPlaces = 3;
           str = str.substring(0, Math.min(pos+decimalPlaces+1, str.length())); 
        }

    //    System.out.println(&quot;res =&gt; [&quot; + str + &quot;]&quot;);
        return str.toCharArray();
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_19"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_9" name="code_9" class="center">
<a class=".title">Substrings Of Exactly K Distinct Chars</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_9">
<code class="language-java">

class SubstringsOfExactlyKDistinctChars implements IInterviewQuestion
{

    public int substringswithExactlyKDistinctChars(String s, int K)
    {
        Window&lt;Character&gt; w1 = new Window&lt;Character&gt;();
        Window&lt;Character&gt; w2 = new Window&lt;Character&gt;();
        int count = 0, left1=0, left2 = 0;
        for(int i=0;i&lt;s.length();i++)
        {
            Character c = s.charAt(i);
            w1.add(c);
            w2.add(c);
            while(w1.kinds() &gt; K) w1.remove(s.charAt(left1++));
            while(w2.kinds() &gt;= K) w2.remove(s.charAt(left2++));
            count += left2-left1;
        }
        return count;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_9"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_16" name="code_16" class="center">
<a class=".title">Partition Label</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_16">
<code class="language-java">

public class PartitionLabel implements IInterviewQuestion
{
    public List&lt;Integer&gt; partitionLabels(String S) {
        int[] last = new int[26];
        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
        
        for(int i=0;i&lt;S.length();i++)
            last[S.charAt(i)-'a'] = i;           
        
        int lastMax = 0, start = 0;
        for(int i=0;i&lt;S.length();i++)
        {
            lastMax = Math.max( last[S.charAt(i)-'a'], lastMax);           
            
            if(lastMax==i)
            {
                res.add(lastMax-start+1);                    
                start = i+1;
            }
        }
        
        return res;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_16"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_14" name="code_14" class="center">
<a class=".title">Reorder Data In Log File</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_14">
<code class="language-java">

public class ReorderDataInLogFile implements IInterviewQuestion
{
    public String[] reorderLogFiles(String[] logs) {
        Arrays.sort(logs, (log1, log2) -&gt; {
            String[] split1 = log1.split(&quot; &quot;, 2);
            String[] split2 = log2.split(&quot; &quot;, 2);
            boolean isDigit1 = Character.isDigit(split1[1].charAt(0));
            boolean isDigit2 = Character.isDigit(split2[1].charAt(0));
            if (!isDigit1 &amp;&amp; !isDigit2) {
                int cmp = split1[1].compareTo(split2[1]);
                if (cmp != 0) return cmp;
                return split1[0].compareTo(split2[0]);
            }
            return isDigit1 ? (isDigit2 ? 0 : 1) : -1;
        });
        return logs;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_14"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_7" name="code_7" class="center">
<a class=".title">Subtree Of Another Tree</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_7">
<code class="language-java">

class SubtreeOfAnotherTree implements IInterviewQuestion
{
    public boolean isSubtree(TreeNode s, TreeNode t) {        
        return traverse(s, t);
    }
    
    public boolean traverse(TreeNode s, TreeNode t)
    {
        return s!=null &amp;&amp; (
            sameStructure(s,t) ||
            traverse(s.left,t) ||
            traverse(s.right,t)
        );
    }
    
    public boolean sameStructure(TreeNode a, TreeNode b)
    {
        if(a==null &amp;&amp; b ==null) // touch bottom of the tree
            return true;
        
        if(a!=null &amp;&amp; b !=null &amp;&amp;
          a.val == b.val)
        {
            return sameStructure(a.left, b.left) &amp;&amp; sameStructure(a.right, b.right);
        }   
        
        return false;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_7"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_23" name="code_23" class="center">
<a class=".title">Merge Two Sorted List</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_23">
<code class="language-java">

class MergeTwoSortedList implements IInterviewQuestion
{
    public Node mergeTwoLists(Node l1, Node l2) {
        Node dummy = new Node(0);
        Node temp = dummy;
        
        while(l1 !=null &amp;&amp; l2 != null)
        {
            Node smaller = (l1.val &lt; l2.val) ? l1:l2;
            temp.next = smaller;             
            temp = temp.next;
            
            if(l1.val &lt; l2.val) l1=l1.next;
            else l2 = l2.next;
        }
        
        while(l1!=null)
        {
            temp.next = l1;
            temp = temp.next;
            l1 = l1.next;
        }
        
        while(l2!=null)
        {
            temp.next = l2;
            temp = temp.next;
            l2 = l2.next;
        }
        
        return dummy.next;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_23"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_10" name="code_10" class="center">
<a class=".title">Subarrays With K Different Integers</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_10">
<code class="language-java">
import java.util.*;
class SubarraysWithKDifferentIntegers implements IInterviewQuestion
{
    //Longest SubString With K Distinct Characters

    public int subarraysWithKDistinct(int[] A, int K) {        
        Window&lt;Integer&gt; w1 = new Window&lt;Integer&gt;();
        Window&lt;Integer&gt; w2 = new Window&lt;Integer&gt;();
        int left1=0, left2 =0;
        int count = 0;
        
        for(int i=0;i &lt; A.length;++i)
        {
            int x = A[i];
            w1.add(x);
            w2.add(x);
            
            while(w1.kinds() &gt; K )
                w1.remove(A[left1++]);
            
            while(w2.kinds() &gt;= K )
                w2.remove(A[left2++]);
            
            count+= left2-left1;            
        }
        
        return count;
    }

 }

</code>
</pre>
</div>

<template id="my-label-button-code_10"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_24" name="code_24" class="center">
<a class=".title">Merge Intervals</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_24">
<code class="language-java">
import java.util.*;
class MergeIntervals implements IInterviewQuestion
{
    public int[][] merge(int[][] intervals) {
		if (intervals== null || intervals.length &lt;= 1) return intervals;

		// Sort by ascending starting point
		Arrays.sort(intervals, (i,j) -&gt; i[0]==j[0] ? i[1]-j[1]:i[0]-j[0]);

		LinkedList&lt;int[]&gt; llRes = new LinkedList&lt;&gt;();
		llRes.add(intervals[0]);
        
		for (int i=1;i &lt; intervals.length;i++) {
            int[] merged = llRes.getLast();                        
			if (intervals[i][0] &lt;= merged[1]) // Overlapping intervals
            {
                llRes.removeLast();
				merged[1] = Math.max(merged[1], intervals[i][1]);
                llRes.addLast(merged);
            }
			else { // disjoint intervals                          
				llRes.add(intervals[i]);
			}
		}

		return llRes.toArray(new int[llRes.size()][]);
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_24"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_20" name="code_20" class="center">
<a class=".title">Most Common Word</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_20">
<code class="language-java">

class MostCommonWord implements IInterviewQuestion
{
    public String mostCommonWord(String paragraph, String[] banned) {
        String[] words = paragraph.split(&quot;\\W+&quot;); // split by all non-character. + means more than one non-character can be used. 
        HashSet&lt;String&gt; set = new HashSet&lt;&gt;();
        HashMap&lt;String,Integer&gt; m = new HashMap&lt;&gt;();
        String maxWord = null;
        int max = 0;
        for(String b : banned)
            set.add(b.toLowerCase());
        
        for(String w: words)
        {
            w = w.toLowerCase();
            if(!set.contains(w))
            {
                m.put(w, m.getOrDefault(w,0)+1);
                int count =m.get(w);
                if(count &gt; max)
                {
                    maxWord = w;
                    max = count;
                }
            }
        }
        
        return maxWord;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_20"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_8" name="code_8" class="center">
<a class=".title">Substrings Of Size Kwith K Distinct Chars</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_8">
<code class="language-java">
import java.util.ArrayList;
class SubstringsOfSizeKwithKDistinctChars implements IInterviewQuestion
{
    public List&lt;String&gt; substringsOfSizeKwithKDistinctChars(String s, int k)
    {
        List&lt;String&gt; res = new ArrayList&lt;&gt;();
        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        int[] m = new int[256];

        for(int i=0, j = 0;i &lt; s.length() &amp;&amp; j &lt; s.length(); )
        {
            if(m[s.charAt(i)]==0)
            {
                m[s.charAt(i++)]++;

            }
            else 
            {
                m[s.charAt(j++)]--;
            }
            if(i-j==k) { 
                String sub = s.substring(j,i);
                // use both hashSet and list to remove duplicate and maintain the original order 
                if(!set.contains(sub)) { res.add(sub); }
                set.add(sub);
                m[s.charAt(j++)]--;
            }
            
        }
        return res;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_8"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_30" name="code_30" class="center">
<a class=".title">Find Unique Pairs With Given Sum</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_30">
<code class="language-java">

public class FindUniquePairsWithGivenSum implements IInterviewQuestion
{
    public List&lt;List&lt;Integer&gt;&gt; findUniquePairsWithGivenSum(int[] nums, int target)
    {
        Map&lt;Integer, List&lt;Integer&gt;&gt; pos = new HashMap&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        for(int i=0;i&lt;nums.length;i++) 
        { 
            List&lt;Integer&gt; ls = pos.get(target-nums[i]);

            if(ls!= null &amp;&amp; ls.size() &gt; 0)
            {  // to DO. get rid of duplication.
                    int x = nums[i];
                    int y = nums[ls.get(0)];
                    int left = x &gt; y ? x:y;
                    int right = x &gt; y ? y:x;
                    res.add(Arrays.asList(left, right));
                    ls.remove(0);
            }
            else
            {
                pos.put(nums[i], pos.getOrDefault(nums[i], new ArrayList&lt;Integer&gt;()) );
                pos.get(nums[i]).add(i);
            }
        }

        return res;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_30"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_21" name="code_21" class="center">
<a class=".title">Minimum Cost To Connect Rope</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_21">
<code class="language-java">
import java.util.PriorityQueue;

class MinimumCostToConnectRope implements IInterviewQuestion
{
    public int minCostToConnectRope(int[] ropes)
    {
        int res = 0;
        PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();
        for(int len : ropes) { minHeap.add(len); }

        while(minHeap.size() &gt; 1)
        {
            int combinedLen = minHeap.poll() + minHeap.poll();
            res += combinedLen;
            minHeap.offer(combinedLen);
        }

        return res;
    }

    public void performTest()
    {
        Helper.equals(minCostToConnectRope(new int[]{2, 4, 3}) , 14, &quot;[2,4,3]: &quot;);
        Helper.equals(minCostToConnectRope(new int[]{8, 4, 6, 12}) , 58, &quot;[8,4,6,12]: &quot;);
        Helper.equals(minCostToConnectRope(new int[]{2, 2, 3, 3}) , 20, &quot;[2, 2, 3, 3]: &quot;);
        Helper.equals(minCostToConnectRope(new int[]{1, 2, 5, 10, 35, 89}) , 224, &quot;[1, 2, 5, 10, 35, 89]: &quot;);

    }

    public String toString() { 
        return &quot;Minimum Time to merge files/Minimum Cost to connect Ropes ([E]) [https://leetcode.com/discuss/interview-question/344677]&quot;;
    }
}
</code>
</pre>
</div>

<template id="my-label-button-code_21"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_15" name="code_15" class="center">
<a class=".title">Prison Cells After N Days</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_15">
<code class="language-java">
import java.util.HashSet;
class PrisonCellsAfterNDays implements IInterviewQuestion {

    public int[] prisonAfterNDays(int[] cells, int N) {
        if(cells==null || cells.length == 0 || N &lt;= 0) return cells;
            Set&lt;String&gt; set = new HashSet&lt;&gt;();
            
            while(0 &lt; N)
            {
                int[] next = nextDayCell(cells);
                String curKey = Arrays.toString(next);
                
                if(set.contains(curKey))
                {                
                    N%=set.size();
                    while(0 &lt; N--) cells  = nextDayCell(cells);
                    
                    return cells;
                }
                else
                {
                    set.add(curKey);
                }
                
                cells = next;   
                N-=1;
            }
            
            return cells;
        }
        
        public int[] nextDayCell(int[] cells)
        {
            int[] temp = new int[cells.length];
            
            for(int i=1;i&lt;cells.length-1;i++)
            {
                temp[i] = (cells[i-1]==cells[i+1]) ? 1:0;        
            }
            return temp;
        }

}

</code>
</pre>
</div>

<template id="my-label-button-code_15"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_35" name="code_35" class="center">
<a class=".title">Copy Random Linked List</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_35">
<code class="language-java">
import java.util.HashMap;
public class CopyRandomLinkedList  implements IInterviewQuestion {
    public Node copyRandomListWithDummyNode(Node head)   {
        if(head==null) return null;        
        HashMap&lt;Node, Node&gt; m = new HashMap&lt;Node, Node&gt;();
        Node dummy = new Node(0);
        
        for(Node cur = head, temp = dummy; cur!=null; cur=cur.next, temp=temp.next)
        {
            temp.next = new Node(cur.val);
            m.put(cur, temp.next);
        }
                
        for(Node cur = head, temp = dummy.next; cur!=null; cur=cur.next, temp=temp.next)
        {
            if(cur.random!=null) temp.random = m.get(cur.random);
        }
        
        return dummy.next;
    }

    public Node copyRandomListWithoutDummyNode(Node head)   {
        if(head==null) return null;        
        HashMap&lt;Node, Node&gt; m = new HashMap&lt;Node, Node&gt;();

        for(Node cur = head; cur!=null; cur=cur.next)
        {
            m.put(cur, new Node(cur.val));
        }
            
        for(Node cur = head; cur!=null; cur=cur.next)
        {
            m.get(cur).next = m.get(cur.next);
            m.get(cur).random = m.get(cur.random);
        }

        return m.get(head);
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_35"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_31" name="code_31" class="center">
<a class=".title">Find Pair With Given Sum</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_31">
<code class="language-java">

public class FindPairWithGivenSum implements IInterviewQuestion
{
    public List&lt;List&lt;Integer&gt;&gt; findPairWithGivenSum(int[] nums, int target)
    {
        Map&lt;Integer, List&lt;Integer&gt;&gt; pos = new HashMap&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        int max = Integer.MIN_VALUE;

        for(int i=0;i&lt;nums.length;i++) 
        { 
            List&lt;Integer&gt; ls = pos.get(target-nums[i]);

            if(ls!= null &amp;&amp; ls.size() &gt; 0)
            {
                    int idx1 = ls.get(0); // this one shall be smaller index.                    
                    int idx2 = i; // current one is always largest index since this index has not put into hash map yet.
                    int curMax = Math.max(nums[idx1],nums[idx2]);

                    ls.remove(0);
                    
                    if(curMax &gt; max)
                    {
                        max = curMax;
                        res.clear();
                        res.add(Arrays.asList(idx1,idx2));
                    }

            }
            else
            {
                pos.put(nums[i], pos.getOrDefault(nums[i], new ArrayList&lt;Integer&gt;()) );
                pos.get(nums[i]).add(i);
            }
        }

        return res;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_31"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_11" name="code_11" class="center">
<a class=".title">Search Suggestion System</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_11">
<code class="language-java">

public class SearchSuggestionSystem implements IInterviewQuestion {
    // System Design interview for auto suggestions: https://www.youtube.com/watch?v=xrYTjaK5QVM
    // https://leetcode.com/problems/search-suggestions-system
     class Trie {
     Trie[] sub = new Trie[26];
     List&lt;String&gt; suggestion = new LinkedList&lt;&gt;();
     }
 
     // autocomplete/typehead
     // suggest 3 items based on a searchWord currently typed.
     public List&lt;List&lt;String&gt;&gt; suggestedProducts(String[] products, String searchWord) {
         Arrays.sort(products);
         
         List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();
         Trie root = new Trie();
         for(String p: products) // pre-compute suggest list based on sorted order
         {
             Trie r = root;
             for(char c : p.toCharArray())
             {
                 if(r.sub[c-'a']==null) r.sub[c-'a'] = new Trie();
 
                 r = r.sub[c-'a'];
                 
                 if(r.suggestion.size() &lt; 3) r.suggestion.add(p);
             }
         }
         
         for(char c: searchWord.toCharArray())
         {
             if(root!=null) root = root.sub[c-'a'];
             res.add( (root==null) ? Arrays.asList() : root.suggestion);
         }
         
         return res;
     }
 
 }

</code>
</pre>
</div>

<template id="my-label-button-code_11"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_3" name="code_3" class="center">
<a class=".title">Treasure Island 2</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_3">
<code class="language-java">
import java.util.LinkedList;
class TreasureIsland2 implements IInterviewQuestion
{
    public int minimumRoute(char[][] maze)
    {
        Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;();
        int[][] dir = new int[][] { {0,1}, {0,-1}, {1,0}, {-1,0} };

        for(int i=0;i&lt; maze.length;i++)
        {
            for(int j=0; j &lt; maze[0].length;j++)
            {
                if(maze[i][j]=='S')
                {
                    q.add(new int[] {j, i});
                }
            }
        }
        
        int count = 0;
        while(q.size() &gt; 0)
        {
            int size = q.size();

            for(int i=0;i&lt;size;i++)
            {
                int[] pos = q.poll();
                for(int k=0;k&lt;dir.length;k++)
                {
                    int nx = pos[0] + dir[k][0];
                    int ny = pos[1] + dir[k][1];
                    if(nx &lt;0 || nx &gt;= maze[0].length || ny &lt;0 || ny &gt;= maze.length) continue;

                    if(maze[ny][nx]=='O') 
                    {
                        maze[ny][nx] = 'D'; // visited
                        q.add(new int[] {nx, ny });
                    }
                    else if(maze[ny][nx]=='X')
                    {
                        return count; // found it
                    }
                }
            }
            count++;
        }

        return count;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_3"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_18" name="code_18" class="center">
<a class=".title">Number Of Clusters</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_18">
<code class="language-java">

public class NumberOfClusters implements IInterviewQuestion {
    // questions: https://www.glassdoor.com/Interview/Problem-2d-grid-each-node-has-1-colors-find-number-of-clusters-of-a-given-color-red-blue-green-blue-gre-QTN_2930567.htm
    // https://leetcode.com/problems/number-of-islands/
    public int[] numberOfClusters(char[][] grid) {
        char[] colors = new char[] {'0','1','2'};
        int[] count = new int[] { 0,0,0};

        for(int i=0;i&lt;grid.length;i++)
        {
            for(int j=0;j&lt;grid[0].length;j++)
            {
                for(int k=0;k&lt;colors.length;k++)
                {
                    if(grid[i][j]==colors[k]) 
                    {
                        dfs(grid, i, j, colors[k]);
                        count[k]++;
                        break; // break; no need to check other colors.
                    }
                }
            }
        }

      //  System.out.println(&quot;counts: &quot; + Arrays.toString(count));
        return count;
    }
    
    public void dfs(char[][] grid, int y, int x, char target)
    {
        if(x &lt; 0 || x &gt;= grid[0].length || y &lt; 0 || y &gt;= grid.length ) return;        
        if(grid[y][x]!= target) return;
        
        grid[y][x]= 'v'; //marked as visited
        
        dfs(grid, y+1, x, target);
        dfs(grid, y-1, x, target);
        dfs(grid, y, x+1, target);
        dfs(grid, y, x-1, target);
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_18"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_33" name="code_33" class="center">
<a class=".title">Favorite Genres</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_33">
<code class="language-java">

class FavoriteGenres implements IInterviewQuestion
{
    public Map&lt;String, List&lt;String&gt;&gt; favoriteGenres(Map&lt;String, List&lt;String&gt;&gt; userSongs, Map&lt;String, List&lt;String&gt;&gt; songGenres)
    {
        Map&lt;String, Integer&gt; genreCount = new HashMap&lt;&gt;();
        Map&lt;String, String&gt; song2Genre = new HashMap&lt;&gt;();
        Map&lt;String, List&lt;String&gt;&gt; m = new HashMap&lt;&gt;();

        for(Map.Entry&lt;String, List&lt;String&gt;&gt; e : songGenres.entrySet())
        {
            for(String song: e.getValue())
            {
                song2Genre.put(song, e.getKey());
            }
        }
         
        System.out.println(song2Genre);

        for(Map.Entry&lt;String, List&lt;String&gt;&gt; e : userSongs.entrySet())
        {
            List&lt;String&gt; songs = e.getValue();
            String singer = e.getKey();
            genreCount.clear();

            int max = Integer.MIN_VALUE;
            for(String song: songs)
            {
                String genre = song2Genre.get(song);
                genreCount.put(genre, genreCount.getOrDefault(genre,0) +1 );
                max = Math.max( max, genreCount.get(genre));
            }

            for(Map.Entry&lt;String,Integer&gt; gc: genreCount.entrySet())
            {
                if(max==gc.getValue()) 
                {
                    m.put(singer, m.getOrDefault(singer, new ArrayList&lt;String&gt;()));
                    m.get(singer).add(gc.getKey());
                }
            }

            genreCount.clear();
        }

        return m;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_33"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_6" name="code_6" class="center">
<a class=".title">Sub Tree With Maximum Average</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_6">
<code class="language-java">

class SubTreeWithMaximumAverage implements IInterviewQuestion
{
    class RefValue
    {
        public NaryTreeNode maxNode;
    }
    public NaryTreeNode getMaxAverageSubTree(NaryTreeNode root)
    {
        RefValue maxSubTree = new RefValue();
        float[] res = getSumAndAverage(root, maxSubTree);
        return maxSubTree.maxNode;
    }

    public float[] getSumAndAverage(NaryTreeNode root, RefValue maxSubTree)
    {
        if(root==null) return new float[]{0,0, 0};
 
        float sum = root.val;
        float maxAverage = 0;
        float childCount = 0;
        if(root.nodes.size() &gt; 0)
        {
            for(NaryTreeNode child: root.nodes)
            {
                float[] res = getSumAndAverage(child, maxSubTree);     
                sum+= res[0];    
                childCount+=res[2];                      
                if(maxAverage &lt; res[1])
                {                 
                    System.out.print(maxAverage +  &quot; &lt; &quot; + res[1]); 
                    maxAverage = res[1];
                    maxSubTree.maxNode = child;
                    System.out.println(&quot; [&quot; + maxSubTree.maxNode.val +&quot;]&quot;);
                }
            }

            float average = sum / (childCount+1);
            if(maxAverage &lt; average)
            {                 
                System.out.print(maxAverage +  &quot; &lt; &quot; + average); 
                maxAverage = average;
                maxSubTree.maxNode = root;
                System.out.println(&quot; [&quot; + maxSubTree.maxNode.val +&quot;]&quot;);
            }
        }

        return new float[]{sum, maxAverage, childCount + 1};
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_6"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_26" name="code_26" class="center">
<a class=".title">Longest Plaindromic Substring</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_26">
<code class="language-java">
class LongestPlaindromicSubstring implements IInterviewQuestion {

    public String longestPalindrome(String s) {
        if(s==null || s.length() &lt; 2) return s;
        
        int left = 0, right = 0;
        int len = s.length();
        boolean[][] isPalindrome = new boolean[len][len];        
        // P(i,j) answers the question 'is the substring from index i to index j  is a paindrome?'.
        
        // j starts from 1. must compare at least two chars. one char from j, another char from i.
        
        for(int j=1; j &lt; s.length();j++) 
            for(int i=0; i &lt; j ; i++)
            {
                //j-i &lt;=2 means current length doesnt have an inner string to check.
                boolean isInnerPalindrome = isPalindrome[i+1][j-1] || j-i &lt;=2;
                
                if(isInnerPalindrome &amp;&amp; s.charAt(i)==s.charAt(j) )
                {
                     isPalindrome[i][j] = true;
                    if(j-i &gt; right-left) // update current max length
                    {
                        right = j;
                        left = i;
                    }
                }
            }
        return s.substring(left,right+1);
    }

    public String longestPalindrome_ExpandFromCenter(String s) {
        String max = &quot;&quot;;
        
        for(int i=0;i&lt; s.length();i++)
        {
            String s1 = expandFromCenter(s, i, i);
            String s2 = expandFromCenter(s, i, i+1);
            String curMax = (s1.length() &gt; s2.length()) ? s1:s2;
            max = (curMax.length() &gt; max.length()) ? curMax:max;            
        }
        
        return max;
    }
    
    public String expandFromCenter(String s, int l, int r)
    {
        while(l&gt;=0 &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r))
        { 
            l--; r++; 
        }
        
        int len = ((r-1)-(l+1));        
        return s.substring(l+1, r);
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_26"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_13" name="code_13" class="center">
<a class=".title">Rottin Oranges</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_13">
<code class="language-java">
import java.util.LinkedList;
public class RottinOranges  implements IInterviewQuestion {
    //https://leetcode.com/problems/rotting-oranges/
    // Zombie in Matrix: https://leetcode.com/discuss/interview-question/411357/
    // Minium hours to send file to all available servers
    public int orangesRotting(int[][] grid) {
        Queue&lt;Integer[]&gt; q = new LinkedList&lt;&gt;();
        int count =0;
        // push source noddes
        for(int i=0;i&lt;grid.length;i++)
            for(int j=0;j&lt;grid[0].length;j++)
            {
                if(grid[i][j]==2) q.offer(new Integer[] {i,j});
                if(grid[i][j]==1) count++;
            }
        
        if(count==0) return 0; // speicial case. no fresh orange at all from start.
        
        int[][] dir = new int[][]{{0,1},{1,0},{0,-1},{-1,0}};
        int time = -1;
        
        while(q.size() &gt; 0)
        {
            int size = q.size();            
            for(int i=0;i&lt;size;i++) // make sure to go through all nodes in current queue
            {
                Integer[] pos = q.poll(); // get position                        
                for(int j=0;j&lt;dir.length;j++) // get adjacents of adjcent node.
                {
                    int nx= pos[0] + dir[j][0];
                    int ny =pos[1] + dir[j][1];

                    if(nx &lt; 0 || ny &lt; 0 || nx &gt;= grid[0].length || ny &gt;= grid.length) continue;
                    
                    if(grid[ny][nx]==1) // push an adjecent neighor which is a fresh orange in this case
                    { // in scoope
                        count--;
                        grid[ny][nx] = 2; // rotten the tomato, mark as visited
                        q.offer(new Integer[]{ny,nx}); 
                    }
                }      
            }
            
            time++;
        }
        
        return (count==0) ? time:-1; //-1 also means it's not possible to rotten every orange.
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_13"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_27" name="code_27" class="center">
<a class=".title">K Closet Pointsto Origin</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_27">
<code class="language-java">
import java.util.Arrays;
class KClosetPointstoOrigin implements IInterviewQuestion  {

    public int[][] KClosetPoints_Sort(int[][] points, int K) {
        Arrays.sort(points, (p1, p2) -&gt; (p1[0]*p1[0] +p1[1]*p1[1]) - (p2[0]*p2[0] +p2[1]*p2[1]) );
        // int[][] temp = new int[K];
        // for(int i=0;i&lt;K;i++) temp[i]=points[i];
        // return temp;
        return Arrays.copyOfRange(points, 0, K);
    }

    public int[][] KClosetPoints_PQ(int[][] points, int K) {
        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;int[]&gt;(  
            (p1, p2) -&gt; (p2[0]*p2[0] +p2[1]*p2[1]) - (p1[0]*p1[0] +p1[1]*p1[1])  );
        // Max heap means get max value when polling.
        // polled values from the max heap are in an descending order

        // this trick maintains a size K of Max PriorityQueue (Max Heap) to stay N*log(k) time complexity.
        for(int[] p:points) 
        {
            pq.offer(p);
            if(pq.size() &gt; K)  pq.poll();
        }
        // all first N-K items are polled. only last K items remained.
        int[][] res = new int[K][2];
        while(K &gt; 0) res[--K] = pq.poll();
        return res;
    }

    public int[][] KClosetPoints_QSelect(int[][] points, int K) {
        int len =  points.length, l = 0, r = len - 1;
        while (l &lt;= r) {
            int mid = helper(points, l, r);
            if (mid == K) break;
            if (mid &lt; K) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return Arrays.copyOfRange(points, 0, K);
    }
    
    private int helper(int[][] arr, int l, int r) {
        int[] pivot = arr[l];

        while (l &lt; r) {
            while (l &lt; r &amp;&amp; compare(arr[r], pivot) &gt;= 0) r--;
            arr[l] = arr[r];
            while (l &lt; r &amp;&amp; compare(arr[l], pivot) &lt;= 0) l++;
            arr[r] = arr[l];
        }

        arr[l] = pivot;
        return l;
    }
    
    private int compare(int[] p1, int[] p2) {
        return p1[0] * p1[0] + p1[1] * p1[1] - p2[0] * p2[0] - p2[1] * p2[1];
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_27"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_36" name="code_36" class="center">
<a class=".title">Binary Search</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_36">
<code class="language-java">
public class BinarySearch implements IInterviewQuestion, IImportTechnique 
{

    public int binarySearch(int[] arr, int key, boolean lowerBound)
    {
        int left = 0;
        int right = arr.length - 1;
        int lastKeyPos = -1;

        while(left &lt;= right)
        {
            int mid = (left+right) / 2;
            int cur  = arr[mid];

            if(key &gt; cur) left = mid+1;
            else if(key &lt; cur) right = mid-1;
            else // key == cur
            {
                lastKeyPos = mid;

                if(lowerBound) right = mid-1;
                else left = mid+1;
            }
        
        }

        return (lastKeyPos==-1) ? -(left+1) : lastKeyPos;
    }

    public void performTest()
    {
        int[] nums = new int[] { 1,2,2,2,2,3,3,3,4,4,6,6,6,7,8,9,10};
        

        System.out.print(&quot;Array: &quot;);
        for(int i=0;i &lt; nums.length; i++) System.out.print(String.format(&quot;[%2s]&quot;, nums[i]));
        System.out.println();

        System.out.print(&quot;Pos:   &quot;);
        for(int i=0;i &lt; nums.length; i++) System.out.print(String.format(&quot;{%2s}&quot;, i));
        System.out.println();

        System.out.println(&quot;\nLowerBound BinarySearch&quot;);
        for(int i=0;i &lt; 12; i++)
        {
            int insertPosition =  binarySearch(nums, i, true);
            System.out.println(&quot;key = &quot; + i + &quot; =&gt; &quot; + insertPosition);
        }

        System.out.println(&quot;\nUpperBound BinarySearch&quot;);
        for(int i=0;i &lt; 12; i++)
        {
            int insertPosition =  binarySearch(nums, i, false);
            System.out.println(&quot;key = &quot; + i + &quot; =&gt; &quot; + insertPosition);
        }

        System.out.println(&quot;Positive insert position = the actual found key position.&quot;);
        System.out.println(&quot;Negative insert postion (-insertPos -1) = the position of the least integer greater than key &quot;);
    }

    public String toString() { 
        return &quot;Binary Search []&quot;;
    }
}

</code>
</pre>
</div>

<template id="my-label-button-code_36"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_22" name="code_22" class="center">
<a class=".title">Min Cost To Connect All Nodes Or Repair Edges</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_22">
<code class="language-java">
import java.util.*;
class UF {
    private int[] parent;
    private int[] rank;
    private int count;

    public UF(int N)
    {
        count = N;
        parent = new int[N];
        rank = new int[N];
        for(int i=0;i&lt;N;i++)
        {
            parent[i]=i;
            rank[i]=0;
        }
    }

    public int find(int x)
    {
        while(x!=parent[x])
        {
            parent[x] = parent[parent[x]]; // path compresion
            x = parent[x];
        }

        return x;
    }

    // union by rank
    public void union(int x, int y)
    {
        int rootX = find(x);
        int rootY = find(y);
        if(rootX==rootY) return;
        if(rank[rootX] &lt; rank[rootY])
        {
            parent[rootX] = rootY;
        }
        else
        {
            parent[rootY] = rootX;
            if(rank[rootX] == rank[rootY]) rank[rootX]++;            
        }
        count--;
    }

    public int count() { return count; }
    public boolean connected(int x, int y) { return find(x)==find(y); }
}

class MinCostToConnectAllNodesOrRepairEdges implements IInterviewQuestion {

    public static int minCost(int n, int[][] edges, int[][] newEdges) {
        UF uf = new UF(n + 1); // + 1 because nodes are 1-based
        
        Queue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;(newEdges.length, (e1, e2) -&gt; Integer.compare(e1[2], e2[2]));
        HashSet&lt;String&gt; added = new HashSet&lt;&gt;();
        
        for (int[] edge : newEdges) {
            pq.offer(edge);
            added.add(edge[0]+&quot;,&quot;+edge[1]);
        }
                
        for (int[] edge : edges) {
            if(!added.contains(edge[0]+&quot;,&quot;+edge[1])) // ensure the same broken edge is not added.
            {
                pq.offer(new int[]{edge[0],edge[1],0});
            }
        }
        
        int totalCost = 0;
        // 2 because nodes are 1-based and we have 1 unused component at index 0
        while (!pq.isEmpty() &amp;&amp; uf.count() != 2) {
            int[] edge = pq.poll();
            if (!uf.connected(edge[0], edge[1])) {
                uf.union(edge[0], edge[1]);
                totalCost += edge[2];
            }
        }
        return totalCost;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_22"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_5" name="code_5" class="center">
<a class=".title">Top K Frequently Mentioned Keywords</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_5">
<code class="language-java">

public class TopKFrequentlyMentionedKeywords implements IInterviewQuestion
{   // related problems:
    // https://leetcode.com/problems/top-k-frequent-words/
    // https://leetcode.com/problems/top-k-frequent-elements/
    // solution from 35 - 79 = about 45 lines
    public List&lt;String&gt; nlogn_Sort(Map&lt;String,Integer&gt; m, int k)
    {   // sort in a descending order based on word frequency from large to small.
        List&lt;String&gt; res = new ArrayList(m.keySet());
        Collections.sort(res, (w1, w2) -&gt; (m.get(w1) == m.get(w2) ? w1.compareTo(w2) : m.get(w2)-m.get(w1)) );
        return res;
    }

    public List&lt;String&gt; nlogk_Sort(Map&lt;String,Integer&gt; m, int k)
    {   
        // create a min heap to sort from small to large. add to sort. remove to get rid of smallest item.
        PriorityQueue&lt;String&gt; q = new PriorityQueue&lt;&gt;( (w1, w2) -&gt; (m.get(w1) == m.get(w2) ? w2.compareTo(w1) : m.get(w1)-m.get(w2)));
        // if you use max heap, you won't be able to lock insert/delete into log(k) time complexity as we did below.
        for (Map.Entry&lt;String, Integer&gt; entry : m.entrySet()) {
            q.offer(entry.getKey());
            if (q.size() &gt; k) { q.poll(); }  // ensure each insertion only uses log(k)       
        }
    
        //get all elements from the heap
        List&lt;String&gt; res = new ArrayList&lt;&gt;();        
        while (q.size() &gt; 0) {
            String w = q.poll();
            res.add(w);
        }    
        Collections.reverse(res); //reverse the order        
        return res;
    }

    public List&lt;String&gt; TopKFrequent(String[] keywords, String[] reviews, int k, boolean nlogksort )
    {
        Set&lt;String&gt; keywordSet = new HashSet&lt;&gt;(Arrays.asList(keywords)); // remove duplicates from keywrods
        Map&lt;String, Integer&gt; m = new HashMap&lt;&gt;();

        for(String r: reviews)
        {   // split based on non-character. characters:[a-zA-Z0-9_]
            String[] strs = r.split(&quot;\\W&quot;);
            Set&lt;String&gt; inReview = new HashSet&lt;&gt;(Arrays.asList(strs));
            for(String w:inReview)
            {  
                w = w.toLowerCase();  // comparision is CASE-INSENSITIVE
                if(keywordSet.contains(w))
                {
                    m.put(w, m.getOrDefault(w,0)+1);
                }
            }
        }

       List&lt;String&gt; res = nlogksort ? nlogk_Sort(m,k) : nlogn_Sort(m, k);
       return res.subList(0,k); // [0,K)
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_5"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_4" name="code_4" class="center">
<a class=".title">Treasure Island</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_4">
<code class="language-java">
import java.util.ArrayList;
class TreasureIsland implements IInterviewQuestion
{
    public List&lt;int[]&gt; minimumRoute(char[][] maze)
    {
        Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;();
        int count = 0;
        int[][] dir = new int[][] { {0,1},{1,0},{ 0,-1},{-1,0}};
        q.offer(new int[]{0,0});
        maze[0][0]= (char)count++;

        while(q.size() &gt; 0)
        {
            int size = q.size();
            for(int i=0;i&lt;size;i++)
            {
                int[] pos = q.poll();
               // System.out.println(Arrays.toString(pos));
                for(int j=0;j&lt;dir.length;j++)
                {
                    int nx = pos[0] + dir[j][0];
                    int ny = pos[1] + dir[j][1];
                    if(nx &lt; 0 || nx &gt;= maze[0].length || ny &lt; 0 || ny &gt;= maze.length) continue;
                    if(maze[ny][nx]=='O') // only O is walkable
                    {
                        q.offer(new int[] {nx,ny});
                        maze[ny][nx]= (char)count;
                    }
                    else if(maze[ny][nx]=='X')
                    { // found the target
                        System.out.println(&quot;Steps: &quot; + (count));
                        List&lt;int[]&gt; res = createSolution(maze, pos[0], pos[1]);  
                        return res;
                    }
                }

            }
            count++;
        }

        return null;        
    }

    public List&lt;int[]&gt; createSolution(char[][] maze, int lastX, int lastY)
    {
        List&lt;int[]&gt; res = new ArrayList&lt;&gt;();
        Stack&lt;int[]&gt; s = new Stack&lt;&gt;();
        System.out.println(&quot;Creating the solution.&quot;);
        s.push(new int[] {lastX,lastY} );
        int count = (int)(maze[lastY][lastX]);
        count--;
        
        for(int i=0;i&lt;maze.length;i++)
        {
            for(int j=0;j&lt;maze[0].length;j++)
            {
                System.out.print(((char)(maze[i][j]+'0')) + &quot;|&quot;);
            }
            System.out.println();
        }

        while(count &gt;= 0)
        {
            int[][] dir = new int[][] { {0,1},{1,0},{ 0,-1},{-1,0}};
            for(int i=0;i&lt;dir.length;i++)
            {
                int nx = lastX + dir[i][0];
                int ny = lastY + dir[i][1];
                if(nx &lt; 0 || nx &gt;= maze[0].length || ny &lt; 0 || ny &gt;= maze.length) continue;
                if((int)maze[ny][nx]==count) 
                {
                    s.push(new int[] {nx, ny});
                    lastX = nx; lastY = ny;
                    count--;
                    break;
                }
            }
        }

        while(!s.isEmpty()) { res.add(s.pop()); };
        
        return res;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_4"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_25" name="code_25" class="center">
<a class=".title">Longest String With Three Consecutive Characters</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_25">
<code class="language-java">

class LongestStringWithThreeConsecutiveCharacters  implements IInterviewQuestion {
    
    // only work for leetcode 1405. Longest Happy String. at most 3 characters. not a general solution
    public void LongestStringWithAtMostKChar(Map&lt;Character, int[]&gt; map, int K, StringBuilder result) {
        PriorityQueue&lt;Map.Entry&lt;Character, int[]&gt;&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; (b.getValue()[0] - a.getValue()[0]));
        for(Map.Entry&lt;Character, int[]&gt; e : map.entrySet()) {
            q.add(e);
        }
        boolean f = false;
        while(!q.isEmpty()) {
            Map.Entry&lt;Character, int[]&gt; current = q.poll();
            if(current.getValue()[0] &gt; 0 &amp;&amp; current.getValue()[1] &lt; K &amp;&amp; !f) {
                result.append(current.getKey());
                map.put(current.getKey(), new int[]{current.getValue()[0] - 1, current.getValue()[1] + 1});
                f = true;
            } else {
                map.put(current.getKey(), new int[]{current.getValue()[0], 0});   
            }
        }
        if(f) {
            LongestStringWithAtMostKChar(map, K, result);
        }
    }

    // INCORRECT. Find the right solution online.
    public String LongestStringWithKConsecutiveCharacters(HashMap&lt;Character, Integer&gt; m, int k)
    {
        System.out.print(&quot;K = &quot; + k + &quot; | &quot;);
        int maxRepeat = k;
        PriorityQueue&lt;Character&gt; pq = new PriorityQueue&lt;&gt;( (c1, c2) -&gt; ( m.get(c1)==m.get(c2) ? c1-c2 :m.get(c2)-m.get(c1) ) );
        
        Iterator&lt;Map.Entry&lt;Character,Integer&gt;&gt; ite = m.entrySet().iterator();

        while(ite.hasNext())
        {
            Map.Entry&lt;Character,Integer&gt; e = ite.next();
            if(e.getValue()&lt;=0) ite.remove();
        }
        
        for(Character c : m.keySet()) { pq.add(c); }

        StringBuilder s = new StringBuilder();
        Character lastChar = null;

        while(pq.size() &gt; 0)
        {            
            Character c = pq.poll(); // get max value

            if(lastChar == c)
            {
               if(pq.isEmpty()) return s.toString();// + &quot;.... (unable to finish) : NOT POSSIBLE &quot;;
                Character next = pq.poll();
                pq.add(c); // add back;
                c = next;
            }
            
            int count = m.get(c);
        //    System.out.print(&quot; pq:&quot; + pq + &quot; , c=&quot;+ c + &quot; | &quot;);

            if(count &gt; 0)
            {
                for(int i=0;  i &lt; Math.min(maxRepeat,count) ; i++)
                {
                    s.append(c);
                    m.put(c,m.get(c)-1);
                }

                if(m.get(c)&gt;0) pq.add(c); // add back 
            }
            lastChar = c;
        }

        return s.toString();
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_25"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_2" name="code_2" class="center">
<a class=".title">Union Find</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_2">
<code class="language-java">
// https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/unionfind-suan-fa-ying-yong

class UnionFind {
    // 
    private int count;
    // 
    private int[] parent;
    // &ldquo;&rdquo;
    private int[] size;

    public UF(int n) {
        this.count = n;
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i &lt; n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    /*  p  q  */
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;

        // 
        if (size[rootP] &gt; size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
    }

    /*  p  q  */
    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        // 
        return rootP == rootQ;
    }

    /*  x  */
    private int find(int x) {
        while (parent[x] != x) {
            // 
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    public int count() {
        return count;
    }
}

public class Test
{
public boolean equationsPossible(String[] equations) {
    // 26 
    UF uf = new UF(26);
    // 
    for (String eq : equations) {
        if (eq.charAt(1) == '=') {
            char x = eq.charAt(0);
            char y = eq.charAt(3);
            uf.union(x - 'a', y - 'a');
        }
    }
    // 
    for (String eq : equations) {
        if (eq.charAt(1) == '!') {
            char x = eq.charAt(0);
            char y = eq.charAt(3);
            // 
            if (uf.connected(x - 'a', y - 'a'))
                return false;
        }
    }
    return true;
}

public  void solve(char[][] board) {
    if (board.length == 0) return;

    int m = board.length;
    int n = board[0].length;
    //  dummy 
    UF uf = new UF(m * n + 1);
    int dummy = m * n;
    //  O  dummy 
    for (int i = 0; i &lt; m; i++) {
        if (board[i][0] == 'O')
            uf.union(i * n, dummy);
        if (board[i][n - 1] == 'O')
            uf.union(i * n + n - 1, dummy);
    }
    //  O  dummy 
    for (int j = 0; j &lt; n; j++) {
        if (board[0][j] == 'O')
            uf.union(j, dummy);
        if (board[m - 1][j] == 'O')
            uf.union(n * (m - 1) + j, dummy);
    }
    //  d 
    int[][] d = new int[][]{{1,0}, {0,1}, {0,-1}, {-1,0}};
    for (int i = 1; i &lt; m - 1; i++) 
        for (int j = 1; j &lt; n - 1; j++) 
            if (board[i][j] == 'O')
                //  O  O 
                for (int k = 0; k &lt; 4; k++) {
                    int x = i + d[k][0];
                    int y = j + d[k][1];
                    if (board[x][y] == 'O')
                        uf.union(x * n + y, i * n + j);
                }
    //  dummy  O
    for (int i = 1; i &lt; m - 1; i++) 
        for (int j = 1; j &lt; n - 1; j++) 
            if (!uf.connected(dummy, i * n + j))
                board[i][j] = 'X';
}
    
public static void main(String[] args)
{
    
}
    
}

</code>
</pre>
</div>

<template id="my-label-button-code_2"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_17" name="code_17" class="center">
<a class=".title">Optimal Utilization</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_17">
<code class="language-java">
import java.util.*;
class OptimalUtilization implements IInterviewQuestion
{ // quite correct result.

    public int binarySearch(int[][] sorted, int target, boolean lowerBound)
    {
        int l = 0;
        int r = sorted.length -1;
        int mid = 0;
        int lastKeyPos = -1;
        while(l &lt;= r)
        {
            mid = (l+r)/2;
            int x = sorted[mid][1];

            if(target &lt; x) r= mid-1;
            else if(target &gt; x) l= mid +1;
            else
            {
                lastKeyPos = mid;
                if(lowerBound) r= mid-1;
                else l = mid +1;                
            }
        }

        return (lastKeyPos==-1) ? -(l+1): lastKeyPos;
    }

    // get target sum or closet sum answer from two non-sorted array
    // if no target answer, we only pick the closet sum answer. 
    // for example, target = 20. if next sum answer is 19,18, we only pick all answers of 19.
    // better than Brute Force. 
    public List&lt;List&lt;Integer&gt;&gt; getOptimalUtilization(int[][] a, int[][] b, int target)
    {   
        Arrays.sort(a, (i,j) -&gt; i[1]-j[1]);
        Arrays.sort(b, (i,j) -&gt; i[1]-j[1]);

        int l = 0;
        int r = b.length-1;
        int minCloset = Integer.MAX_VALUE;
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();

        while(l &lt; a.length &amp;&amp; r &gt;= 0)
        {
            int sum = a[l][1] + b[r][1];
            int diff = sum - target ;

            if(sum &gt; target ) r--;
            else {
                
                if(diff&lt;= 0)
                {
                    diff = Math.abs(diff);
                    if(minCloset &gt; diff)
                    {
                        minCloset = diff;
                        res.clear(); 
                        res.add(Arrays.asList( a[l][0], b[r][0]));                  
                    }
                    else if(minCloset == diff)
                    {
                        res.add(Arrays.asList( a[l][0], b[r][0]));                  
                    }
                }

                l++;
            }

        }

        return res;
    }

    // binary search approach
    public List&lt;List&lt;Integer&gt;&gt; binarySearch_getOptimalUtilization(int[][] a, int[][] b, int target)
    {   
        Arrays.sort(a, (i,j) -&gt; i[1]-j[1] ); 
        Arrays.sort(b, (i,j) -&gt; i[1]-j[1] ); 
        List&lt;int[]&gt; candidates = new ArrayList&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        int k =  b.length-1;
        
        while(k  &gt;= 0) 
        {
            int complement = target - b[k][1];
            int index = binarySearch(a, complement, true); 
           // System.out.println(&quot;found at &quot; + index + &quot; for key = &quot; + complement );
           if(index &lt; 0) { 
            index = -index -1; // index of the least integer greater than key
            index = index -1; // index of the greatest integer less than key
           }

            while(index &gt;= 0 &amp;&amp; index &lt; a.length) 
            {
            int diff = target - (a[index][1]+ b[k][1]);
            candidates.add(new int[]{a[index][0], b[k][0], diff }  );
            index--;
            }
           
            k--;
        }

        Collections.sort(candidates, (i , j) -&gt;  i[2]-j[2]  );

        Integer[] lastDiff = { null};

        candidates.forEach( p -&gt; {            
            if(lastDiff[0]==null || lastDiff[0]==p[2])
            {
  //              System.out.println(&quot;(&quot; + Arrays.toString(p) + &quot;)&quot;);
                res.add(Arrays.asList(p[0],p[1]) );
                lastDiff[0] = p[2];
            }
        });

        return res;
    }
    
    // same as binarsearch. TreeMap can be used for two dimension array source
    public List&lt;List&lt;Integer&gt;&gt; TreeMap_getOptimalUtilization(int[][] a, int[][] b, int target)
    {   
        TreeMap&lt;Integer,Integer&gt; pos = new TreeMap&lt;&gt;();
        List&lt;int[]&gt; candidates = new ArrayList&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();

        for(int i=0; i &lt; a.length;i++)
        {
            pos.put(a[i][1],a[i][0]);
        }

        Arrays.sort(b, (i,j) -&gt; i[1]-j[1] ); 

        int k = b.length -1;
        while(k&gt;0)
        {
            int complement = target-b[k][1];
            Map&lt;Integer,Integer&gt; candidate = pos.headMap(complement, true);

            for(Map.Entry&lt;Integer,Integer&gt; e : candidate.entrySet())
            {
                int index = e.getValue();
                int value = e.getKey();
                int diff = target - (value+ b[k][1]);
                candidates.add(new int[]{ index , b[k][0], diff});
            }
            
            k--;
        }

        Collections.sort(candidates, (i , j) -&gt;  i[2]-j[2]  );

        Integer[] lastDiff = { null};

        candidates.forEach( p -&gt; {            
            if(lastDiff[0]==null || lastDiff[0]==p[2])
            {
//                System.out.println(&quot;(&quot; + Arrays.toString(p) + &quot;)&quot;);
                res.add(Arrays.asList(p[0],p[1]) );
                lastDiff[0] = p[2];
            }
        });

        return res;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_17"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_34" name="code_34" class="center">
<a class=".title">Critical Routers Or Connections</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_34">
<code class="language-java">

import java.util.ArrayList;
import java.util.List;
import java.util.HashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;



public class CriticalRoutersOrConnections implements IInterviewQuestion 
{
    class Graph&lt;T&gt;
    {
        private Map&lt;T, List&lt;T&gt;&gt; adjList = new HashMap&lt;&gt;();
        private int time = 0;

        public void addEdges(T[][] edges)
        {
            for(int i=0;i&lt;edges.length;i++)
            {
                addEdge(edges[i][0], edges[i][1]);
            }
        }

        public void clear()
        {
            adjList.clear();
        }

        public void addEdge(T u, T v)
        {
            addEdge(u, v, true);
        }

        public void addEdge(T u, T v, boolean biDir)
        {
            adjList.put(u, adjList.getOrDefault(u, new ArrayList&lt;T&gt;()));
            adjList.get(u).add(v);
            if(biDir)
            {
                adjList.put(v, adjList.getOrDefault(v, new ArrayList&lt;T&gt;()));
                adjList.get(v).add(u);
            }
        }        

        public void findCutPoints(T node, Map&lt;T, Boolean&gt; visited, Map&lt;T, T&gt; parent,  Map&lt;T, Integer&gt; disc, Map&lt;T, Integer&gt; low, Set&lt;T&gt; ap, Map&lt;T, List&lt;T&gt;&gt; bridges)
        {
            int children = 0;
            visited.put(node, true);
            time++;
            disc.put(node, time);
            low.put(node, time);
                        
            for(T adjNode: adjList.get(node))
            {
                if(visited.get(adjNode)==false)
                {
                    children++;
                    parent.put(adjNode,node);
                    findCutPoints(adjNode, visited, parent, disc, low, ap, bridges);
                    low.put(node, Math.min(low.get(node), low.get(adjNode) ) );
                    
                    // this piece of code is to determine cut points
                    if(ap!=null)
                    {
                        if(parent.get(node)==null &amp;&amp; children &gt; 1) ap.add(node);
                        if(parent.get(node) != null &amp;&amp; low.get(adjNode) &gt;= disc.get(node)) // &gt; for bridges, &gt;= for points
                            ap.add(node);
                    }

                    // this piece of code is to determine. &gt; for bridges, &gt;= for points
                    if(bridges != null)
                    {
                        if(low.get(adjNode) &gt; disc.get(node)) {
                            bridges.put(node, bridges.getOrDefault(node, new ArrayList&lt;T&gt;()) );
                            bridges.get(node).add(adjNode);
                        }
                    }

                }
                else if(visited.get(adjNode)== true &amp;&amp; adjNode != parent.get(node) )
                {
                    low.put(node, Math.min(low.get(node), disc.get(adjNode) ) );
                }

            }
        }

        public Set&lt;T&gt; findCutPoints()
        {
            Map&lt;T, Boolean&gt; visited = new HashMap&lt;&gt;();
            Map&lt;T, T&gt; parent= new HashMap&lt;&gt;();
            Map&lt;T, Integer&gt; low= new HashMap&lt;&gt;();
            Map&lt;T, Integer&gt; disc= new HashMap&lt;&gt;();
            Set&lt;T&gt; ap = new HashSet&lt;T&gt;();
            time = 0;
            for(T node: adjList.keySet())
            {
                visited.put(node, false);
                parent.put(node, null); // root by deafult
                low.put(node, 0);
                disc.put(node, 0);
            }
    
            for(T node: adjList.keySet())
            {
                if(visited.get(node)==false)
                findCutPoints(node, visited, parent, disc, low, ap, null);
            }

            return ap;
        }

        public Map&lt;T, List&lt;T&gt;&gt; findBridges()
        {
            Map&lt;T, Boolean&gt; visited = new HashMap&lt;&gt;();
            Map&lt;T, T&gt; parent= new HashMap&lt;&gt;();
            Map&lt;T, Integer&gt; low= new HashMap&lt;&gt;();
            Map&lt;T, Integer&gt; disc= new HashMap&lt;&gt;();
            Map&lt;T, List&lt;T&gt;&gt; bridges = new HashMap&lt;&gt;();

            time = 0;

            for(T node: adjList.keySet())
            {
                visited.put(node, false);
                parent.put(node, null); // root by deafult
                low.put(node, 0);
                disc.put(node, 0);
            }
    
            for(T node: adjList.keySet())
            {
                if(visited.get(node)==false)
                findCutPoints(node, visited, parent, disc, low, null, bridges);
            }

            return bridges;
        }
    }

    public void performTest()
    {
        Graph&lt;Integer&gt;  g = new Graph&lt;&gt;();

        // https://leetcode.com/discuss/interview-question/436073/
        g.addEdges(new Integer[][] { {0, 1}, {0, 2}, {1, 3}, {2, 3}, {2, 5}, {5, 6}, {3, 4} });
        System.out.println(&quot;Cut Points :&quot; +  g.findCutPoints() );

        // https://leetcode.com/problems/critical-connections-in-a-network/
        g.clear();
        g.addEdges(new Integer[][] { {1, 2}, {1, 3}, {3, 4}, {1, 4}, {4, 5}} );
        System.out.println(&quot;Bridges (Cut Edges) :&quot; + g.findBridges() );
        g.clear();
        g.addEdges(new Integer[][] { {1, 2}, {1, 3}, {2, 3}, {2, 4}, {2, 5}, {4, 6}, {5, 6} } );
        System.out.println(&quot;Bridges (Cut Edges) :&quot; + g.findBridges() );
        g.clear();
        g.addEdges(new Integer[][] { {1, 2}, {1, 3}, {2, 3}, {3, 4}, {3, 6}, {4, 5}, {6, 7}, {6, 9}, {7, 8}, {8, 9} } );
        System.out.println(&quot;Bridges (Cut Edges) :&quot; + g.findBridges() );
    }

    public String toString() { return &quot;Critical Routers &amp; Connections, Articulation Points/Cut Point, Bridges/Cut Edges ([E]**):&quot;;}

}

</code>
</pre>
</div>

<template id="my-label-button-code_34"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_28" name="code_28" class="center">
<a class=".title">Java Collections</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_28">
<code class="language-java">
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.Collection;
import java.util.Collections;
import java.util.PriorityQueue;
import java.util.Queue;

import java.util.Iterator;


public class JavaCollections implements IInterviewQuestion, IImportTechnique  {
    public void performTest()
    {
        System.out.println(&quot;Priorty Queue:&quot;);
        PriorityQueue&lt;Integer&gt; pq=new PriorityQueue&lt;&gt;(); // min heap/priority queue by deafult
        int[] points = new int[] { 1,10,3,6,5,8,7,4,9,2}; int K = 3;

        for(int pValue: points) { pq.offer(pValue); }

        // print heap array content (in an array order)
        for(Integer p: pq) { System.out.print(p+ &quot; &quot;); } System.out.println();        

        // how to iterate through PriorityQueue without affectint pq heap content
        Iterator itr = pq.iterator(); 
        while (itr.hasNext()) { System.out.print(itr.next()+ &quot; &quot;);  } System.out.println();
       
        while(pq.size() &gt; 0) { System.out.print(pq.poll()+ &quot; &quot;); } System.out.println();

        Queue&lt;Integer&gt; pq2=new PriorityQueue&lt;&gt;(Collections.reverseOrder()); // max heap/priority queue

        for(int pValue: points) { pq2.offer(pValue); }
        while(pq2.size() &gt; 0) { System.out.print(pq2.poll()+ &quot; &quot;); } System.out.println();
   
        // a trick to stay N*log(k) time complexity for Max Priority Queue to get top k minimum in descending order (max-heap max first out)
        // without this trick, it's N*log(N) time complexity.
        // Min Priority Queue = N*log(N) since you need to put all numbers into the pq first.
        // Min Priority Queue with the trick won't work since you will get top k max in an ascending order. (min-heap min first out)
        for(int pValue: points) 
        {
            pq2.offer(pValue);
            if(pq2.size() &gt; K)  pq2.poll();
        }

        // print the result        
        while(!pq2.isEmpty()) { System.out.print(pq2.poll() + &quot; &quot;); } System.out.println();
    
        // add() vs offer(), remove() vs poll(), element() vs peek().
        // add() from Collection can't return false and throw an exception if an element cannot be added.
        // offer() from Queue returns false if an element cannot be added.
        // when the queue is empty, element() and remove() from Collection throws NoSuchElementException, while poll() &amp; peek() return null.
        /*
           add Throws:
            IllegalStateException - if the element cannot be added at this time due to capacity restrictions
            ClassCastException - if the class of the specified element prevents it from being added to this queue.
                for example, adding another type of object into a non-generic ArrayList.
            NullPointerException - if the specified element is null and this queue does not permit null elements
            IllegalArgumentException - if some property of this element prevents it from being added to this queue
        */

        System.out.println(&quot;HashMap:&quot;);

        HashMap&lt;Integer, String&gt; m = new HashMap&lt;&gt;();
        m.put(11, &quot;AB&quot;);
        m.put(2, &quot;CD&quot;);
        m.put(33, &quot;EF&quot;);
        m.put(9, &quot;GH&quot;);
        m.put(3, &quot;IJ&quot;);    

        for(Map.Entry e: m.entrySet() ) { System.out.print(&quot;{&quot; + e.getKey() + &quot;=&gt;&quot; + e.getValue() + &quot;},&quot;); }  System.out.println();

        HashMap&lt;Integer,String&gt; m2 = (HashMap)m.clone();
        
        for(Map.Entry&lt;Integer,String&gt; e: m2.entrySet() ) { System.out.print(&quot;{&quot; + e.getKey() + &quot;=&gt;&quot; + e.getValue() + &quot;},&quot;); } System.out.println();   
        m2.clear();
        m2.putAll(m);        Iterator mItr = m2.entrySet().iterator();
        while(mItr.hasNext()) { Map.Entry e = (Map.Entry)mItr.next(); System.out.print(&quot;{&quot; + e.getKey() + &quot;=&gt;&quot; + e.getValue() + &quot;},&quot;); } System.out.println();

        /*  HashSet &amp; HashMap doesn't maintain any kind of order of its elements.
            LinkedHashSet &amp; LinkedHashMap maintains insertion order.
            TreeSet &amp; TreeMap sort the entries in ascending order of keys and they don't allow null key and throw NullPointerException.
            Set -&gt; contains
            Map -&gt; containsKey, containsValue
        */        

        Set&lt;Integer&gt; set = m2.keySet();
        Iterator&lt;Integer&gt; ite2 = set.iterator();
        while(ite2.hasNext()) { System.out.print(ite2.next() + &quot;,&quot;); } System.out.println();

        Collection&lt;String&gt; values = m2.values();
        for(String s: values) { System.out.print(s + &quot;,&quot;); } System.out.println();
        Iterator&lt;String&gt; ite3 = values.iterator();
        while(ite3.hasNext()) { System.out.print(ite3.next() + &quot;,&quot;); } System.out.println();

        System.out.println(&quot;hello&quot;);

    }
    
    public String toString() { 
        return &quot;Mastering JavaCollectionsn [https://beginnersbook.com/2013/12/how-to-loop-hashmap-in-java/]&quot;;
    }
}

/*

- Use Comparator when you need more flexibilit
** The compareTo() method will return a positive number if one object is greater than the other, negative if it&rsquo;s lower, and zero if they are the same.

import java.util.Comparator;

public class MyComparator implements Comparator&lt;String&gt;
{
   @Override // ascending order based on String length
   public int compare(String x, String y) { return x.length() - y.length();}
}

or you can replace everything before Comparator using new keyword as below.

Collections.sort(strArr, new Comparator&lt;String&gt;
{
   @Override // ascending order based on String length
   public int compare(String x, String y) { return x.length() - y.length();}
});

Using Comparator with lambda expressions as below:
Collections.sort(strArr, (x, y) -&gt; x.length() - y.length()  );

You always use compareTo for a String/object.
Collections.sort(strArr, (s1, s2) -&gt; s1.compareTo(s2));

even shorter with
Collections.sort(strArr, Comparator.naturalOrder() );

    // ascending order means to arrange values from smallest to largest.
    // descending order means to arrange values from largest to smallest.

    // ascending order based on value
    public int compare(Integer x, Integer y) { return x - y;}
    // descending order based on value
    public int compare(Integer x, Integer y) { return y - x;}

    // sort by id in ascending order. when ids are the same, sort by their name in alphabetic order.
    public int compare(User x, User y) { return x.id == y.id ? x.name.compareTo(y)  : x.id-y.id  ;}
    (x,y) -&gt; x.id==y.id ? x.name.compareTo(y) : x.id-y.id;

    // sort by map value in ascending order. When map value are the same, sort by the name in alphabetic order.
    public int compare(String s1, String s2) { return count.get(s1) == count.get(s2) ? s1.compareTo(s2)  : count.get(s1)-count.get(s2); }
    (s1,s2) -&gt; count.get(s1)==count.get(s2) ? s1.compareTo(s2) : count.get(s1)-count.get(s2);

    Sorting a Map with TreeMap
    Map&lt;String, Integer&gt; m  = new TreeMap&lt;&gt;();
    m.put(&quot;DEF&quot;, 10);
    m.put(&quot;ABC&quot;, 20);
    System.out.println(m);

    Sorting a Set with TreeSet
    Set&lt;String&gt; s  = new TreeSet&lt;&gt;();
    s.put(&quot;DEF&quot;);
    s.put(&quot;ABC&quot;);
    System.out.println(m);
*/
</code>
</pre>
</div>

<template id="my-label-button-code_28"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>


  
	</body>
</html>
