<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Atomic Habit</title>
    <link rel="stylesheet" type="text/css" href="prism.css" />
    <style>
      .center {
          margin: auto;
          width: 820px;
          border: 1px solid black;
          padding: 0 0 0 0;
          font-size: 11px;
          line-height: 14px;
        }

      .noscrollbar {
        overflow: hidden;
      }

      .token.number {
        color: lightblue;
      }

      
    </style>
		<script src="prism.js" type="text/javascript"></script>
		<script src="main.js" type="text/javascript"></script>

<script>


  </script>
	</head>
	<body>
	
  <!-- table of contents -->
	<ul>
    <li id="li_1" name="li_1" data-id=""><input type="checkbox" id="checkbox_1" name="checkbox_1" /><a href="#code_1">Window</a></li>
<li id="li_2" name="li_2" data-id=""><input type="checkbox" id="checkbox_2" name="checkbox_2" /><a href="#code_2">Union Find</a></li>
<li id="li_3" name="li_3" data-id=""><input type="checkbox" id="checkbox_3" name="checkbox_3" /><a href="#code_3">Tree Node</a></li>
<li id="li_4" name="li_4" data-id=""><input type="checkbox" id="checkbox_4" name="checkbox_4" /><a href="#code_4">Treasure Island 2</a></li>
<li id="li_5" name="li_5" data-id=""><input type="checkbox" id="checkbox_5" name="checkbox_5" /><a href="#code_5">Treasure Island</a></li>
<li id="li_6" name="li_6" data-id=""><input type="checkbox" id="checkbox_6" name="checkbox_6" /><a href="#code_6">Top K Frequently Mentioned Keywords</a></li>
<li id="li_7" name="li_7" data-id=""><input type="checkbox" id="checkbox_7" name="checkbox_7" /><a href="#code_7">Test Class</a></li>
<li id="li_8" name="li_8" data-id=""><input type="checkbox" id="checkbox_8" name="checkbox_8" /><a href="#code_8">Sub Tree With Maximum Average</a></li>
<li id="li_9" name="li_9" data-id=""><input type="checkbox" id="checkbox_9" name="checkbox_9" /><a href="#code_9">Subtree Of Another Tree</a></li>
<li id="li_10" name="li_10" data-id=""><input type="checkbox" id="checkbox_10" name="checkbox_10" /><a href="#code_10">Substrings Of Size Kwith K Distinct Chars</a></li>
<li id="li_11" name="li_11" data-id=""><input type="checkbox" id="checkbox_11" name="checkbox_11" /><a href="#code_11">Substrings Of Exactly K Distinct Chars</a></li>
<li id="li_12" name="li_12" data-id=""><input type="checkbox" id="checkbox_12" name="checkbox_12" /><a href="#code_12">Subarrays With K Different Integers</a></li>
<li id="li_13" name="li_13" data-id=""><input type="checkbox" id="checkbox_13" name="checkbox_13" /><a href="#code_13">Search Suggestion System</a></li>
<li id="li_14" name="li_14" data-id=""><input type="checkbox" id="checkbox_14" name="checkbox_14" /><a href="#code_14">Search Matrix</a></li>
<li id="li_15" name="li_15" data-id=""><input type="checkbox" id="checkbox_15" name="checkbox_15" /><a href="#code_15">Rottin Oranges</a></li>
<li id="li_16" name="li_16" data-id=""><input type="checkbox" id="checkbox_16" name="checkbox_16" /><a href="#code_16">Reorder Data In Log File</a></li>
<li id="li_17" name="li_17" data-id=""><input type="checkbox" id="checkbox_17" name="checkbox_17" /><a href="#code_17">Prison Cells After N Days</a></li>
<li id="li_18" name="li_18" data-id=""><input type="checkbox" id="checkbox_18" name="checkbox_18" /><a href="#code_18">Partition Label</a></li>
<li id="li_19" name="li_19" data-id=""><input type="checkbox" id="checkbox_19" name="checkbox_19" /><a href="#code_19">Optimal Utilization</a></li>
<li id="li_20" name="li_20" data-id=""><input type="checkbox" id="checkbox_20" name="checkbox_20" /><a href="#code_20">Number Of Clusters</a></li>
<li id="li_21" name="li_21" data-id=""><input type="checkbox" id="checkbox_21" name="checkbox_21" /><a href="#code_21">Nth Geometric Progression</a></li>
<li id="li_22" name="li_22" data-id=""><input type="checkbox" id="checkbox_22" name="checkbox_22" /><a href="#code_22">Most Common Word</a></li>
<li id="li_23" name="li_23" data-id=""><input type="checkbox" id="checkbox_23" name="checkbox_23" /><a href="#code_23">Minimum Cost To Connect Rope</a></li>
<li id="li_24" name="li_24" data-id=""><input type="checkbox" id="checkbox_24" name="checkbox_24" /><a href="#code_24">Min Cost To Connect All Nodes Or Repair Edges</a></li>
<li id="li_25" name="li_25" data-id=""><input type="checkbox" id="checkbox_25" name="checkbox_25" /><a href="#code_25">Merge Two Sorted List</a></li>
<li id="li_26" name="li_26" data-id=""><input type="checkbox" id="checkbox_26" name="checkbox_26" /><a href="#code_26">Merge Intervals</a></li>
<li id="li_27" name="li_27" data-id=""><input type="checkbox" id="checkbox_27" name="checkbox_27" /><a href="#code_27">Longest String With Three Consecutive Characters</a></li>
<li id="li_28" name="li_28" data-id=""><input type="checkbox" id="checkbox_28" name="checkbox_28" /><a href="#code_28">Longest Plaindromic Substring</a></li>
<li id="li_29" name="li_29" data-id=""><input type="checkbox" id="checkbox_29" name="checkbox_29" /><a href="#code_29">K Closet Pointsto Origin</a></li>
<li id="li_30" name="li_30" data-id=""><input type="checkbox" id="checkbox_30" name="checkbox_30" /><a href="#code_30">Java Collections</a></li>
<li id="li_31" name="li_31" data-id=""><input type="checkbox" id="checkbox_31" name="checkbox_31" /><a href="#code_31">Generate Parentheses</a></li>
<li id="li_32" name="li_32" data-id=""><input type="checkbox" id="checkbox_32" name="checkbox_32" /><a href="#code_32">Find Unique Pairs With Given Sum</a></li>
<li id="li_33" name="li_33" data-id=""><input type="checkbox" id="checkbox_33" name="checkbox_33" /><a href="#code_33">Find Pair With Given Sum</a></li>
<li id="li_34" name="li_34" data-id=""><input type="checkbox" id="checkbox_34" name="checkbox_34" /><a href="#code_34">Find N Unique Integers Sum Up To Zero</a></li>
<li id="li_35" name="li_35" data-id=""><input type="checkbox" id="checkbox_35" name="checkbox_35" /><a href="#code_35">Favorite Genres</a></li>
<li id="li_36" name="li_36" data-id=""><input type="checkbox" id="checkbox_36" name="checkbox_36" /><a href="#code_36">Critical Routers Or Connections</a></li>
<li id="li_37" name="li_37" data-id=""><input type="checkbox" id="checkbox_37" name="checkbox_37" /><a href="#code_37">Copy Random Linked List</a></li>
<li id="li_38" name="li_38" data-id=""><input type="checkbox" id="checkbox_38" name="checkbox_38" /><a href="#code_38">Binary Search</a></li>

  </ul>
  
  
<div id="code_1" name="code_1" class="center">
<a class=".title">Window</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_1">
<code class="language-java">
import java.util.Map;
import java.util.HashMap;

class Window&lt;E&gt;
{
    Map&lt;E,Integer&gt; m = new HashMap&lt;&gt;();
    int kinds = 0; // the total number of types available in the map
    
    public Window() {}
    
    public void add(E x)
    {
        m.put(x, m.getOrDefault(x,0)+1);
        if(m.get(x)==1) kinds++;
    }
    
    public void remove(E x)
    {
        m.put(x, m.get(x)-1);
        if(m.get(x)==0) kinds--;
    }
    
    public int kinds() { return kinds; }
}
</code>
</pre>
</div>

<template id="my-label-button-code_1"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_2" name="code_2" class="center">
<a class=".title">Union Find</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_2">
<code class="language-java">
// https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/unionfind-suan-fa-ying-yong

class UnionFind {
    // 记录连通分量个数
    private int count;
    // 存储若干棵树
    private int[] parent;
    // 记录树的&ldquo;重量&rdquo;
    private int[] size;

    public UF(int n) {
        this.count = n;
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i &lt; n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    /* 将 p 和 q 连通 */
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;

        // 小树接到大树下面，较平衡
        if (size[rootP] &gt; size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
    }

    /* 判断 p 和 q 是否互相连通 */
    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        // 处于同一棵树上的节点，相互连通
        return rootP == rootQ;
    }

    /* 返回节点 x 的根节点 */
    private int find(int x) {
        while (parent[x] != x) {
            // 进行路径压缩
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    public int count() {
        return count;
    }
}

public class Test
{
public boolean equationsPossible(String[] equations) {
    // 26 个英文字母
    UF uf = new UF(26);
    // 先让相等的字母形成连通分量
    for (String eq : equations) {
        if (eq.charAt(1) == '=') {
            char x = eq.charAt(0);
            char y = eq.charAt(3);
            uf.union(x - 'a', y - 'a');
        }
    }
    // 检查不等关系是否打破相等关系的连通性
    for (String eq : equations) {
        if (eq.charAt(1) == '!') {
            char x = eq.charAt(0);
            char y = eq.charAt(3);
            // 如果相等关系成立，就是逻辑冲突
            if (uf.connected(x - 'a', y - 'a'))
                return false;
        }
    }
    return true;
}

public  void solve(char[][] board) {
    if (board.length == 0) return;

    int m = board.length;
    int n = board[0].length;
    // 给 dummy 留一个额外位置
    UF uf = new UF(m * n + 1);
    int dummy = m * n;
    // 将首列和末列的 O 与 dummy 连通
    for (int i = 0; i &lt; m; i++) {
        if (board[i][0] == 'O')
            uf.union(i * n, dummy);
        if (board[i][n - 1] == 'O')
            uf.union(i * n + n - 1, dummy);
    }
    // 将首行和末行的 O 与 dummy 连通
    for (int j = 0; j &lt; n; j++) {
        if (board[0][j] == 'O')
            uf.union(j, dummy);
        if (board[m - 1][j] == 'O')
            uf.union(n * (m - 1) + j, dummy);
    }
    // 方向数组 d 是上下左右搜索的常用手法
    int[][] d = new int[][]{{1,0}, {0,1}, {0,-1}, {-1,0}};
    for (int i = 1; i &lt; m - 1; i++) 
        for (int j = 1; j &lt; n - 1; j++) 
            if (board[i][j] == 'O')
                // 将此 O 与上下左右的 O 连通
                for (int k = 0; k &lt; 4; k++) {
                    int x = i + d[k][0];
                    int y = j + d[k][1];
                    if (board[x][y] == 'O')
                        uf.union(x * n + y, i * n + j);
                }
    // 所有不和 dummy 连通的 O，都要被替换
    for (int i = 1; i &lt; m - 1; i++) 
        for (int j = 1; j &lt; n - 1; j++) 
            if (!uf.connected(dummy, i * n + j))
                board[i][j] = 'X';
}
    
    

public static void main(String[] args)
{
    
}
    
}

</code>
</pre>
</div>

<template id="my-label-button-code_2"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_3" name="code_3" class="center">
<a class=".title">Tree Node</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_3">
<code class="language-java">
import java.util.*;

// https://github.com/nykevinwong/TreeAlgorithm/blob/master/TreeTraversal.cs
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {  }
    TreeNode(int x) { val = x; }

    public static TreeNode createBinaryTreeFromArray(Integer[] arr)
    {
        return createBinaryTreeFromArray(arr, 0);
    }

    protected static TreeNode createBinaryTreeFromArray(Integer [] arr, int index)
    {
        if(arr.length &gt; index)
        {
            if(arr[index]==null) return null;

            TreeNode node = new TreeNode(arr[index]);
            node.left = createBinaryTreeFromArray(arr, 2*index+1);
            node.right = createBinaryTreeFromArray(arr, 2*index+2);
            return node;
        }
        return null;
    }
}


class NaryTreeNode {
int val;
List&lt;NaryTreeNode&gt; nodes = new ArrayList&lt;NaryTreeNode&gt;();

public NaryTreeNode(int val) { this.val = val; }
public void addNode(NaryTreeNode node)
{
   if(!nodes.contains(node)) nodes.add(node);
}

public void addNodes(int[] arr)
{
   for(int val: arr) { nodes.add(new NaryTreeNode(val)); }
}
}
</code>
</pre>
</div>

<template id="my-label-button-code_3"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_4" name="code_4" class="center">
<a class=".title">Treasure Island 2</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_4">
<code class="language-java">
import java.util.LinkedList;
import java.util.Queue;

class TreasureIsland2 implements IInterviewQuestion
{
    public int minimumRoute(char[][] maze)
    {
        Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;();
        int[][] dir = new int[][] { {0,1}, {0,-1}, {1,0}, {-1,0} };

        for(int i=0;i&lt; maze.length;i++)
        {
            for(int j=0; j &lt; maze[0].length;j++)
            {
                if(maze[i][j]=='S')
                {
                    q.add(new int[] {j, i});
                }
            }
        }
        
        int count = 0;
        while(q.size() &gt; 0)
        {
            int size = q.size();

            for(int i=0;i&lt;size;i++)
            {
                int[] pos = q.poll();
                for(int k=0;k&lt;dir.length;k++)
                {
                    int nx = pos[0] + dir[k][0];
                    int ny = pos[1] + dir[k][1];
                    if(nx &lt;0 || nx &gt;= maze[0].length || ny &lt;0 || ny &gt;= maze.length) continue;

                    if(maze[ny][nx]=='O') 
                    {
                        maze[ny][nx] = 'D'; // visited
                        q.add(new int[] {nx, ny });
                    }
                    else if(maze[ny][nx]=='X')
                    {
                        return count; // found it
                    }
                }
            }
            count++;
        }

        return count;
    }

    public void performTest()
    {
        int minStep = minimumRoute(new char[][] {
            {'S','O','O','S','S'},
            {'D','O','D','O','D'},
            {'O','O','O','O','O'},
            {'X','D','D','O','O'},
            {'X','D','D','D','O'},
        });

        System.out.println(&quot;Min Steps: &quot; + minStep);
    }
    
    public String toString() { return &quot;Treasure Island 2 [https://leetcode.com/discuss/interview-question/356150]: &quot;;}
}

</code>
</pre>
</div>

<template id="my-label-button-code_4"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_5" name="code_5" class="center">
<a class=".title">Treasure Island</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_5">
<code class="language-java">
import java.util.ArrayList;
import java.util.List;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;


class TreasureIsland implements IInterviewQuestion
{
    public List&lt;int[]&gt; minimumRoute(char[][] maze)
    {
        Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;();
        int count = 0;
        int[][] dir = new int[][] { {0,1},{1,0},{ 0,-1},{-1,0}};
        q.offer(new int[]{0,0});
        maze[0][0]= (char)count++;

        while(q.size() &gt; 0)
        {
            int size = q.size();
            for(int i=0;i&lt;size;i++)
            {
                int[] pos = q.poll();
               // System.out.println(Arrays.toString(pos));
                for(int j=0;j&lt;dir.length;j++)
                {
                    int nx = pos[0] + dir[j][0];
                    int ny = pos[1] + dir[j][1];
                    if(nx &lt; 0 || nx &gt;= maze[0].length || ny &lt; 0 || ny &gt;= maze.length) continue;
                    if(maze[ny][nx]=='O') // only O is walkable
                    {
                        q.offer(new int[] {nx,ny});
                        maze[ny][nx]= (char)count;
                    }
                    else if(maze[ny][nx]=='X')
                    { // found the target
                        System.out.println(&quot;Steps: &quot; + (count));
                        List&lt;int[]&gt; res = createSolution(maze, pos[0], pos[1]);  
                        return res;
                    }
                }

            }
            count++;
        }

        return null;        
    }

    public List&lt;int[]&gt; createSolution(char[][] maze, int lastX, int lastY)
    {
        List&lt;int[]&gt; res = new ArrayList&lt;&gt;();
        Stack&lt;int[]&gt; s = new Stack&lt;&gt;();
        System.out.println(&quot;Creating the solution.&quot;);
        s.push(new int[] {lastX,lastY} );
        int count = (int)(maze[lastY][lastX]);
        count--;
        
        for(int i=0;i&lt;maze.length;i++)
        {
            for(int j=0;j&lt;maze[0].length;j++)
            {
                System.out.print(((char)(maze[i][j]+'0')) + &quot;|&quot;);
            }
            System.out.println();
        }

        while(count &gt;= 0)
        {
            int[][] dir = new int[][] { {0,1},{1,0},{ 0,-1},{-1,0}};
            for(int i=0;i&lt;dir.length;i++)
            {
                int nx = lastX + dir[i][0];
                int ny = lastY + dir[i][1];
                if(nx &lt; 0 || nx &gt;= maze[0].length || ny &lt; 0 || ny &gt;= maze.length) continue;
                if((int)maze[ny][nx]==count) 
                {
                    s.push(new int[] {nx, ny});
                    lastX = nx; lastY = ny;
                    count--;
                    break;
                }
            }
        }

        while(!s.isEmpty()) { res.add(s.pop()); };
        
        return res;
    }

    public void performTest()
    {
        List&lt;int[]&gt; res = minimumRoute(new char[][] {
            {'O','O','O','O'},
            {'D','O','D','O'},
            {'O','O','O','O'},
            {'X','D','D','O'},
        });

        for(int[] pos: res)
        {
            System.out.print(&quot;(&quot; + pos[1] + &quot;,&quot; + pos[0] + &quot;) ,&quot;);
        }
        System.out.println();
    }
    
    public String toString() { return &quot;Treasure Island ([I]**) [https://leetcode.com/discuss/interview-question/347457]: &quot;;}

}
</code>
</pre>
</div>

<template id="my-label-button-code_5"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_6" name="code_6" class="center">
<a class=".title">Top K Frequently Mentioned Keywords</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_6">
<code class="language-java">

import java.util.ArrayList;
import java.util.List;
import java.util.HashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.Arrays;
import java.util.Collections;
import java.util.PriorityQueue;



public class TopKFrequentlyMentionedKeywords implements IInterviewQuestion
{   // related problems:
    // https://leetcode.com/problems/top-k-frequent-words/
    // https://leetcode.com/problems/top-k-frequent-elements/
    // solution from 35 - 79 = about 45 lines
    public List&lt;String&gt; nlogn_Sort(Map&lt;String,Integer&gt; m, int k)
    {   // sort in a descending order based on word frequency from large to small.
        List&lt;String&gt; res = new ArrayList(m.keySet());
        Collections.sort(res, (w1, w2) -&gt; (m.get(w1) == m.get(w2) ? w1.compareTo(w2) : m.get(w2)-m.get(w1)) );
        return res;
    }

    public List&lt;String&gt; nlogk_Sort(Map&lt;String,Integer&gt; m, int k)
    {   
        // create a min heap to sort from small to large. add to sort. remove to get rid of smallest item.
        PriorityQueue&lt;String&gt; q = new PriorityQueue&lt;&gt;( (w1, w2) -&gt; (m.get(w1) == m.get(w2) ? w2.compareTo(w1) : m.get(w1)-m.get(w2)));
        // if you use max heap, you won't be able to lock insert/delete into log(k) time complexity as we did below.
        for (Map.Entry&lt;String, Integer&gt; entry : m.entrySet()) {
            q.offer(entry.getKey());
            if (q.size() &gt; k) { q.poll(); }  // ensure each insertion only uses log(k)       
        }
    
        //get all elements from the heap
        List&lt;String&gt; res = new ArrayList&lt;&gt;();        
        while (q.size() &gt; 0) {
            String w = q.poll();
            res.add(w);
        }    
        Collections.reverse(res); //reverse the order        
        return res;
    }

    public List&lt;String&gt; TopKFrequent(String[] keywords, String[] reviews, int k, boolean nlogksort )
    {
        Set&lt;String&gt; keywordSet = new HashSet&lt;&gt;(Arrays.asList(keywords)); // remove duplicates from keywrods
        Map&lt;String, Integer&gt; m = new HashMap&lt;&gt;();

        for(String r: reviews)
        {   // split based on non-character. characters:[a-zA-Z0-9_]
            String[] strs = r.split(&quot;\\W&quot;);
            Set&lt;String&gt; inReview = new HashSet&lt;&gt;(Arrays.asList(strs));
            for(String w:inReview)
            {  
                w = w.toLowerCase();  // comparision is CASE-INSENSITIVE
                if(keywordSet.contains(w))
                {
                    m.put(w, m.getOrDefault(w,0)+1);
                }
            }
        }

       List&lt;String&gt; res = nlogksort ? nlogk_Sort(m,k) : nlogn_Sort(m, k);
       return res.subList(0,k); // [0,K)
    }

    public void performTest()
    {
        boolean[] nlogkFlag = new boolean[] { false, true};

        for(int i=0; i &lt; nlogkFlag.length;i++)
        {
            boolean nlogk = nlogkFlag[i];
            String label = nlogk ? &quot;nlogk&quot;: &quot;nlogn&quot;;

            Helper.equals(TopKFrequent(new String[] { &quot;anacell&quot;, &quot;cetracular&quot;, &quot;betacellular&quot; },
            new String[] { &quot;Anacell provides the best services in the city&quot;, 
                &quot;betacellular has awesome services&quot;,
                &quot;Best services provided by anacell, everyone should use anacell&quot; }, 2, nlogk) , 
                new String[] {&quot;anacell&quot;, &quot;betacellular&quot;} , 
                &quot;Top K Frequent (&quot;+label +&quot;)&quot;);

            Helper.equals(TopKFrequent(new String[] { &quot;anacell&quot;, &quot;betacellular&quot;, &quot;cetracular&quot;, &quot;deltacellular&quot;, &quot;eurocell&quot; },
            new String[] {  &quot;I love anacell Best services; Best services provided by anacell&quot;,
                &quot;betacellular has great services&quot;,
                &quot;deltacellular provides much better services than betacellular&quot;,
                &quot;cetracular is worse than anacell&quot;,
                &quot;Betacellular is better than deltacellular.&quot; }, 2, nlogk) ,
                new String[] {&quot;betacellular&quot;, &quot;anacell&quot;} , 
                &quot;Top K Frequent (&quot;+label +&quot;)&quot;);
        }

    }

    public String toString() { return &quot;Top K Frequently Mentioned Keywords ([E]***):&quot;;}
}

</code>
</pre>
</div>

<template id="my-label-button-code_6"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_7" name="code_7" class="center">
<a class=".title">Test Class</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_7">
<code class="language-java">
/* IMPORTANT: Multiple classes and nested static classes are supported */



//imports for BufferedReader
import java.io.BufferedReader;
import java.io.InputStreamReader;

//import for Scanner and other utility classes
import java.util.*;


// Warning: Printing unwanted or ill-formatted data to output will cause the test cases to fail

class TestClass {

    public class NQueen 
    {
        int[][] board;
        int N;
        HashSet&lt;int[]&gt; queenPos = new HashSet&lt;&gt;();

        public NQueen(int N)
        {
            this.N = N;
            board = new int[N][N];
        }

        private boolean isValidSpot(int x, int y)
        {
            for(int i=0;i&lt;board.length;i++)
                if(board[i][x]==1) return false;

            for(int j=0;j&lt;board[0].length;j++)
                if(board[y][j]==1) return false;

            int[][] d = new int[][] {
                new int[] {1,1},
                new int[] {1,-1},
                new int[] {-1,1},
                new int[] {-1,-1}
            };

            int[][] pos = new int[][] {
                new int[] {x,y},
                new int[] {x,y},
                new int[] {x,y},
                new int[] {x,y}
            };

            HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();

            while(set.size() &lt; 4)
            {
                for(int i=0;i&lt;4;i++)
                {
                    pos[i][0] += d[i][0];
                    pos[i][1] += d[i][1];
                    int px = pos[i][0];
                    int py = pos[i][1];
                    if(px &lt; 0 || px &gt;= board[0].length || py &lt;0 || py &gt;= board.length) 
                    {
                        set.add(i);
                         continue;
                    }
                    if(board[py][px]==1) return false;
                }
            }

            return true;
        }

        public boolean solveNQueen()
        {
            return solveNQueen(N, 0,0);
        }

        private boolean solveNQueen(int count, int x1, int y1)
        {            
            if(count==0) return true; // this is the solution.

            for(int y=y1;y&lt;board.length;y++)
            {
                for(int x=x1;x&lt;board[0].length;x++)
                {
                    if(isValidSpot(x, y))
                    {
                        board[y][x]=1; 
                        if(solveNQueen(count-1, x1 +1, y1+1)) return true;
                        board[y][x]=0;
                    }
                }
            }

            return false;
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder();
            for(int y=0;y&lt;board.length;y++)
            {
                for(int x=0;x&lt;board[0].length;x++)
                {
                    sb.append(board[y][x]+ &quot; &quot;);
                }                
                sb.append(&quot;\n&quot;);
            }

            return sb.toString();
        }

    }

    public static void main(String args[] ) throws Exception {
        //Scanner
        //Scanner s = new Scanner(System.in);
        int N = 4;//Integer.parseInt( s.nextLine() );                 // Reading input from STDIN

        TestClass test = new TestClass();

        test.Test(N);
        
    }

    public void Test(int N)
    {
        // Write your code here
        
        NQueen nq = new NQueen(N);

        if(!nq.solveNQueen())  System.out.println(&quot;NO&quot;);
        else
        {
             System.out.println(&quot;YES&quot;);
        }

             System.out.println(nq);

    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_7"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_8" name="code_8" class="center">
<a class=".title">Sub Tree With Maximum Average</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_8">
<code class="language-java">

class SubTreeWithMaximumAverage implements IInterviewQuestion
{
    class RefValue
    {
        public NaryTreeNode maxNode;
    }
    public NaryTreeNode getMaxAverageSubTree(NaryTreeNode root)
    {
        RefValue maxSubTree = new RefValue();
        float[] res = getSumAndAverage(root, maxSubTree);
        return maxSubTree.maxNode;
    }

    public float[] getSumAndAverage(NaryTreeNode root, RefValue maxSubTree)
    {
        if(root==null) return new float[]{0,0, 0};
 
        float sum = root.val;
        float maxAverage = 0;
        float childCount = 0;
        if(root.nodes.size() &gt; 0)
        {
            for(NaryTreeNode child: root.nodes)
            {
                float[] res = getSumAndAverage(child, maxSubTree);     
                sum+= res[0];    
                childCount+=res[2];                      
                if(maxAverage &lt; res[1])
                {                 
                    System.out.print(maxAverage +  &quot; &lt; &quot; + res[1]); 
                    maxAverage = res[1];
                    maxSubTree.maxNode = child;
                    System.out.println(&quot; [&quot; + maxSubTree.maxNode.val +&quot;]&quot;);
                }
            }

            float average = sum / (childCount+1);
            if(maxAverage &lt; average)
            {                 
                System.out.print(maxAverage +  &quot; &lt; &quot; + average); 
                maxAverage = average;
                maxSubTree.maxNode = root;
                System.out.println(&quot; [&quot; + maxSubTree.maxNode.val +&quot;]&quot;);
            }
        }

        return new float[]{sum, maxAverage, childCount + 1};
    }

    public void performTest()
    {
        NaryTreeNode root = new NaryTreeNode(20);
        NaryTreeNode left = new NaryTreeNode(12);
        NaryTreeNode right = new NaryTreeNode(18);
        left.addNodes(new int[]{11,2,3});
        right.addNodes(new int[]{15,8});
        root.addNode(left);
        root.addNode(right);

        NaryTreeNode maxSubTree = getMaxAverageSubTree(root);
        System.out.println(&quot;18 = &quot; + maxSubTree.val  );
    }

    public String toString() { 
        return &quot;SubTree With Maximum Average [https://leetcode.com/discuss/interview-question/349617]&quot;;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_8"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_9" name="code_9" class="center">
<a class=".title">Subtree Of Another Tree</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_9">
<code class="language-java">


class SubtreeOfAnotherTree implements IInterviewQuestion
{
    public boolean isSubtree(TreeNode s, TreeNode t) {        
        return traverse(s, t);
    }
    
    public boolean traverse(TreeNode s, TreeNode t)
    {
        return s!=null &amp;&amp; (
            sameStructure(s,t) ||
            traverse(s.left,t) ||
            traverse(s.right,t)
        );
    }
    
    public boolean sameStructure(TreeNode a, TreeNode b)
    {
        if(a==null &amp;&amp; b ==null) // touch bottom of the tree
            return true;
        
        if(a!=null &amp;&amp; b !=null &amp;&amp;
          a.val == b.val)
        {
            return sameStructure(a.left, b.left) &amp;&amp; sameStructure(a.right, b.right);
        }   
        
        return false;
    }

    public void performTest()
    {
        TreeNode s = TreeNode.createBinaryTreeFromArray(new Integer[]{3,4,5,1,2});
        TreeNode t = TreeNode.createBinaryTreeFromArray(new Integer[]{4,1,2});
        System.out.println(&quot;is Subtree? &quot; + traverse(s, t));
        TreeNode s0 = TreeNode.createBinaryTreeFromArray(new Integer[]{3,4,5,1,2,null,null,0});
        TreeNode t0= TreeNode.createBinaryTreeFromArray(new Integer[]{4,1,2});
        System.out.println(&quot;is Subtree? false = &quot; + traverse(s0, t0));
        TreeNode s1 = TreeNode.createBinaryTreeFromArray(new Integer[]{1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,2});
        TreeNode t1 = TreeNode.createBinaryTreeFromArray(new Integer[]{1,null,1,null,1,null,1,null,1,null,1,2});
        System.out.println(&quot;is Subtree? &quot; + traverse(s1, t1));
        TreeNode s2 = TreeNode.createBinaryTreeFromArray(new Integer[]{1,1});
        TreeNode t2 = TreeNode.createBinaryTreeFromArray(new Integer[]{1});
        System.out.println(&quot;is Subtree? &quot; + traverse(s, t));
    }
   
    public String toString() { 
        return &quot;Subtree of Another Tree ([I] *) [https://leetcode.com/problems/subtree-of-another-tree/]&quot;;
    }
}

</code>
</pre>
</div>

<template id="my-label-button-code_9"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_10" name="code_10" class="center">
<a class=".title">Substrings Of Size Kwith K Distinct Chars</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_10">
<code class="language-java">
import java.util.ArrayList;
import java.util.List;
import java.util.HashSet;
import java.util.Set;


class SubstringsOfSizeKwithKDistinctChars implements IInterviewQuestion
{
    public List&lt;String&gt; substringsOfSizeKwithKDistinctChars(String s, int k)
    {
        List&lt;String&gt; res = new ArrayList&lt;&gt;();
        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        int[] m = new int[256];

        for(int i=0, j = 0;i &lt; s.length() &amp;&amp; j &lt; s.length(); )
        {
            if(m[s.charAt(i)]==0)
            {
                m[s.charAt(i++)]++;

            }
            else 
            {
                m[s.charAt(j++)]--;
            }
            if(i-j==k) { 
                String sub = s.substring(j,i);
                // use both hashSet and list to remove duplicate and maintain the original order 
                if(!set.contains(sub)) { res.add(sub); }
                set.add(sub);
                m[s.charAt(j++)]--;
            }
            

        }
        return res;
    }

    public void performTest()
    {
        Helper.equals( substringsOfSizeKwithKDistinctChars(&quot;awaglknagawunagwkwagl&quot;,4), 
        new String[] {&quot;wagl&quot;, &quot;aglk&quot;, &quot;glkn&quot;, &quot;lkna&quot;, &quot;knag&quot;, &quot;gawu&quot;, &quot;awun&quot;, &quot;wuna&quot;, &quot;unag&quot;, &quot;nagw&quot;, &quot;agwk&quot;, &quot;kwag&quot;}, &quot;SubString&quot;);
    }
    
    public String toString() { return &quot;Substrings Of Size K with K Distinct Chars ([I]**) [https://leetcode.com/discuss/interview-question/370112]: &quot;;}
}

</code>
</pre>
</div>

<template id="my-label-button-code_10"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_11" name="code_11" class="center">
<a class=".title">Substrings Of Exactly K Distinct Chars</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_11">
<code class="language-java">




class SubstringsOfExactlyKDistinctChars implements IInterviewQuestion
{

    public int substringswithExactlyKDistinctChars(String s, int K)
    {
        Window&lt;Character&gt; w1 = new Window&lt;Character&gt;();
        Window&lt;Character&gt; w2 = new Window&lt;Character&gt;();
        int count = 0, left1=0, left2 = 0;
        for(int i=0;i&lt;s.length();i++)
        {
            Character c = s.charAt(i);
            w1.add(c);
            w2.add(c);
            while(w1.kinds() &gt; K) w1.remove(s.charAt(left1++));
            while(w2.kinds() &gt;= K) w2.remove(s.charAt(left2++));
            count += left2-left1;
        }
        return count;
    }

    public void performTest()
    {
        Helper.equals( substringswithExactlyKDistinctChars(&quot;pqpqs&quot;,2), 7, &quot;pqpqs has 7 number of substring stasified the ans. &quot;);
//        new String[] {&quot;pq&quot;, &quot;pqp&quot;, &quot;pqpq&quot;, &quot;qp&quot;, &quot;qpq&quot;, &quot;pq&quot;, &quot;qs&quot;}, &quot;SubString &quot;);
    }
    
    public String toString() { return &quot;Substrings with exactly K Distinct Chars ([I]**) [https://leetcode.com/discuss/interview-question/370157  https://leetcode.com/problems/subarrays-with-k-different-integers/]: &quot;;}
}
</code>
</pre>
</div>

<template id="my-label-button-code_11"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_12" name="code_12" class="center">
<a class=".title">Subarrays With K Different Integers</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_12">
<code class="language-java">
import java.util.*;
class SubarraysWithKDifferentIntegers implements IInterviewQuestion
{
    //Longest SubString With K Distinct Characters

    
    public int subarraysWithKDistinct(int[] A, int K) {        
        Window&lt;Integer&gt; w1 = new Window&lt;Integer&gt;();
        Window&lt;Integer&gt; w2 = new Window&lt;Integer&gt;();
        int left1=0, left2 =0;
        int count = 0;
        
        for(int i=0;i &lt; A.length;++i)
        {
            int x = A[i];
            w1.add(x);
            w2.add(x);
            
            while(w1.kinds() &gt; K )
                w1.remove(A[left1++]);
            
            while(w2.kinds() &gt;= K )
                w2.remove(A[left2++]);
            
            count+= left2-left1;            
        }
        
        return count;
    }

    public void performTest()
    {
        Helper.equals( subarraysWithKDistinct(new int[]{1,2,1,2,3}, 2) , 7, &quot;{1,2,1,2,3} = &quot;);
        Helper.equals( subarraysWithKDistinct(new int[]{1,2,1,3,4}, 3) , 3, &quot;{1,2,1,3,4} = &quot;);

    }

    public String toString() { 
        return &quot;Subarrays with K Different Integers (*) [https://leetcode.com/problems/subarrays-with-k-different-integers/]&quot;;
    }

 }

</code>
</pre>
</div>

<template id="my-label-button-code_12"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_13" name="code_13" class="center">
<a class=".title">Search Suggestion System</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_13">
<code class="language-java">

import java.util.ArrayList;
import java.util.List;
import java.util.Arrays;
import java.util.LinkedList;


public class SearchSuggestionSystem implements IInterviewQuestion {
    // System Design interview for auto suggestions: https://www.youtube.com/watch?v=xrYTjaK5QVM
    // https://leetcode.com/problems/search-suggestions-system
     class Trie {
     Trie[] sub = new Trie[26];
     List&lt;String&gt; suggestion = new LinkedList&lt;&gt;();
     }
 
     // autocomplete/typehead
     // suggest 3 items based on a searchWord currently typed.
     public List&lt;List&lt;String&gt;&gt; suggestedProducts(String[] products, String searchWord) {
         Arrays.sort(products);
         
         List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();
         Trie root = new Trie();
         for(String p: products) // pre-compute suggest list based on sorted order
         {
             Trie r = root;
             for(char c : p.toCharArray())
             {
                 if(r.sub[c-'a']==null) r.sub[c-'a'] = new Trie();
 
                 r = r.sub[c-'a'];
                 
                 if(r.suggestion.size() &lt; 3) r.suggestion.add(p);
             }
         }
         
         for(char c: searchWord.toCharArray())
         {
             if(root!=null) root = root.sub[c-'a'];
             res.add( (root==null) ? Arrays.asList() : root.suggestion);
         }
         
         return res;
     }
 
     public void performTest()
     {
         String[] products = new String[]{&quot;mobile&quot;,&quot;mouse&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mousepad&quot;};
         String searchWord = &quot;mouse&quot;;
         Helper.equals(suggestedProducts(products,searchWord), 
         new String[][] {
             {&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;},
             {&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;},
             {&quot;mouse&quot;,&quot;mousepad&quot;},
             {&quot;mouse&quot;,&quot;mousepad&quot;},
             {&quot;mouse&quot;,&quot;mousepad&quot;}
         }, &quot;AutoComplete/TypeAhead Suggestion: &quot;);
     }
 
     public String toString() { return &quot;Product Suggestions ([E]**):&quot;;}
 }
</code>
</pre>
</div>

<template id="my-label-button-code_13"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_14" name="code_14" class="center">
<a class=".title">Search Matrix</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_14">
<code class="language-java">

public class SearchMatrix implements IInterviewQuestion
{
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix==null || matrix.length==0 || matrix[0].length==0 ) return false;
        int col = matrix[0].length-1;
        int row = 0;
        
        while(row &lt; matrix.length &amp;&amp; col &gt;= 0)
        {
            if(matrix[row][col]==target) return true;
            if(matrix[row][col] &lt; target) row++;
            else col--;
        }
        
        return false;
    }

    public void performTest()
    {
        int[][] m = new int[][] {
            {1,   4,  7, 11, 15},
            {2,   5,  8, 12, 19},
            {3,   6,  9, 16, 22},
            {10, 13, 14, 17, 24},
            {18, 21, 23, 26, 30}
        };

        Helper.equals(searchMatrix(m, 16), true, &quot;Search 16 &quot;);
        Helper.equals(searchMatrix(m, 13), true, &quot;Search 13 &quot;);
        Helper.equals(searchMatrix(m, 100), false, &quot;Search 100 &quot;);
    }

    public String toString() { return &quot;Seach a 2D Matrix ([N]**) [https://leetcode.com/problems/search-a-2d-matrix-ii]: &quot;;}
}

</code>
</pre>
</div>

<template id="my-label-button-code_14"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_15" name="code_15" class="center">
<a class=".title">Rottin Oranges</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_15">
<code class="language-java">
import java.util.LinkedList;
import java.util.Queue;


public class RottinOranges  implements IInterviewQuestion {
    //https://leetcode.com/problems/rotting-oranges/
    // Zombie in Matrix: https://leetcode.com/discuss/interview-question/411357/
    // Minium hours to send file to all available servers
    public int orangesRotting(int[][] grid) {
        Queue&lt;Integer[]&gt; q = new LinkedList&lt;&gt;();
        int count =0;
        // push source noddes
        for(int i=0;i&lt;grid.length;i++)
            for(int j=0;j&lt;grid[0].length;j++)
            {
                if(grid[i][j]==2) q.offer(new Integer[] {i,j});
                if(grid[i][j]==1) count++;
            }
        
        if(count==0) return 0; // speicial case. no fresh orange at all from start.
        
        int[][] dir = new int[][]{{0,1},{1,0},{0,-1},{-1,0}};
        int time = -1;
        
        while(q.size() &gt; 0)
        {
            int size = q.size();            
            for(int i=0;i&lt;size;i++) // make sure to go through all nodes in current queue
            {
                Integer[] pos = q.poll(); // get position                        
                for(int j=0;j&lt;dir.length;j++) // get adjacents of adjcent node.
                {
                    int nx= pos[0] + dir[j][0];
                    int ny =pos[1] + dir[j][1];

                    if(nx &lt; 0 || ny &lt; 0 || nx &gt;= grid[0].length || ny &gt;= grid.length) continue;
                    
                    if(grid[ny][nx]==1) // push an adjecent neighor which is a fresh orange in this case
                    { // in scoope
                        count--;
                        grid[ny][nx] = 2; // rotten the tomato, mark as visited
                        q.offer(new Integer[]{ny,nx}); 
                    }
                }      
            }
            
            time++;
        }
        
        return (count==0) ? time:-1; //-1 also means it's not possible to rotten every orange.
    }

    public void performTest()
    {
        Helper.equals(orangesRotting(new int[][] { {2,1,1},{1,1,0},{0,1,1} }), 4, &quot;Min minutes to rotten all oranges: &quot;);
        Helper.equals(orangesRotting(new int[][] { {2,1,1},{0,1,0},{1,0,1} }), -1, &quot;Min minutes to rotten all oranges: &quot;);
        Helper.equals(orangesRotting(new int[][] { {2,2,2},{0,2,0},{2,0,2} }), 0, &quot;Min minutes to rotten all oranges: &quot;);
    }

    public String toString() { return &quot;Zombie in Matrix [Min hours to send file to all available servers] ([E]***):&quot;;}
}

</code>
</pre>
</div>

<template id="my-label-button-code_15"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_16" name="code_16" class="center">
<a class=".title">Reorder Data In Log File</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_16">
<code class="language-java">

import java.util.Arrays;


public class ReorderDataInLogFile implements IInterviewQuestion
{
    public String[] reorderLogFiles(String[] logs) {
        Arrays.sort(logs, (log1, log2) -&gt; {
            String[] split1 = log1.split(&quot; &quot;, 2);
            String[] split2 = log2.split(&quot; &quot;, 2);
            boolean isDigit1 = Character.isDigit(split1[1].charAt(0));
            boolean isDigit2 = Character.isDigit(split2[1].charAt(0));
            if (!isDigit1 &amp;&amp; !isDigit2) {
                int cmp = split1[1].compareTo(split2[1]);
                if (cmp != 0) return cmp;
                return split1[0].compareTo(split2[0]);
            }
            return isDigit1 ? (isDigit2 ? 0 : 1) : -1;
        });
        return logs;
    }

    public void performTest()
    {
        Helper.equals( reorderLogFiles(new String[] { &quot;dig1 8 1 5 1&quot;,&quot;let1 art can&quot;,&quot;dig2 3 6&quot;,&quot;let2 own kit dig&quot;,&quot;let3 art zero&quot;} ) ,
        new String[] {&quot;let1 art can&quot;,&quot;let3 art zero&quot;,&quot;let2 own kit dig&quot;,&quot;dig1 8 1 5 1&quot;,&quot;dig2 3 6&quot;}, &quot;Reoder Log &quot;);
    }

    public String toString() { return &quot; Reorder Data in Log Files([E]*) [https://leetcode.com/problems/reorder-data-in-log-files/]: &quot;;}
}

</code>
</pre>
</div>

<template id="my-label-button-code_16"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_17" name="code_17" class="center">
<a class=".title">Prison Cells After N Days</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_17">
<code class="language-java">
import java.util.HashSet;
import java.util.Arrays;
import java.util.Set;

class PrisonCellsAfterNDays implements IInterviewQuestion {

    public int[] prisonAfterNDays(int[] cells, int N) {
        if(cells==null || cells.length == 0 || N &lt;= 0) return cells;
            Set&lt;String&gt; set = new HashSet&lt;&gt;();
            
            while(0 &lt; N)
            {
                int[] next = nextDayCell(cells);
                String curKey = Arrays.toString(next);
                
                if(set.contains(curKey))
                {                
                    N%=set.size();
                    while(0 &lt; N--) cells  = nextDayCell(cells);
                    
                    return cells;
                }
                else
                {
                    set.add(curKey);
                }
                
                
                cells = next;   
                N-=1;
            }
            
            return cells;
        }
        
        public int[] nextDayCell(int[] cells)
        {
            int[] temp = new int[cells.length];
            
            for(int i=1;i&lt;cells.length-1;i++)
            {
                temp[i] = (cells[i-1]==cells[i+1]) ? 1:0;        
            }
            return temp;
        }

    public void performTest()
    {
        Helper.equals(prisonAfterNDays(new int[]{1,0,0,1,0,0,1,0}, 1000000000) ,
            new int[]{0,0,1,1,1,1,1,0} , &quot;prison After N Days:&quot;);

    }

    
    public String toString() { 
        return &quot;prison After N Days [https://leetcode.com/problems/prison-cells-after-n-days/]&quot;;
    }
}
</code>
</pre>
</div>

<template id="my-label-button-code_17"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_18" name="code_18" class="center">
<a class=".title">Partition Label</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_18">
<code class="language-java">

import java.util.ArrayList;
import java.util.List;

public class PartitionLabel implements IInterviewQuestion
{
    public List&lt;Integer&gt; partitionLabels(String S) {
        int[] last = new int[26];
        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
        
        for(int i=0;i&lt;S.length();i++)
            last[S.charAt(i)-'a'] = i;           
        
        int lastMax = 0, start = 0;
        for(int i=0;i&lt;S.length();i++)
        {
            lastMax = Math.max( last[S.charAt(i)-'a'], lastMax);           
            
            if(lastMax==i)
            {
                res.add(lastMax-start+1);                    
                start = i+1;
            }
        }
        
        return res;
    }

    public void performTest()
    {
        Helper.equals(partitionLabels(&quot;ababcbacadefegdehijhklij&quot;), new Integer[] {9,7,8}, &quot;Partition Label -&gt; ababcbacadefegdehijhklij &quot;);

    }

    public String toString() { return &quot;Partition Labels([E]*) [https://leetcode.com/problems/partition-labels/]: &quot;;}
}

</code>
</pre>
</div>

<template id="my-label-button-code_18"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_19" name="code_19" class="center">
<a class=".title">Optimal Utilization</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_19">
<code class="language-java">
import java.util.*;

class OptimalUtilization implements IInterviewQuestion
{ // quite correct result.

    public int binarySearch(int[][] sorted, int target, boolean lowerBound)
    {
        int l = 0;
        int r = sorted.length -1;
        int mid = 0;
        int lastKeyPos = -1;
        while(l &lt;= r)
        {
            mid = (l+r)/2;
            int x = sorted[mid][1];

            if(target &lt; x) r= mid-1;
            else if(target &gt; x) l= mid +1;
            else
            {
                lastKeyPos = mid;
                if(lowerBound) r= mid-1;
                else l = mid +1;                
            }
        }

        return (lastKeyPos==-1) ? -(l+1): lastKeyPos;
    }

    // get target sum or closet sum answer from two non-sorted array
    // if no target answer, we only pick the closet sum answer. 
    // for example, target = 20. if next sum answer is 19,18, we only pick all answers of 19.
    // better than Brute Force. 
    public List&lt;List&lt;Integer&gt;&gt; getOptimalUtilization(int[][] a, int[][] b, int target)
    {   
        Arrays.sort(a, (i,j) -&gt; i[1]-j[1]);
        Arrays.sort(b, (i,j) -&gt; i[1]-j[1]);

        int l = 0;
        int r = b.length-1;
        int minCloset = Integer.MAX_VALUE;
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();

        while(l &lt; a.length &amp;&amp; r &gt;= 0)
        {
            int sum = a[l][1] + b[r][1];
            int diff = sum - target ;

            if(sum &gt; target ) r--;
            else {
                
                if(diff&lt;= 0)
                {
                    diff = Math.abs(diff);
                    if(minCloset &gt; diff)
                    {
                        minCloset = diff;
                        res.clear(); 
                        res.add(Arrays.asList( a[l][0], b[r][0]));                  
                    }
                    else if(minCloset == diff)
                    {
                        res.add(Arrays.asList( a[l][0], b[r][0]));                  
                    }
                }

                
                l++;
            }

        }

        return res;
    }

    // binary search approach
    public List&lt;List&lt;Integer&gt;&gt; binarySearch_getOptimalUtilization(int[][] a, int[][] b, int target)
    {   
        Arrays.sort(a, (i,j) -&gt; i[1]-j[1] ); 
        Arrays.sort(b, (i,j) -&gt; i[1]-j[1] ); 
        List&lt;int[]&gt; candidates = new ArrayList&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        int k =  b.length-1;
        
        while(k  &gt;= 0) 
        {
            int complement = target - b[k][1];
            int index = binarySearch(a, complement, true); 
           // System.out.println(&quot;found at &quot; + index + &quot; for key = &quot; + complement );
           if(index &lt; 0) { 
            index = -index -1; // index of the least integer greater than key
            index = index -1; // index of the greatest integer less than key
           }

            while(index &gt;= 0 &amp;&amp; index &lt; a.length) 
            {
            int diff = target - (a[index][1]+ b[k][1]);
            candidates.add(new int[]{a[index][0], b[k][0], diff }  );
            index--;
            }
           
            k--;
        }

        Collections.sort(candidates, (i , j) -&gt;  i[2]-j[2]  );

        Integer[] lastDiff = { null};

        candidates.forEach( p -&gt; {            
            if(lastDiff[0]==null || lastDiff[0]==p[2])
            {
  //              System.out.println(&quot;(&quot; + Arrays.toString(p) + &quot;)&quot;);
                res.add(Arrays.asList(p[0],p[1]) );
                lastDiff[0] = p[2];
            }
        });

        return res;
    }
    

    // same as binarsearch. TreeMap can be used for two dimension array source
    public List&lt;List&lt;Integer&gt;&gt; TreeMap_getOptimalUtilization(int[][] a, int[][] b, int target)
    {   
        TreeMap&lt;Integer,Integer&gt; pos = new TreeMap&lt;&gt;();
        List&lt;int[]&gt; candidates = new ArrayList&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();

        for(int i=0; i &lt; a.length;i++)
        {
            pos.put(a[i][1],a[i][0]);
        }

        Arrays.sort(b, (i,j) -&gt; i[1]-j[1] ); 

        int k = b.length -1;
        while(k&gt;0)
        {
            int complement = target-b[k][1];
            Map&lt;Integer,Integer&gt; candidate = pos.headMap(complement, true);

            for(Map.Entry&lt;Integer,Integer&gt; e : candidate.entrySet())
            {
                int index = e.getValue();
                int value = e.getKey();
                int diff = target - (value+ b[k][1]);
                candidates.add(new int[]{ index , b[k][0], diff});
            }
            
            k--;
        }

        Collections.sort(candidates, (i , j) -&gt;  i[2]-j[2]  );

        Integer[] lastDiff = { null};

        candidates.forEach( p -&gt; {            
            if(lastDiff[0]==null || lastDiff[0]==p[2])
            {
//                System.out.println(&quot;(&quot; + Arrays.toString(p) + &quot;)&quot;);
                res.add(Arrays.asList(p[0],p[1]) );
                lastDiff[0] = p[2];
            }
        });

        return res;
    }

    public void performTest()
    {
        Helper.equalsTo(getOptimalUtilization(new int[][] { {1,2}, {2,4},{3,6}}, new int[][]{{1,2}}, 7 ), new Integer[][] {{2,1}});
        Helper.equalsTo(getOptimalUtilization(new int[][] { {1,3}, {2,5},{3,7},{4,10}}, new int[][]{{1,2},{2,3},{3,4},{4,5}}, 10 ), new Integer[][] {{2,4},{3,2}});
        Helper.equalsTo(getOptimalUtilization(new int[][] { {1,8}, {2,7},{3,14}}, new int[][]{{1,5},{2,10},{3,14}}, 20 ), new Integer[][] {{3,1}} );
        Helper.equalsTo(getOptimalUtilization(new int[][] { {1,8}, {2,15},{3,9}}, new int[][]{{1,8},{2,11},{3,12}}, 20 ), new Integer[][] {{1,3}, {3,2}});
        Helper.equalsTo(getOptimalUtilization(new int[][] { {1,0}, {2,0},{3,0}}, new int[][]{{1,0}}, 7 ), new Integer[][] {} );

        System.out.println(&quot;$$$$$$$$$$$ Binary search approach:&quot;); 
        Helper.equalsTo(binarySearch_getOptimalUtilization(new int[][] { {1,2}, {2,4},{3,6}}, new int[][]{{1,2}}, 7 ), new Integer[][] {{2,1}});
        Helper.equalsTo(binarySearch_getOptimalUtilization(new int[][] { {1,3}, {2,5},{3,7},{4,10}}, new int[][]{{1,2},{2,3},{3,4},{4,5}}, 10 ), new Integer[][] {{2,4},{3,2}});
        Helper.equalsTo(binarySearch_getOptimalUtilization(new int[][] { {1,8}, {2,7},{3,14}}, new int[][]{{1,5},{2,10},{3,14}}, 20 ), new Integer[][] {{3,1}} );
        Helper.equalsTo(binarySearch_getOptimalUtilization(new int[][] { {1,8}, {2,15},{3,9}}, new int[][]{{1,8},{2,11},{3,12}}, 20 ), new Integer[][] {{1,3}, {3,2}});
        Helper.equalsTo(binarySearch_getOptimalUtilization(new int[][] { {1,0}, {2,0},{3,0}}, new int[][]{{1,0}}, 7 ), new Integer[][] {} );
    }

    public String toString() { 
        return &quot;Optimal Utilization ([E]) [https://leetcode.com/discuss/interview-question/344677]&quot;;
    }
}
</code>
</pre>
</div>

<template id="my-label-button-code_19"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_20" name="code_20" class="center">
<a class=".title">Number Of Clusters</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_20">
<code class="language-java">


public class NumberOfClusters implements IInterviewQuestion {
    // questions: https://www.glassdoor.com/Interview/Problem-2d-grid-each-node-has-1-colors-find-number-of-clusters-of-a-given-color-red-blue-green-blue-gre-QTN_2930567.htm
    // https://leetcode.com/problems/number-of-islands/
    public int[] numberOfClusters(char[][] grid) {
        char[] colors = new char[] {'0','1','2'};
        int[] count = new int[] { 0,0,0};

        for(int i=0;i&lt;grid.length;i++)
        {
            for(int j=0;j&lt;grid[0].length;j++)
            {
                for(int k=0;k&lt;colors.length;k++)
                {
                    if(grid[i][j]==colors[k]) 
                    {
                        dfs(grid, i, j, colors[k]);
                        count[k]++;
                        break; // break; no need to check other colors.
                    }
                }
            }
        }

      //  System.out.println(&quot;counts: &quot; + Arrays.toString(count));
        return count;
    }
    
    public void dfs(char[][] grid, int y, int x, char target)
    {
        if(x &lt; 0 || x &gt;= grid[0].length || y &lt; 0 || y &gt;= grid.length ) return;        
        if(grid[y][x]!= target) return;
        
        grid[y][x]= 'v'; //marked as visited
        
        dfs(grid, y+1, x, target);
        dfs(grid, y-1, x, target);
        dfs(grid, y, x+1, target);
        dfs(grid, y, x-1, target);
    }

    public void performTest()
    {
        Helper.equals( numberOfClusters(new char[][] {
            {'1','1','0','1','0'},
            {'1','2','0','1','0'},
            {'1','2','2','2','2'},
            {'0','0','1','1','0'},
        }), new int[] {4,3,1} ,&quot;Number of Culsters :&quot;);
        
    }

    public String toString() { return &quot;Number Of Clusters ([E]**):&quot;;}
}

</code>
</pre>
</div>

<template id="my-label-button-code_20"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_21" name="code_21" class="center">
<a class=".title">Nth Geometric Progression</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_21">
<code class="language-java">
class NthGeometricProgression implements IInterviewQuestion  {

    public char[] getNthGP(double secondTerm, double thirdTerm, int nth)
    {
        double r = thirdTerm/ secondTerm;
        double a = secondTerm/r;
        double result = a*Math.pow(r, nth-1);
        String str = String.valueOf(result);
        int pos = str.indexOf('.');

        if(pos &gt; 0) // trim up to 
        {
           int decimalPlaces = 3;
           str = str.substring(0, Math.min(pos+decimalPlaces+1, str.length())); 
        }

    //    System.out.println(&quot;res =&gt; [&quot; + str + &quot;]&quot;);
        return str.toCharArray();
    }

    public void performTest()
    {
        Helper.equals(String.valueOf( getNthGP(1,2,4) ), &quot;4.0&quot;, &quot;seoncd Term:1, thrid Term: 2, Find 4th Term = ? &quot;);
    }

    public String toString() { 
        return &quot;Nth Geometric Progression ([I]*) [https://leetcode.com/discuss/interview-question/432213/]&quot;;
    }
}
</code>
</pre>
</div>

<template id="my-label-button-code_21"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_22" name="code_22" class="center">
<a class=".title">Most Common Word</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_22">
<code class="language-java">



import java.util.HashSet;
import java.util.HashMap;


class MostCommonWord implements IInterviewQuestion
{
    public String mostCommonWord(String paragraph, String[] banned) {
        String[] words = paragraph.split(&quot;\\W+&quot;); // split by all non-character. + means more than one non-character can be used. 
        HashSet&lt;String&gt; set = new HashSet&lt;&gt;();
        HashMap&lt;String,Integer&gt; m = new HashMap&lt;&gt;();
        String maxWord = null;
        int max = 0;
        for(String b : banned)
            set.add(b.toLowerCase());
        
        for(String w: words)
        {
            w = w.toLowerCase();
            if(!set.contains(w))
            {
                m.put(w, m.getOrDefault(w,0)+1);
                int count =m.get(w);
                if(count &gt; max)
                {
                    maxWord = w;
                    max = count;
                }
            }
        }
        
        return maxWord;
    }

    public void performTest()
    {
        Helper.equals(mostCommonWord(&quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;, new String[] {&quot;hit&quot;}), 
        &quot;ball&quot; , &quot;Most Command Word &quot;);
        Helper.equals(mostCommonWord(&quot;Bob. hIt, baLl&quot;, new String[] {&quot;bob&quot;, &quot;hit&quot;}), 
        &quot;ball&quot; , &quot;Most Command Word &quot;);
    }
    
    public String toString() { return &quot;Most Common Word ([I]**) [https://leetcode.com/problems/most-common-word/]: &quot;;}

}
</code>
</pre>
</div>

<template id="my-label-button-code_22"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_23" name="code_23" class="center">
<a class=".title">Minimum Cost To Connect Rope</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_23">
<code class="language-java">
import java.util.PriorityQueue;

class MinimumCostToConnectRope implements IInterviewQuestion
{
    public int minCostToConnectRope(int[] ropes)
    {
        int res = 0;
        PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();
        for(int len : ropes) { minHeap.add(len); }

        while(minHeap.size() &gt; 1)
        {
            int combinedLen = minHeap.poll() + minHeap.poll();
            res += combinedLen;
            minHeap.offer(combinedLen);
        }

        return res;
    }

    public void performTest()
    {
        Helper.equals(minCostToConnectRope(new int[]{2, 4, 3}) , 14, &quot;[2,4,3]: &quot;);
        Helper.equals(minCostToConnectRope(new int[]{8, 4, 6, 12}) , 58, &quot;[8,4,6,12]: &quot;);
        Helper.equals(minCostToConnectRope(new int[]{2, 2, 3, 3}) , 20, &quot;[2, 2, 3, 3]: &quot;);
        Helper.equals(minCostToConnectRope(new int[]{1, 2, 5, 10, 35, 89}) , 224, &quot;[1, 2, 5, 10, 35, 89]: &quot;);

    }

    public String toString() { 
        return &quot;Minimum Time to merge files/Minimum Cost to connect Ropes ([E]) [https://leetcode.com/discuss/interview-question/344677]&quot;;
    }
}
</code>
</pre>
</div>

<template id="my-label-button-code_23"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_24" name="code_24" class="center">
<a class=".title">Min Cost To Connect All Nodes Or Repair Edges</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_24">
<code class="language-java">
import java.util.*;

class UF {
    private int[] parent;
    private int[] rank;
    private int count;

    public UF(int N)
    {
        count = N;
        parent = new int[N];
        rank = new int[N];
        for(int i=0;i&lt;N;i++)
        {
            parent[i]=i;
            rank[i]=0;
        }
    }

    public int find(int x)
    {
        while(x!=parent[x])
        {
            parent[x] = parent[parent[x]]; // path compresion
            x = parent[x];
        }

        return x;
    }

    // union by rank
    public void union(int x, int y)
    {
        int rootX = find(x);
        int rootY = find(y);
        if(rootX==rootY) return;
        if(rank[rootX] &lt; rank[rootY])
        {
            parent[rootX] = rootY;
        }
        else
        {
            parent[rootY] = rootX;
            if(rank[rootX] == rank[rootY]) rank[rootX]++;            
        }
        count--;
    }

    public int count() { return count; }
    public boolean connected(int x, int y) { return find(x)==find(y); }
}

class MinCostToConnectAllNodesOrRepairEdges implements IInterviewQuestion {

    public static int minCost(int n, int[][] edges, int[][] newEdges) {
        UF uf = new UF(n + 1); // + 1 because nodes are 1-based
        
        Queue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;(newEdges.length, (e1, e2) -&gt; Integer.compare(e1[2], e2[2]));
        HashSet&lt;String&gt; added = new HashSet&lt;&gt;();
        
        for (int[] edge : newEdges) {
            pq.offer(edge);
            added.add(edge[0]+&quot;,&quot;+edge[1]);
        }
                
        for (int[] edge : edges) {
            if(!added.contains(edge[0]+&quot;,&quot;+edge[1])) // ensure the same broken edge is not added.
            {
                pq.offer(new int[]{edge[0],edge[1],0});
            }
        }
        
        int totalCost = 0;
        // 2 because nodes are 1-based and we have 1 unused component at index 0
        while (!pq.isEmpty() &amp;&amp; uf.count() != 2) {
            int[] edge = pq.poll();
            if (!uf.connected(edge[0], edge[1])) {
                uf.union(edge[0], edge[1]);
                totalCost += edge[2];
            }
        }
        return totalCost;
    }

    public void performTest()
    {
        // below tests are for new edges, new roads and etc. new edge must be edges never in MST before.
        int n = 6;
        int[][] edges = {{1, 4}, {4, 5}, {2, 3}};
        int[][] newEdges = {{1, 2, 5}, {1, 3, 10}, {1, 6, 2}, {5, 6, 5}};
        System.out.println(minCost(n, edges, newEdges));
        Helper.equals( minCost(n, edges, newEdges), 7 , &quot;new edges -&gt;&quot; );

        // below tests are for broken edges. broken edges must be edges already in MST
        n = 5;
        edges = new int[][] {{1, 2}, {2, 3}, {3, 4}, {4, 5}, {1, 5}};
        int[][] brokenEdges = new int[][] {{1, 2, 12}, {3, 4, 30}, {1, 5, 8}};
        Helper.equals( minCost(n, edges, brokenEdges), 20 , &quot;broekn edges -&gt;&quot; );

        n = 6;
        edges = new int[][] {{1, 2}, {2, 3}, {4, 5}, {3, 5}, {1, 6}, {2, 4}};
        brokenEdges = new int[][] {{1, 6, 410}, {2, 4, 800}};
        Helper.equals( minCost(n, edges, brokenEdges), 410 , &quot;broekn edges -&gt;&quot; );

        n = 6;
        edges = new int[][] { {1, 2}, {2, 3}, {4, 5}, {5, 6}, {1, 5}, {2, 4}, {3, 4} };
        brokenEdges = new int[][] { {1, 5, 110}, {2, 4, 84}, {3, 4, 79} };
        Helper.equals( minCost(n, edges, brokenEdges), 79 , &quot;broekn edges -&gt;&quot; );

/*
Example 2:

Input: n = 6, edges = [[1, 2], [2, 3], [4, 5], [3, 5], [1, 6], [2, 4]], edgesToRepair = [[1, 6, 410], [2, 4, 800]]
Output: 410
Example 3:

Input: n = 6, edges = [[1, 2], [2, 3], [4, 5], [5, 6], [1, 5], [2, 4], [3, 4]], edgesToRepair = [[1, 5, 110], [2, 4, 84], [3, 4, 79]]
Output: 79
*/
        
    }

    public String toString() { 
        return &quot;Min Cost to Connect All Nodes (a.k.a. Min Cost to Add New Roads) [https://leetcode.com/discuss/interview-question/356981]&quot;;
    }
}
</code>
</pre>
</div>

<template id="my-label-button-code_24"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_25" name="code_25" class="center">
<a class=".title">Merge Two Sorted List</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_25">
<code class="language-java">


class MergeTwoSortedList implements IInterviewQuestion
{
    public Node mergeTwoLists(Node l1, Node l2) {
        Node dummy = new Node(0);
        Node temp = dummy;
        
        while(l1 !=null &amp;&amp; l2 != null)
        {
            Node smaller = (l1.val &lt; l2.val) ? l1:l2;
            temp.next = smaller;             
            temp = temp.next;
            
            if(l1.val &lt; l2.val) l1=l1.next;
            else l2 = l2.next;
        }
        
        while(l1!=null)
        {
            temp.next = l1;
            temp = temp.next;
            l1 = l1.next;
        }
        
        while(l2!=null)
        {
            temp.next = l2;
            temp = temp.next;
            l2 = l2.next;
        }
        
        return dummy.next;
    }

    public void performTest()
    {        
         System.out.println(&quot;Same contents? &quot; + mergeTwoLists(new Node(new int[] {1,3,6,8}), new Node(new int[]{2,4,5,7}) )
         .equalList(new Node(new int[] {1,2,3,4,5,6,7,8} ) ) );

    }
    
    public String toString() { return &quot;Merge Two Sorted Lists ([N]**) [https://leetcode.com/problems/merge-two-sorted-lists/] &quot;;}

}
</code>
</pre>
</div>

<template id="my-label-button-code_25"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_26" name="code_26" class="center">
<a class=".title">Merge Intervals</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_26">
<code class="language-java">
import java.util.*;

class MergeIntervals implements IInterviewQuestion
{
    public int[][] merge(int[][] intervals) {
		if (intervals== null || intervals.length &lt;= 1) return intervals;

		// Sort by ascending starting point
		Arrays.sort(intervals, (i,j) -&gt; i[0]==j[0] ? i[1]-j[1]:i[0]-j[0]);

		LinkedList&lt;int[]&gt; llRes = new LinkedList&lt;&gt;();
		llRes.add(intervals[0]);
        
		for (int i=1;i &lt; intervals.length;i++) {
            int[] merged = llRes.getLast();                        
			if (intervals[i][0] &lt;= merged[1]) // Overlapping intervals
            {
                llRes.removeLast();
				merged[1] = Math.max(merged[1], intervals[i][1]);
                llRes.addLast(merged);
            }
			else { // disjoint intervals                          
				llRes.add(intervals[i]);
			}
		}

		return llRes.toArray(new int[llRes.size()][]);
    }

    public void performTest()
    {
        int[][] res = merge(new int[][] { {1,3},{2,6},{8,10},{15,18} });
        Helper.arrayEquals(res, new int[][] { {1,6}, {8,10}, {15,18} } );
    }

    public String toString() { 
        return &quot;Merge Intervals (*) [https://leetcode.com/problems/merge-intervals/]&quot;;
    }
}

</code>
</pre>
</div>

<template id="my-label-button-code_26"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_27" name="code_27" class="center">
<a class=".title">Longest String With Three Consecutive Characters</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_27">
<code class="language-java">

import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Iterator;

class LongestStringWithThreeConsecutiveCharacters  implements IInterviewQuestion {
    
    // only work for leetcode 1405. Longest Happy String. at most 3 characters. not a general solution
    public void LongestStringWithAtMostKChar(Map&lt;Character, int[]&gt; map, int K, StringBuilder result) {
        PriorityQueue&lt;Map.Entry&lt;Character, int[]&gt;&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; (b.getValue()[0] - a.getValue()[0]));
        for(Map.Entry&lt;Character, int[]&gt; e : map.entrySet()) {
            q.add(e);
        }
        boolean f = false;
        while(!q.isEmpty()) {
            Map.Entry&lt;Character, int[]&gt; current = q.poll();
            if(current.getValue()[0] &gt; 0 &amp;&amp; current.getValue()[1] &lt; K &amp;&amp; !f) {
                result.append(current.getKey());
                map.put(current.getKey(), new int[]{current.getValue()[0] - 1, current.getValue()[1] + 1});
                f = true;
            } else {
                map.put(current.getKey(), new int[]{current.getValue()[0], 0});   
            }
        }
        if(f) {
            LongestStringWithAtMostKChar(map, K, result);
        }
    }

    // INCORRECT. Find the right solution online.
    public String LongestStringWithKConsecutiveCharacters(HashMap&lt;Character, Integer&gt; m, int k)
    {
        System.out.print(&quot;K = &quot; + k + &quot; | &quot;);
        int maxRepeat = k;
        PriorityQueue&lt;Character&gt; pq = new PriorityQueue&lt;&gt;( (c1, c2) -&gt; ( m.get(c1)==m.get(c2) ? c1-c2 :m.get(c2)-m.get(c1) ) );
        
        Iterator&lt;Map.Entry&lt;Character,Integer&gt;&gt; ite = m.entrySet().iterator();

        while(ite.hasNext())
        {
            Map.Entry&lt;Character,Integer&gt; e = ite.next();
            if(e.getValue()&lt;=0) ite.remove();
        }
        
        for(Character c : m.keySet()) { pq.add(c); }

        StringBuilder s = new StringBuilder();
        Character lastChar = null;

        while(pq.size() &gt; 0)
        {            
            Character c = pq.poll(); // get max value

            if(lastChar == c)
            {
               if(pq.isEmpty()) return s.toString();// + &quot;.... (unable to finish) : NOT POSSIBLE &quot;;
                Character next = pq.poll();
                pq.add(c); // add back;
                c = next;
            }
            

            int count = m.get(c);
        //    System.out.print(&quot; pq:&quot; + pq + &quot; , c=&quot;+ c + &quot; | &quot;);

            if(count &gt; 0)
            {
                for(int i=0;  i &lt; Math.min(maxRepeat,count) ; i++)
                {
                    s.append(c);
                    m.put(c,m.get(c)-1);
                }

                if(m.get(c)&gt;0) pq.add(c); // add back 
            }
            lastChar = c;
        }

        return s.toString();
    }

    public void performTest()
    {
        HashMap&lt;Character, Integer&gt; m  =new HashMap&lt;&gt;(); 
/*
        m.put('a',1);
        m.put('b',2);
        m.put('c',3);
        m.put('d',6);
        m.put('e',7);
        m.put('f',7);
        m.put('g',9);
        m.put('i',9);

        System.out.println(m + &quot; =&gt; &quot;+  LongestStringWithKConsecutiveCharacters(m,3));

        m.clear();*/
        m.put('a',1);
        m.put('b',1);
        m.put('c',7);
        System.out.println(m + &quot; =&gt; &quot;+  LongestStringWithKConsecutiveCharacters(m,3));
        
        m.clear();
        m.put('a',2);
        m.put('b',2);
        m.put('c',1);
        System.out.println(m + &quot; =&gt; &quot;+  LongestStringWithKConsecutiveCharacters(m,2));

        m.clear();
        m.put('a',7);
        m.put('b',1);
        m.put('c',0);
        System.out.println(m + &quot; =&gt; &quot;+  LongestStringWithKConsecutiveCharacters(m,2));

        StringBuilder s = new StringBuilder();
        HashMap&lt;Character, int[]&gt; m2  =new HashMap&lt;&gt;(); 
        m2.put('a', new int[]{1, 0});
        m2.put('b', new int[]{1, 0});
        m2.put('c', new int[]{7, 0});

        LongestStringWithAtMostKChar(m2, 3, s);
        System.out.println(m2 + &quot; =&gt; &quot; + s);

        m2.clear();
        m2.put('a', new int[]{2, 0});
        m2.put('b', new int[]{2, 0});
        m2.put('c', new int[]{1, 0});
        
        LongestStringWithAtMostKChar(m2, 2, s);
        System.out.println(m2 + &quot; =&gt; &quot; + s);

        m2.clear();
        m2.put('a', new int[]{7, 0});
        m2.put('b', new int[]{1, 0});
        m2.put('c', new int[]{0, 0});        
        LongestStringWithAtMostKChar(m2, 2, s);
        System.out.println(m2 + &quot; =&gt; &quot; + s);
    }

    
    public String toString() { 
        return &quot;Longest String With 3 or K Consecutive Characters ([N]**) [https://leetcode.com/problems/reorganize-string/  https://leetcode.com/problems/longest-happy-string/ ] &quot;;
    }

}
</code>
</pre>
</div>

<template id="my-label-button-code_27"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_28" name="code_28" class="center">
<a class=".title">Longest Plaindromic Substring</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_28">
<code class="language-java">
class LongestPlaindromicSubstring implements IInterviewQuestion {

    public String longestPalindrome(String s) {
        if(s==null || s.length() &lt; 2) return s;
        
        int left = 0, right = 0;
        int len = s.length();
        boolean[][] isPalindrome = new boolean[len][len];        
        // P(i,j) answers the question 'is the substring from index i to index j  is a paindrome?'.
        
        // j starts from 1. must compare at least two chars. one char from j, another char from i.
        
        for(int j=1; j &lt; s.length();j++) 
            for(int i=0; i &lt; j ; i++)
            {
                //j-i &lt;=2 means current length doesnt have an inner string to check.
                boolean isInnerPalindrome = isPalindrome[i+1][j-1] || j-i &lt;=2;
                
                if(isInnerPalindrome &amp;&amp; s.charAt(i)==s.charAt(j) )
                {
                     isPalindrome[i][j] = true;
                    if(j-i &gt; right-left) // update current max length
                    {
                        right = j;
                        left = i;
                    }
                }
            }
        return s.substring(left,right+1);
    }

    public String longestPalindrome_ExpandFromCenter(String s) {
        String max = &quot;&quot;;
        
        for(int i=0;i&lt; s.length();i++)
        {
            String s1 = expandFromCenter(s, i, i);
            String s2 = expandFromCenter(s, i, i+1);
            String curMax = (s1.length() &gt; s2.length()) ? s1:s2;
            max = (curMax.length() &gt; max.length()) ? curMax:max;            
        }
        
        return max;
    }
    
    public String expandFromCenter(String s, int l, int r)
    {
        while(l&gt;=0 &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r))
        { 
            l--; r++; 
        }
        
        int len = ((r-1)-(l+1));        
        return s.substring(l+1, r);
    }

    public void performTest()
    {
        Helper.equals(longestPalindrome(&quot;babad&quot;),  &quot;bab&quot;, &quot; longest plaindrome ?&quot; );
        Helper.equals(longestPalindrome(&quot;cbbd&quot;),  &quot;bab&quot;, &quot; longest plaindrome ?&quot; );

        Helper.equals(longestPalindrome_ExpandFromCenter(&quot;babad&quot;),  &quot;bab&quot;, &quot;(EXPAND from Center) longest plaindrome ?&quot; );
        Helper.equals(longestPalindrome_ExpandFromCenter(&quot;cbbd&quot;),  &quot;bab&quot;, &quot;(EXPAND from Center)  longest plaindrome ?&quot; );
    }

    public String toString() { 
        return &quot;Longest Palindromic Substring ([I]**) [https://leetcode.com/problems/longest-palindromic-substring/]&quot;;
    }
}
</code>
</pre>
</div>

<template id="my-label-button-code_28"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_29" name="code_29" class="center">
<a class=".title">K Closet Pointsto Origin</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_29">
<code class="language-java">
import java.util.Arrays;
import java.util.PriorityQueue;

class KClosetPointstoOrigin implements IInterviewQuestion  {

    public int[][] KClosetPoints_Sort(int[][] points, int K) {
        Arrays.sort(points, (p1, p2) -&gt; (p1[0]*p1[0] +p1[1]*p1[1]) - (p2[0]*p2[0] +p2[1]*p2[1]) );
        // int[][] temp = new int[K];
        // for(int i=0;i&lt;K;i++) temp[i]=points[i];
        // return temp;
        return Arrays.copyOfRange(points, 0, K);
    }

    public int[][] KClosetPoints_PQ(int[][] points, int K) {
        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;int[]&gt;(  
            (p1, p2) -&gt; (p2[0]*p2[0] +p2[1]*p2[1]) - (p1[0]*p1[0] +p1[1]*p1[1])  );
        // Max heap means get max value when polling.
        // polled values from the max heap are in an descending order

        // this trick maintains a size K of Max PriorityQueue (Max Heap) to stay N*log(k) time complexity.
        for(int[] p:points) 
        {
            pq.offer(p);
            if(pq.size() &gt; K)  pq.poll();
        }
        // all first N-K items are polled. only last K items remained.
        int[][] res = new int[K][2];
        while(K &gt; 0) res[--K] = pq.poll();
        return res;
    }

    public int[][] KClosetPoints_QSelect(int[][] points, int K) {
        int len =  points.length, l = 0, r = len - 1;
        while (l &lt;= r) {
            int mid = helper(points, l, r);
            if (mid == K) break;
            if (mid &lt; K) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return Arrays.copyOfRange(points, 0, K);
    }
    
    private int helper(int[][] arr, int l, int r) {
        int[] pivot = arr[l];

        while (l &lt; r) {
            while (l &lt; r &amp;&amp; compare(arr[r], pivot) &gt;= 0) r--;
            arr[l] = arr[r];
            while (l &lt; r &amp;&amp; compare(arr[l], pivot) &lt;= 0) l++;
            arr[r] = arr[l];
        }

        arr[l] = pivot;
        return l;
    }
    
    private int compare(int[] p1, int[] p2) {
        return p1[0] * p1[0] + p1[1] * p1[1] - p2[0] * p2[0] - p2[1] * p2[1];
    }


    public void performTest()
    {
        System.out.println(&quot;KClosetPoints_Sort: &quot; + Helper.arrayEquals(KClosetPoints_Sort(new int[][] { {-5,4}, {-6,-5}, {4,6} }, 2) , new int[][] { {-5, 4}, {4,6} } ) ) ;
        System.out.println(&quot;KClosetPoints_PQ: &quot; + Helper.arrayEquals(KClosetPoints_PQ(new int[][] { {-5,4}, {-6,-5}, {4,6} }, 2) , new int[][] { {-5, 4}, {4,6} } ) );
        System.out.println(&quot;KClosetPoints_QSelect: &quot; + Helper.arrayEquals(KClosetPoints_QSelect(new int[][] { {-5,4}, {-6,-5}, {4,6} }, 2) , new int[][] { {-5, 4}, {4,6} } ) );

    }

    
    public String toString() { 
        return &quot;K Closest Points to Origin ([I] *)[https://leetcode.com/problems/k-closest-points-to-origin/discuss/220235/Java-Three-solutions-to-this-classical-K-th-problem.]&quot;;
    }
}

</code>
</pre>
</div>

<template id="my-label-button-code_29"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_30" name="code_30" class="center">
<a class=".title">Java Collections</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_30">
<code class="language-java">
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.Collection;
import java.util.Collections;
import java.util.PriorityQueue;
import java.util.Queue;

import java.util.Iterator;


public class JavaCollections implements IInterviewQuestion, IImportTechnique  {
    public void performTest()
    {
        System.out.println(&quot;Priorty Queue:&quot;);
        PriorityQueue&lt;Integer&gt; pq=new PriorityQueue&lt;&gt;(); // min heap/priority queue by deafult
        int[] points = new int[] { 1,10,3,6,5,8,7,4,9,2}; int K = 3;

        for(int pValue: points) { pq.offer(pValue); }

        // print heap array content (in an array order)
        for(Integer p: pq) { System.out.print(p+ &quot; &quot;); } System.out.println();        

        // how to iterate through PriorityQueue without affectint pq heap content
        Iterator itr = pq.iterator(); 
        while (itr.hasNext()) { System.out.print(itr.next()+ &quot; &quot;);  } System.out.println();
       
        while(pq.size() &gt; 0) { System.out.print(pq.poll()+ &quot; &quot;); } System.out.println();

        Queue&lt;Integer&gt; pq2=new PriorityQueue&lt;&gt;(Collections.reverseOrder()); // max heap/priority queue

        for(int pValue: points) { pq2.offer(pValue); }
        while(pq2.size() &gt; 0) { System.out.print(pq2.poll()+ &quot; &quot;); } System.out.println();
   
        // a trick to stay N*log(k) time complexity for Max Priority Queue to get top k minimum in descending order (max-heap max first out)
        // without this trick, it's N*log(N) time complexity.
        // Min Priority Queue = N*log(N) since you need to put all numbers into the pq first.
        // Min Priority Queue with the trick won't work since you will get top k max in an ascending order. (min-heap min first out)
        for(int pValue: points) 
        {
            pq2.offer(pValue);
            if(pq2.size() &gt; K)  pq2.poll();
        }

        // print the result        
        while(!pq2.isEmpty()) { System.out.print(pq2.poll() + &quot; &quot;); } System.out.println();
    
        // add() vs offer(), remove() vs poll(), element() vs peek().
        // add() from Collection can't return false and throw an exception if an element cannot be added.
        // offer() from Queue returns false if an element cannot be added.
        // when the queue is empty, element() and remove() from Collection throws NoSuchElementException, while poll() &amp; peek() return null.
        /*
           add Throws:
            IllegalStateException - if the element cannot be added at this time due to capacity restrictions
            ClassCastException - if the class of the specified element prevents it from being added to this queue.
                for example, adding another type of object into a non-generic ArrayList.
            NullPointerException - if the specified element is null and this queue does not permit null elements
            IllegalArgumentException - if some property of this element prevents it from being added to this queue
        */

        System.out.println(&quot;HashMap:&quot;);

        HashMap&lt;Integer, String&gt; m = new HashMap&lt;&gt;();
        m.put(11, &quot;AB&quot;);
        m.put(2, &quot;CD&quot;);
        m.put(33, &quot;EF&quot;);
        m.put(9, &quot;GH&quot;);
        m.put(3, &quot;IJ&quot;);    

        for(Map.Entry e: m.entrySet() ) { System.out.print(&quot;{&quot; + e.getKey() + &quot;=&gt;&quot; + e.getValue() + &quot;},&quot;); }  System.out.println();

        HashMap&lt;Integer,String&gt; m2 = (HashMap)m.clone();
        
        for(Map.Entry&lt;Integer,String&gt; e: m2.entrySet() ) { System.out.print(&quot;{&quot; + e.getKey() + &quot;=&gt;&quot; + e.getValue() + &quot;},&quot;); } System.out.println();   
        m2.clear();
        m2.putAll(m);        Iterator mItr = m2.entrySet().iterator();
        while(mItr.hasNext()) { Map.Entry e = (Map.Entry)mItr.next(); System.out.print(&quot;{&quot; + e.getKey() + &quot;=&gt;&quot; + e.getValue() + &quot;},&quot;); } System.out.println();

        /*  HashSet &amp; HashMap doesn't maintain any kind of order of its elements.
            LinkedHashSet &amp; LinkedHashMap maintains insertion order.
            TreeSet &amp; TreeMap sort the entries in ascending order of keys and they don't allow null key and throw NullPointerException.
            Set -&gt; contains
            Map -&gt; containsKey, containsValue
        */        

        Set&lt;Integer&gt; set = m2.keySet();
        Iterator&lt;Integer&gt; ite2 = set.iterator();
        while(ite2.hasNext()) { System.out.print(ite2.next() + &quot;,&quot;); } System.out.println();

        Collection&lt;String&gt; values = m2.values();
        for(String s: values) { System.out.print(s + &quot;,&quot;); } System.out.println();
        Iterator&lt;String&gt; ite3 = values.iterator();
        while(ite3.hasNext()) { System.out.print(ite3.next() + &quot;,&quot;); } System.out.println();

        System.out.println(&quot;hello&quot;);

    }
    
    public String toString() { 
        return &quot;Mastering JavaCollectionsn [https://beginnersbook.com/2013/12/how-to-loop-hashmap-in-java/]&quot;;
    }
}

/*

- Use Comparator when you need more flexibilit
** The compareTo() method will return a positive number if one object is greater than the other, negative if it&rsquo;s lower, and zero if they are the same.

import java.util.Comparator;

public class MyComparator implements Comparator&lt;String&gt;
{
   @Override // ascending order based on String length
   public int compare(String x, String y) { return x.length() - y.length();}
}

or you can replace everything before Comparator using new keyword as below.

Collections.sort(strArr, new Comparator&lt;String&gt;
{
   @Override // ascending order based on String length
   public int compare(String x, String y) { return x.length() - y.length();}
});

Using Comparator with lambda expressions as below:
Collections.sort(strArr, (x, y) -&gt; x.length() - y.length()  );

You always use compareTo for a String/object.
Collections.sort(strArr, (s1, s2) -&gt; s1.compareTo(s2));

even shorter with
Collections.sort(strArr, Comparator.naturalOrder() );

    // ascending order means to arrange values from smallest to largest.
    // descending order means to arrange values from largest to smallest.

    // ascending order based on value
    public int compare(Integer x, Integer y) { return x - y;}
    // descending order based on value
    public int compare(Integer x, Integer y) { return y - x;}

    // sort by id in ascending order. when ids are the same, sort by their name in alphabetic order.
    public int compare(User x, User y) { return x.id == y.id ? x.name.compareTo(y)  : x.id-y.id  ;}
    (x,y) -&gt; x.id==y.id ? x.name.compareTo(y) : x.id-y.id;

    // sort by map value in ascending order. When map value are the same, sort by the name in alphabetic order.
    public int compare(String s1, String s2) { return count.get(s1) == count.get(s2) ? s1.compareTo(s2)  : count.get(s1)-count.get(s2); }
    (s1,s2) -&gt; count.get(s1)==count.get(s2) ? s1.compareTo(s2) : count.get(s1)-count.get(s2);

    Sorting a Map with TreeMap
    Map&lt;String, Integer&gt; m  = new TreeMap&lt;&gt;();
    m.put(&quot;DEF&quot;, 10);
    m.put(&quot;ABC&quot;, 20);
    System.out.println(m);

    Sorting a Set with TreeSet
    Set&lt;String&gt; s  = new TreeSet&lt;&gt;();
    s.put(&quot;DEF&quot;);
    s.put(&quot;ABC&quot;);
    System.out.println(m);
*/
</code>
</pre>
</div>

<template id="my-label-button-code_30"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_31" name="code_31" class="center">
<a class=".title">Generate Parentheses</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_31">
<code class="language-java">
import java.util.List;
import java.util.ArrayList;

class GenerateParentheses implements IInterviewQuestion {
    
    public List&lt;String&gt; generateParentheses(int n) {
        List&lt;String&gt; res = new ArrayList&lt;&gt;();
        dfs(&quot;&quot;, n, n, res);   
        return res;
    }
    
    public void dfs(String s, int left, int right, List&lt;String&gt; res)
    {
        if(left &gt; right) return;
        if(left &lt;0 || right &lt; 0) return;
        if(left==0 &amp;&amp; right==0) res.add(s);
        
        dfs(s+&quot;(&quot;, left-1, right, res);
        dfs(s+&quot;)&quot;, left, right-1, res);
    }

    public void performTest()
    {
        Helper.equals( generateParentheses(3), new String[] {&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;} , &quot;Valid parentheses generation? &quot;);
    }

   
    public String toString() { 
        return &quot;Generate Parentheses ([I] *) [https://leetcode.com/problems/generate-parentheses/]&quot;;
    }
}
</code>
</pre>
</div>

<template id="my-label-button-code_31"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_32" name="code_32" class="center">
<a class=".title">Find Unique Pairs With Given Sum</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_32">
<code class="language-java">

import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;
import java.util.Map;
import java.util.Arrays;


public class FindUniquePairsWithGivenSum implements IInterviewQuestion
{
    public List&lt;List&lt;Integer&gt;&gt; findUniquePairsWithGivenSum(int[] nums, int target)
    {
        Map&lt;Integer, List&lt;Integer&gt;&gt; pos = new HashMap&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        for(int i=0;i&lt;nums.length;i++) 
        { 
            List&lt;Integer&gt; ls = pos.get(target-nums[i]);

            if(ls!= null &amp;&amp; ls.size() &gt; 0)
            {  // to DO. get rid of duplication.
                    int x = nums[i];
                    int y = nums[ls.get(0)];
                    int left = x &gt; y ? x:y;
                    int right = x &gt; y ? y:x;
                    res.add(Arrays.asList(left, right));
                    ls.remove(0);
            }
            else
            {
                pos.put(nums[i], pos.getOrDefault(nums[i], new ArrayList&lt;Integer&gt;()) );
                pos.get(nums[i]).add(i);
            }
        }

        return res;
    }

    public void performTest()
    {
      Helper.equals(findUniquePairsWithGivenSum(new int[] {1, 1, 2, 45, 46, 46 } , 47),
      new Integer[][] { {45, 2}, {46, 1}, {46 ,1}}, &quot;Find Unique Pairs &quot;);

      Helper.equals(findUniquePairsWithGivenSum(new int[] {1, 5, 1, 5} , 6 ),
      new Integer[][] { {5, 1}, {5, 1}}, &quot;Find Unique Pairs &quot;);

      Helper.equals(findUniquePairsWithGivenSum(new int[] {1, 5, 9, 1, 5, 3, 2, 7} , 6 ),
      new Integer[][] { {5, 1}, {5, 1}}, &quot;Find Unique Pairs &quot;);
    }

    public String toString() { return &quot;Find Unqiue Pair With Given Sum ([E,I]**) [https://leetcode.com/discuss/interview-question/372434]: &quot;;}
}

</code>
</pre>
</div>

<template id="my-label-button-code_32"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_33" name="code_33" class="center">
<a class=".title">Find Pair With Given Sum</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_33">
<code class="language-java">

import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;
import java.util.Map;
import java.util.Arrays;


public class FindPairWithGivenSum implements IInterviewQuestion
{
    public List&lt;List&lt;Integer&gt;&gt; findPairWithGivenSum(int[] nums, int target)
    {
        Map&lt;Integer, List&lt;Integer&gt;&gt; pos = new HashMap&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        int max = Integer.MIN_VALUE;

    
        for(int i=0;i&lt;nums.length;i++) 
        { 
            List&lt;Integer&gt; ls = pos.get(target-nums[i]);

            if(ls!= null &amp;&amp; ls.size() &gt; 0)
            {
                    int idx1 = ls.get(0); // this one shall be smaller index.                    
                    int idx2 = i; // current one is always largest index since this index has not put into hash map yet.
                    int curMax = Math.max(nums[idx1],nums[idx2]);

                    ls.remove(0);
                    
                    if(curMax &gt; max)
                    {
                        max = curMax;
                        res.clear();
                        res.add(Arrays.asList(idx1,idx2));
                    }

            }
            else
            {
                pos.put(nums[i], pos.getOrDefault(nums[i], new ArrayList&lt;Integer&gt;()) );
                pos.get(nums[i]).add(i);
            }
        }

        return res;
    }

    public void performTest()
    {
      Helper.equals(findPairWithGivenSum(new int[] {1, 10, 25, 35, 60 } , 90 - 30 ),
      new Integer[][] { {2, 3}}, &quot;Find Pair &quot;);
       
      Helper.equals(findPairWithGivenSum(new int[] {21,1,2,45,46,46} , 46 ),     
      new Integer[][] { {1, 3}}, &quot;Find  Pairs &quot;);

      Helper.equals(findPairWithGivenSum(new int[] {20, 50, 40, 25, 30, 10} , 90-30 ),     
      new Integer[][] { {1, 5}}, &quot;Find  Pairs &quot;);
      
    }

    public String toString() { return &quot;Find Pair With Given Sum ([E,I]**) [https://leetcode.com/discuss/interview-question/356960]: &quot;;}
}

</code>
</pre>
</div>

<template id="my-label-button-code_33"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_34" name="code_34" class="center">
<a class=".title">Find N Unique Integers Sum Up To Zero</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_34">
<code class="language-java">
import java.util.*;

class FindNUniqueIntegersSumUpToZero implements IInterviewQuestion {

    public int[] sumZero(int n) {
        
        int half = n/2;
        int[] arr = new int[n];
        for(int i=0;i&lt; half;i++)
        {
            arr[i]=-(n-i);
            arr[n-i-1]= (n-i);
        }
                    
        return arr;
    }

    public void performTest()
    {
        for(int i=0;i&lt;5;i++)
        {
            int n = (int)(Math.random()*20+1);
            int[] res = sumZero(n);
            
            int sum = Arrays.stream(res).reduce(0, (a,b) -&gt; a + b);
            System.out.println(&quot;n:&quot; + n  + &quot;, &quot; + Arrays.toString(res) + &quot;, sum = 0 ? =&gt; &quot; + (sum==0));            

        }

    }

    public String toString() { 
        return &quot;Subarrays with K Different Integers (*) [https://leetcode.com/problems/subarrays-with-k-different-integers/]&quot;;
    }
}
</code>
</pre>
</div>

<template id="my-label-button-code_34"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_35" name="code_35" class="center">
<a class=".title">Favorite Genres</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_35">
<code class="language-java">

import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;
import java.util.Map;
import java.util.Arrays;

class FavoriteGenres implements IInterviewQuestion
{
    public Map&lt;String, List&lt;String&gt;&gt; favoriteGenres(Map&lt;String, List&lt;String&gt;&gt; userSongs, Map&lt;String, List&lt;String&gt;&gt; songGenres)
    {
        Map&lt;String, Integer&gt; genreCount = new HashMap&lt;&gt;();
        Map&lt;String, String&gt; song2Genre = new HashMap&lt;&gt;();
        Map&lt;String, List&lt;String&gt;&gt; m = new HashMap&lt;&gt;();

        for(Map.Entry&lt;String, List&lt;String&gt;&gt; e : songGenres.entrySet())
        {
            for(String song: e.getValue())
            {
                song2Genre.put(song, e.getKey());
            }
        }
         
        System.out.println(song2Genre);

        for(Map.Entry&lt;String, List&lt;String&gt;&gt; e : userSongs.entrySet())
        {
            List&lt;String&gt; songs = e.getValue();
            String singer = e.getKey();
            genreCount.clear();

            int max = Integer.MIN_VALUE;
            for(String song: songs)
            {
                String genre = song2Genre.get(song);
                genreCount.put(genre, genreCount.getOrDefault(genre,0) +1 );
                max = Math.max( max, genreCount.get(genre));
            }

            for(Map.Entry&lt;String,Integer&gt; gc: genreCount.entrySet())
            {
                if(max==gc.getValue()) 
                {
                    m.put(singer, m.getOrDefault(singer, new ArrayList&lt;String&gt;()));
                    m.get(singer).add(gc.getKey());
                }
            }

            genreCount.clear();
        }

        return m;
    }

    public void performTest()
    {
        Map&lt;String, List&lt;String&gt;&gt; userSongs = new HashMap&lt;&gt;();
        Map&lt;String, List&lt;String&gt;&gt; songGenres = new HashMap&lt;&gt;();

        userSongs.put(&quot;David&quot;, Arrays.asList(&quot;song1&quot;, &quot;song2&quot;, &quot;song3&quot;, &quot;song4&quot;, &quot;song8&quot;));
        userSongs.put(&quot;Emma&quot;, Arrays.asList(&quot;song5&quot;, &quot;song6&quot;, &quot;song7&quot;));
        songGenres.put(&quot;Rock&quot;, Arrays.asList(&quot;song1&quot;, &quot;song3&quot;));
        songGenres.put(&quot;Dubstep&quot;, Arrays.asList(&quot;song7&quot;));
        songGenres.put(&quot;Techno&quot;, Arrays.asList(&quot;song2&quot;, &quot;song4&quot;));
        songGenres.put(&quot;Pop&quot;, Arrays.asList(&quot;song5&quot;, &quot;song6&quot;));
        songGenres.put(&quot;Jazz&quot;, Arrays.asList(&quot;song8&quot;, &quot;song9&quot;));

        Map&lt;String, List&lt;String&gt;&gt; m = favoriteGenres(userSongs, songGenres);
        System.out.println(m);
    }

    public String toString() { return &quot;Favorite Genres ([N]**) [    https://leetcode.com/discuss/interview-question/373006]: &quot;;}

}

</code>
</pre>
</div>

<template id="my-label-button-code_35"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_36" name="code_36" class="center">
<a class=".title">Critical Routers Or Connections</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_36">
<code class="language-java">

import java.util.ArrayList;
import java.util.List;
import java.util.HashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;



public class CriticalRoutersOrConnections implements IInterviewQuestion 
{
    class Graph&lt;T&gt;
    {
        private Map&lt;T, List&lt;T&gt;&gt; adjList = new HashMap&lt;&gt;();
        private int time = 0;

        public void addEdges(T[][] edges)
        {
            for(int i=0;i&lt;edges.length;i++)
            {
                addEdge(edges[i][0], edges[i][1]);
            }
        }

        public void clear()
        {
            adjList.clear();
        }

        public void addEdge(T u, T v)
        {
            addEdge(u, v, true);
        }

        public void addEdge(T u, T v, boolean biDir)
        {
            adjList.put(u, adjList.getOrDefault(u, new ArrayList&lt;T&gt;()));
            adjList.get(u).add(v);
            if(biDir)
            {
                adjList.put(v, adjList.getOrDefault(v, new ArrayList&lt;T&gt;()));
                adjList.get(v).add(u);
            }
        }        

        public void findCutPoints(T node, Map&lt;T, Boolean&gt; visited, Map&lt;T, T&gt; parent,  Map&lt;T, Integer&gt; disc, Map&lt;T, Integer&gt; low, Set&lt;T&gt; ap, Map&lt;T, List&lt;T&gt;&gt; bridges)
        {
            int children = 0;
            visited.put(node, true);
            time++;
            disc.put(node, time);
            low.put(node, time);
                        
            for(T adjNode: adjList.get(node))
            {
                if(visited.get(adjNode)==false)
                {
                    children++;
                    parent.put(adjNode,node);
                    findCutPoints(adjNode, visited, parent, disc, low, ap, bridges);
                    low.put(node, Math.min(low.get(node), low.get(adjNode) ) );
                    
                    // this piece of code is to determine cut points
                    if(ap!=null)
                    {
                        if(parent.get(node)==null &amp;&amp; children &gt; 1) ap.add(node);
                        if(parent.get(node) != null &amp;&amp; low.get(adjNode) &gt;= disc.get(node)) // &gt; for bridges, &gt;= for points
                            ap.add(node);
                    }

                    // this piece of code is to determine. &gt; for bridges, &gt;= for points
                    if(bridges != null)
                    {
                        if(low.get(adjNode) &gt; disc.get(node)) {
                            bridges.put(node, bridges.getOrDefault(node, new ArrayList&lt;T&gt;()) );
                            bridges.get(node).add(adjNode);
                        }
                    }

                }
                else if(visited.get(adjNode)== true &amp;&amp; adjNode != parent.get(node) )
                {
                    low.put(node, Math.min(low.get(node), disc.get(adjNode) ) );
                }

            }
        }

        public Set&lt;T&gt; findCutPoints()
        {
            Map&lt;T, Boolean&gt; visited = new HashMap&lt;&gt;();
            Map&lt;T, T&gt; parent= new HashMap&lt;&gt;();
            Map&lt;T, Integer&gt; low= new HashMap&lt;&gt;();
            Map&lt;T, Integer&gt; disc= new HashMap&lt;&gt;();
            Set&lt;T&gt; ap = new HashSet&lt;T&gt;();
            time = 0;
            for(T node: adjList.keySet())
            {
                visited.put(node, false);
                parent.put(node, null); // root by deafult
                low.put(node, 0);
                disc.put(node, 0);
            }
    
            for(T node: adjList.keySet())
            {
                if(visited.get(node)==false)
                findCutPoints(node, visited, parent, disc, low, ap, null);
            }

            return ap;
        }

        public Map&lt;T, List&lt;T&gt;&gt; findBridges()
        {
            Map&lt;T, Boolean&gt; visited = new HashMap&lt;&gt;();
            Map&lt;T, T&gt; parent= new HashMap&lt;&gt;();
            Map&lt;T, Integer&gt; low= new HashMap&lt;&gt;();
            Map&lt;T, Integer&gt; disc= new HashMap&lt;&gt;();
            Map&lt;T, List&lt;T&gt;&gt; bridges = new HashMap&lt;&gt;();

            time = 0;

            for(T node: adjList.keySet())
            {
                visited.put(node, false);
                parent.put(node, null); // root by deafult
                low.put(node, 0);
                disc.put(node, 0);
            }
    
            for(T node: adjList.keySet())
            {
                if(visited.get(node)==false)
                findCutPoints(node, visited, parent, disc, low, null, bridges);
            }

            return bridges;
        }
    }

    public void performTest()
    {
        Graph&lt;Integer&gt;  g = new Graph&lt;&gt;();

        // https://leetcode.com/discuss/interview-question/436073/
        g.addEdges(new Integer[][] { {0, 1}, {0, 2}, {1, 3}, {2, 3}, {2, 5}, {5, 6}, {3, 4} });
        System.out.println(&quot;Cut Points :&quot; +  g.findCutPoints() );

        // https://leetcode.com/problems/critical-connections-in-a-network/
        g.clear();
        g.addEdges(new Integer[][] { {1, 2}, {1, 3}, {3, 4}, {1, 4}, {4, 5}} );
        System.out.println(&quot;Bridges (Cut Edges) :&quot; + g.findBridges() );
        g.clear();
        g.addEdges(new Integer[][] { {1, 2}, {1, 3}, {2, 3}, {2, 4}, {2, 5}, {4, 6}, {5, 6} } );
        System.out.println(&quot;Bridges (Cut Edges) :&quot; + g.findBridges() );
        g.clear();
        g.addEdges(new Integer[][] { {1, 2}, {1, 3}, {2, 3}, {3, 4}, {3, 6}, {4, 5}, {6, 7}, {6, 9}, {7, 8}, {8, 9} } );
        System.out.println(&quot;Bridges (Cut Edges) :&quot; + g.findBridges() );
    }

    public String toString() { return &quot;Critical Routers &amp; Connections, Articulation Points/Cut Point, Bridges/Cut Edges ([E]**):&quot;;}

}

</code>
</pre>
</div>

<template id="my-label-button-code_36"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_37" name="code_37" class="center">
<a class=".title">Copy Random Linked List</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_37">
<code class="language-java">
import java.util.HashMap;

public class CopyRandomLinkedList  implements IInterviewQuestion {
    public Node copyRandomListWithDummyNode(Node head)   {
        if(head==null) return null;        
        HashMap&lt;Node, Node&gt; m = new HashMap&lt;Node, Node&gt;();
        Node dummy = new Node(0);
        
        for(Node cur = head, temp = dummy; cur!=null; cur=cur.next, temp=temp.next)
        {
            temp.next = new Node(cur.val);
            m.put(cur, temp.next);
        }
                
        for(Node cur = head, temp = dummy.next; cur!=null; cur=cur.next, temp=temp.next)
        {
            if(cur.random!=null) temp.random = m.get(cur.random);
        }
        
        return dummy.next;
    }

    public Node copyRandomListWithoutDummyNode(Node head)   {
        if(head==null) return null;        
        HashMap&lt;Node, Node&gt; m = new HashMap&lt;Node, Node&gt;();

        for(Node cur = head; cur!=null; cur=cur.next)
        {
            m.put(cur, new Node(cur.val));
        }
            
        for(Node cur = head; cur!=null; cur=cur.next)
        {
            m.get(cur).next = m.get(cur.next);
            m.get(cur).random = m.get(cur.random);
        }

        return m.get(head);
    }


    public void performTest()
    {
        Node root = new Node(new int[] {0,1,2,3,4,5,6,7,8,9}, new int[] {0 ,1,3,5,7,9,0,6, 8,0});
        Node copy = new Node(new int[] {0,1,2,3,4,5,6,7,8,9}, new int[] {0 ,1,3,5,7,9,0,6, 8,0});
        System.out.println(&quot;Same contents? &quot; + copyRandomListWithDummyNode(root ).equalList(copy) );
        System.out.println(&quot;Same contents? &quot; + copyRandomListWithoutDummyNode(root ).equalList(copy) );

    }
    
    public String toString() { return &quot;Copy Random Linked List ([N]**) [https://leetcode.com/problems/reorganize-string/] &quot;;}
}
</code>
</pre>
</div>

<template id="my-label-button-code_37"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_38" name="code_38" class="center">
<a class=".title">Binary Search</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_38">
<code class="language-java">
public class BinarySearch implements IInterviewQuestion, IImportTechnique 
{

    public int binarySearch(int[] arr, int key, boolean lowerBound)
    {
        int left = 0;
        int right = arr.length - 1;
        int lastKeyPos = -1;

        while(left &lt;= right)
        {
            int mid = (left+right) / 2;
            int cur  = arr[mid];

            if(key &gt; cur) left = mid+1;
            else if(key &lt; cur) right = mid-1;
            else // key == cur
            {
                lastKeyPos = mid;

                if(lowerBound) right = mid-1;
                else left = mid+1;
            }
        
        }

        return (lastKeyPos==-1) ? -(left+1) : lastKeyPos;
    }

    public void performTest()
    {
        int[] nums = new int[] { 1,2,2,2,2,3,3,3,4,4,6,6,6,7,8,9,10};
        

        System.out.print(&quot;Array: &quot;);
        for(int i=0;i &lt; nums.length; i++) System.out.print(String.format(&quot;[%2s]&quot;, nums[i]));
        System.out.println();

        System.out.print(&quot;Pos:   &quot;);
        for(int i=0;i &lt; nums.length; i++) System.out.print(String.format(&quot;{%2s}&quot;, i));
        System.out.println();

        System.out.println(&quot;\nLowerBound BinarySearch&quot;);
        for(int i=0;i &lt; 12; i++)
        {
            int insertPosition =  binarySearch(nums, i, true);
            System.out.println(&quot;key = &quot; + i + &quot; =&gt; &quot; + insertPosition);
        }

        System.out.println(&quot;\nUpperBound BinarySearch&quot;);
        for(int i=0;i &lt; 12; i++)
        {
            int insertPosition =  binarySearch(nums, i, false);
            System.out.println(&quot;key = &quot; + i + &quot; =&gt; &quot; + insertPosition);
        }

        System.out.println(&quot;Positive insert position = the actual found key position.&quot;);
        System.out.println(&quot;Negative insert postion (-insertPos -1) = the position of the least integer greater than key &quot;);
    }

    public String toString() { 
        return &quot;Binary Search []&quot;;
    }
}

</code>
</pre>
</div>

<template id="my-label-button-code_38"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>


  
	</body>
</html>
