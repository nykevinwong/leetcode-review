<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Atomic Habit</title>
    <link rel="stylesheet" type="text/css" href="prism.css" />
    <style>
      .center {
          margin: auto;
          width: 820px;
          border: 1px solid black;
          padding: 0 0 0 0;
          font-size: 11px;
          line-height: 14px;
        }

      .noscrollbar {
        overflow: hidden;
      }

      .token.number {
        color: lightblue;
      }

      
    </style>
		<script src="prism.js" type="text/javascript"></script>
		<script src="main.js" type="text/javascript"></script>

<script>


  </script>
	</head>
	<body>
	
  <!-- table of contents -->
	<ul>
    <li id="li_1" name="li_1" data-id=""><input type="checkbox" id="checkbox_1" name="checkbox_1" /><a href="#code_1">Union Find</a></li>
<li id="li_2" name="li_2" data-id=""><input type="checkbox" id="checkbox_2" name="checkbox_2" /><a href="#code_2">Treasure Island 2</a></li>
<li id="li_3" name="li_3" data-id=""><input type="checkbox" id="checkbox_3" name="checkbox_3" /><a href="#code_3">Treasure Island</a></li>
<li id="li_4" name="li_4" data-id=""><input type="checkbox" id="checkbox_4" name="checkbox_4" /><a href="#code_4">Top K Frequently Mentioned Keywords</a></li>
<li id="li_5" name="li_5" data-id=""><input type="checkbox" id="checkbox_5" name="checkbox_5" /><a href="#code_5">Sub Tree With Maximum Average</a></li>
<li id="li_6" name="li_6" data-id=""><input type="checkbox" id="checkbox_6" name="checkbox_6" /><a href="#code_6">Subtree Of Another Tree</a></li>
<li id="li_7" name="li_7" data-id=""><input type="checkbox" id="checkbox_7" name="checkbox_7" /><a href="#code_7">Substrings Of Size Kwith K Distinct Chars</a></li>
<li id="li_8" name="li_8" data-id=""><input type="checkbox" id="checkbox_8" name="checkbox_8" /><a href="#code_8">Substrings Of Exactly K Distinct Chars</a></li>
<li id="li_9" name="li_9" data-id=""><input type="checkbox" id="checkbox_9" name="checkbox_9" /><a href="#code_9">Subarrays With K Different Integers</a></li>
<li id="li_10" name="li_10" data-id=""><input type="checkbox" id="checkbox_10" name="checkbox_10" /><a href="#code_10">Search Suggestion System</a></li>
<li id="li_11" name="li_11" data-id=""><input type="checkbox" id="checkbox_11" name="checkbox_11" /><a href="#code_11">Search Matrix</a></li>
<li id="li_12" name="li_12" data-id=""><input type="checkbox" id="checkbox_12" name="checkbox_12" /><a href="#code_12">Rottin Oranges</a></li>
<li id="li_13" name="li_13" data-id=""><input type="checkbox" id="checkbox_13" name="checkbox_13" /><a href="#code_13">Reorder Data In Log File</a></li>
<li id="li_14" name="li_14" data-id=""><input type="checkbox" id="checkbox_14" name="checkbox_14" /><a href="#code_14">Prison Cells After N Days</a></li>
<li id="li_15" name="li_15" data-id=""><input type="checkbox" id="checkbox_15" name="checkbox_15" /><a href="#code_15">Partition Label</a></li>
<li id="li_16" name="li_16" data-id=""><input type="checkbox" id="checkbox_16" name="checkbox_16" /><a href="#code_16">Optimal Utilization</a></li>
<li id="li_17" name="li_17" data-id=""><input type="checkbox" id="checkbox_17" name="checkbox_17" /><a href="#code_17">Number Of Clusters</a></li>
<li id="li_18" name="li_18" data-id=""><input type="checkbox" id="checkbox_18" name="checkbox_18" /><a href="#code_18">Nth Geometric Progression</a></li>
<li id="li_19" name="li_19" data-id=""><input type="checkbox" id="checkbox_19" name="checkbox_19" /><a href="#code_19">Most Common Word</a></li>
<li id="li_20" name="li_20" data-id=""><input type="checkbox" id="checkbox_20" name="checkbox_20" /><a href="#code_20">Minimum Cost To Connect Rope</a></li>
<li id="li_21" name="li_21" data-id=""><input type="checkbox" id="checkbox_21" name="checkbox_21" /><a href="#code_21">Min Cost To Connect All Nodes Or Repair Edges</a></li>
<li id="li_22" name="li_22" data-id=""><input type="checkbox" id="checkbox_22" name="checkbox_22" /><a href="#code_22">Merge Two Sorted List</a></li>
<li id="li_23" name="li_23" data-id=""><input type="checkbox" id="checkbox_23" name="checkbox_23" /><a href="#code_23">Merge Intervals</a></li>
<li id="li_24" name="li_24" data-id=""><input type="checkbox" id="checkbox_24" name="checkbox_24" /><a href="#code_24">Longest String With Three Consecutive Characters</a></li>
<li id="li_25" name="li_25" data-id=""><input type="checkbox" id="checkbox_25" name="checkbox_25" /><a href="#code_25">Longest Plaindromic Substring</a></li>
<li id="li_26" name="li_26" data-id=""><input type="checkbox" id="checkbox_26" name="checkbox_26" /><a href="#code_26">K Closet Pointsto Origin</a></li>
<li id="li_27" name="li_27" data-id=""><input type="checkbox" id="checkbox_27" name="checkbox_27" /><a href="#code_27">Java Collections</a></li>
<li id="li_28" name="li_28" data-id=""><input type="checkbox" id="checkbox_28" name="checkbox_28" /><a href="#code_28">Generate Parentheses</a></li>
<li id="li_29" name="li_29" data-id=""><input type="checkbox" id="checkbox_29" name="checkbox_29" /><a href="#code_29">Find Unique Pairs With Given Sum</a></li>
<li id="li_30" name="li_30" data-id=""><input type="checkbox" id="checkbox_30" name="checkbox_30" /><a href="#code_30">Find Pair With Given Sum</a></li>
<li id="li_31" name="li_31" data-id=""><input type="checkbox" id="checkbox_31" name="checkbox_31" /><a href="#code_31">Find N Unique Integers Sum Up To Zero</a></li>
<li id="li_32" name="li_32" data-id=""><input type="checkbox" id="checkbox_32" name="checkbox_32" /><a href="#code_32">Favorite Genres</a></li>
<li id="li_33" name="li_33" data-id=""><input type="checkbox" id="checkbox_33" name="checkbox_33" /><a href="#code_33">Critical Routers Or Connections</a></li>
<li id="li_34" name="li_34" data-id=""><input type="checkbox" id="checkbox_34" name="checkbox_34" /><a href="#code_34">Copy Random Linked List</a></li>
<li id="li_35" name="li_35" data-id=""><input type="checkbox" id="checkbox_35" name="checkbox_35" /><a href="#code_35">Category Counter</a></li>
<li id="li_36" name="li_36" data-id=""><input type="checkbox" id="checkbox_36" name="checkbox_36" /><a href="#code_36">Binary Search</a></li>

  </ul>
  
  
<div id="code_1" name="code_1" class="center">
<a class=".title">Union Find</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_1">
<code class="language-java">
// https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/unionfind-suan-fa-ying-yong

class UnionFind {
    // 记录连通分量个数
    private int count;
    // 存储若干棵树
    private int[] parent;
    // 记录树的&ldquo;重量&rdquo;
    private int[] size;

    public UF(int n) {
        this.count = n;
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i &lt; n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    /* 将 p 和 q 连通 */
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;

        // 小树接到大树下面，较平衡
        if (size[rootP] &gt; size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
    }

    /* 判断 p 和 q 是否互相连通 */
    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        // 处于同一棵树上的节点，相互连通
        return rootP == rootQ;
    }

    /* 返回节点 x 的根节点 */
    private int find(int x) {
        while (parent[x] != x) {
            // 进行路径压缩
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    public int count() {
        return count;
    }
}

public class Test
{
public boolean equationsPossible(String[] equations) {
    // 26 个英文字母
    UF uf = new UF(26);
    // 先让相等的字母形成连通分量
    for (String eq : equations) {
        if (eq.charAt(1) == '=') {
            char x = eq.charAt(0);
            char y = eq.charAt(3);
            uf.union(x - 'a', y - 'a');
        }
    }
    // 检查不等关系是否打破相等关系的连通性
    for (String eq : equations) {
        if (eq.charAt(1) == '!') {
            char x = eq.charAt(0);
            char y = eq.charAt(3);
            // 如果相等关系成立，就是逻辑冲突
            if (uf.connected(x - 'a', y - 'a'))
                return false;
        }
    }
    return true;
}

public  void solve(char[][] board) {
    if (board.length == 0) return;

    int m = board.length;
    int n = board[0].length;
    // 给 dummy 留一个额外位置
    UF uf = new UF(m * n + 1);
    int dummy = m * n;
    // 将首列和末列的 O 与 dummy 连通
    for (int i = 0; i &lt; m; i++) {
        if (board[i][0] == 'O')
            uf.union(i * n, dummy);
        if (board[i][n - 1] == 'O')
            uf.union(i * n + n - 1, dummy);
    }
    // 将首行和末行的 O 与 dummy 连通
    for (int j = 0; j &lt; n; j++) {
        if (board[0][j] == 'O')
            uf.union(j, dummy);
        if (board[m - 1][j] == 'O')
            uf.union(n * (m - 1) + j, dummy);
    }
    // 方向数组 d 是上下左右搜索的常用手法
    int[][] d = new int[][]{{1,0}, {0,1}, {0,-1}, {-1,0}};
    for (int i = 1; i &lt; m - 1; i++) 
        for (int j = 1; j &lt; n - 1; j++) 
            if (board[i][j] == 'O')
                // 将此 O 与上下左右的 O 连通
                for (int k = 0; k &lt; 4; k++) {
                    int x = i + d[k][0];
                    int y = j + d[k][1];
                    if (board[x][y] == 'O')
                        uf.union(x * n + y, i * n + j);
                }
    // 所有不和 dummy 连通的 O，都要被替换
    for (int i = 1; i &lt; m - 1; i++) 
        for (int j = 1; j &lt; n - 1; j++) 
            if (!uf.connected(dummy, i * n + j))
                board[i][j] = 'X';
}
    
public static void main(String[] args)
{
    
}
    
}

</code>
</pre>
</div>

<template id="my-label-button-code_1"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_2" name="code_2" class="center">
<a class=".title">Treasure Island 2</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_2">
<code class="language-java">
import java.util.LinkedList;
class TreasureIsland2 
{   //求從某起點至其中一個終點的最短步數
    public int minimumRoute(char[][] maze)
    {
        Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;();
        int[][] dir = new int[][] { {0,1}, {0,-1}, {1,0}, {-1,0} }; //四鄰接方向的位置

        // 將起始節點存入廣優搜佇例
        for(int i=0;i&lt; maze.length;i++)
        {
            for(int j=0; j &lt; maze[0].length;j++)
            {
                if(maze[i][j]=='S')//如果是起始點，可以有多個. 
                {
                    q.add(new int[] {j, i});
                }
            }
        }
        
        int count = 0;
        while(q.size() &gt; 0)
        {
            int size = q.size(); //針對當前佇例的所有節點先處理，記錄要處理的當前節點量

            for(int i=0;i&lt;size;i++) //針對當前佇例的所有節點先處理
            {
                int[] pos = q.poll();//取出節點
                for(int k=0;k&lt;dir.length;k++) // 針對節點的四或八方向的鄰接節點處理
                {
                    int nx = pos[0] + dir[k][0];
                    int ny = pos[1] + dir[k][1];
                    // 不在網格內的座標，是不存在任何鄰接節點的，要跳過。
                    if(nx &lt;0 || nx &gt;= maze[0].length || ny &lt;0 || ny &gt;= maze.length) continue;

                    if(maze[ny][nx]=='O') // 如果是未訪問過的節點
                    {
                        maze[ny][nx] = 'D'; // 設成訪問過
                        q.add(new int[] {nx, ny });// 將該節點放入佇例，好下次處理該節點的鄰節接點.
                    }
                    else if(maze[ny][nx]=='X') //如果是終點標記
                    {
                        return count; //傳回從起點到另一終點的最少步數
                    }
                }
            }

            count++; //每批次處理當前節點後，等於廣優搜執行一次，也等於步數.
        }

        return count;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_2"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_3" name="code_3" class="center">
<a class=".title">Treasure Island</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_3">
<code class="language-java">
import java.util.ArrayList;
class TreasureIsland 
{   //求並印出一起點至一終點的最短路徑
    public List&lt;int[]&gt; minimumRoute(char[][] maze)
    {
        Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;();
        int count = 0;
        int[][] dir = new int[][] { {0,1},{1,0},{ 0,-1},{-1,0}}; //四鄰接方向的位置
        q.offer(new int[]{0,0}); // 將起始節點存入廣優搜佇例
        maze[0][0]= (char)count++; // 用步數值標記成訪問過

        while(q.size() &gt; 0)
        {
            int size = q.size(); //針對當前佇例的所有節點先處理，記錄要處理的當前節點量
            for(int i=0;i&lt;size;i++) //針對當前佇例的所有節點先處理
            {
                int[] pos = q.poll(); //取出節點
             
                for(int j=0;j&lt;dir.length;j++) // 針對節點的四或八方向的鄰接節點處理
                {
                    int nx = pos[0] + dir[j][0];
                    int ny = pos[1] + dir[j][1];
                    // 不在網格內的座標，是不存在任何鄰接節點的，要跳過。
                    if(nx &lt; 0 || nx &gt;= maze[0].length || ny &lt; 0 || ny &gt;= maze.length) continue;

                    if(maze[ny][nx]=='O') // 如果是未訪問過的節點
                    {
                        maze[ny][nx]= (char)count; // 用步數值標記成訪問過
                        q.offer(new int[] {nx,ny}); // 將該節點放入佇例，好下次處理該節點的鄰節接點.
                    }
                    else if(maze[ny][nx]=='X') //如果是終點節點
                    { // found the target
                        System.out.println(&quot;Steps: &quot; + (count)); //輸出需要的步數
                        // 用該陣列製作起點到終點的座標路徑圖
                        List&lt;int[]&gt; res = createSolution(maze, pos[0], pos[1]);  
                        return res;
                    }
                }

            }
            count++;
        }

        return null;        
    }

    public List&lt;int[]&gt; createSolution(char[][] maze, int lastX, int lastY)
    {
        List&lt;int[]&gt; res = new ArrayList&lt;&gt;();
        Stack&lt;int[]&gt; s = new Stack&lt;&gt;();
        System.out.println(&quot;Creating the solution.&quot;);
        s.push(new int[] {lastX,lastY} );
        int count = (int)(maze[lastY][lastX]);
        count--;
        
        for(int i=0;i&lt;maze.length;i++)
        {
            for(int j=0;j&lt;maze[0].length;j++)
            {
                System.out.print(((char)(maze[i][j]+'0')) + &quot;|&quot;);
            }
            System.out.println();
        }

        while(count &gt;= 0)
        {
            int[][] dir = new int[][] { {0,1},{1,0},{ 0,-1},{-1,0}};
            for(int i=0;i&lt;dir.length;i++)
            {
                int nx = lastX + dir[i][0];
                int ny = lastY + dir[i][1];
                if(nx &lt; 0 || nx &gt;= maze[0].length || ny &lt; 0 || ny &gt;= maze.length) continue;
                if((int)maze[ny][nx]==count) 
                {
                    s.push(new int[] {nx, ny});
                    lastX = nx; lastY = ny;
                    count--;
                    break;
                }
            }
        }

        while(!s.isEmpty()) { res.add(s.pop()); };
        
        return res;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_3"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_4" name="code_4" class="center">
<a class=".title">Top K Frequently Mentioned Keywords</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_4">
<code class="language-java">

/* @@DESCRIPTION
692. TOP K Frequent words. 前K個最高頻字或元素.
給一堆可能從覆的關鍵字，一堆評價文章。找出前K個最高頻字.同頻字要依照字母順序排.
解法是將每個評價文轉成小寫並拆成字組存入HashSet排除從覆字.儲存每字出現字數到對照表。
依出現次數由大排到小. 取前K個。
更快的方法是，使用最小堆積優先佇列. 用K log(K)的方法，讓佇列只留下最高頻字數的前K個.
將佇列提出的順序反轉就是前K個.
*/

public class TopKFrequentlyMentionedKeywords 
{   // related problems:
    // https://leetcode.com/problems/top-k-frequent-words/
    // https://leetcode.com/problems/top-k-frequent-elements/
    // solution from 35 - 79 = about 45 lines
    public List&lt;String&gt; nlogn_Sort(Map&lt;String,Integer&gt; m, int k)
    {   // sort in a descending order based on word frequency from large to small.
        List&lt;String&gt; res = new ArrayList(m.keySet());
        // 從字數出現次數大到小排. 相等次數者，依字串字母排序。
        Collections.sort(res, (w1, w2) -&gt; (m.get(w1) == m.get(w2) ? w1.compareTo(w2) : m.get(w2)-m.get(w1)) );
        return res; //由出現次數高至低排列的答案
    }

    public List&lt;String&gt; nlogk_Sort(Map&lt;String,Integer&gt; m, int k)
    {   
        // 從字數出現次數小到大排. 相等次數者，依字串字母排序。由於是反轉後，才是正確的順序。字母排序也是相反的。
        // 用最小堆積從小數到大數排，小數先排出。最後會留下最大的。
        PriorityQueue&lt;String&gt; q = new PriorityQueue&lt;&gt;( (w1, w2) -&gt; (m.get(w1) == m.get(w2) ? w2.compareTo(w1) : m.get(w1)-m.get(w2)));

        // 將數值放入最小堆積自已排序，堆積大於k個，就排出最小的。最後會只留下K個最大值。
        // 這方法是N*log(K) time complexity.
        for (Map.Entry&lt;String, Integer&gt; entry : m.entrySet()) {
            q.offer(entry.getKey());
            if (q.size() &gt; k) { q.poll(); }  // ensure each insertion only uses log(k)       
        }
    
        // 將最小堆積內容取出反轉順序。 最小堆積從小到大排，答案是從大到小排。
        List&lt;String&gt; res = new ArrayList&lt;&gt;();        
        while (q.size() &gt; 0) {
            String w = q.poll();
            res.add(w);
        }    
        Collections.reverse(res); //reverse the order        
        return res; //由出現次數高至低排列的答案
    }

    public List&lt;String&gt; TopKFrequent(String[] keywords, String[] reviews, int k, boolean nlogksort )
    {  // 關鍵字表存放需要被計數的字，符合者才被計數.
        Set&lt;String&gt; keywordSet = new HashSet&lt;&gt;(Arrays.asList(keywords)); // 將重覆的關鍵字除去
        Map&lt;String, Integer&gt; m = new HashMap&lt;&gt;(); //字數對照表

        for(String r: reviews)
        {   // split based on non-character. characters:[a-zA-Z0-9_]
            String[] strs = r.split(&quot;\\W&quot;); //將review 段落中的單字都取出，由段落的非單字如空白，標點等等來分割這些單字。
            Set&lt;String&gt; inReview = new HashSet&lt;&gt;(Arrays.asList(strs)); //將重覆的單字除去
            for(String w:inReview) //針對這個review中的個別單字計數
            {  
                w = w.toLowerCase();  // 轉成小寫，確保比較字串時，不用分大小寫.
                if(keywordSet.contains(w)) // 該字必須在關鍵字表才要計數
                {
                    m.put(w, m.getOrDefault(w,0)+1); // 計錄該單字的全域出現次數
                }
            }
        }

        // 取出單字全域出現次數最高的K者
       List&lt;String&gt; res = nlogksort ? nlogk_Sort(m,k) : nlogn_Sort(m, k);
       return res.subList(0,k); // [0,K)
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_4"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_5" name="code_5" class="center">
<a class=".title">Sub Tree With Maximum Average</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_5">
<code class="language-java">
//多元樹的最大平均值
//每個節點下的子樹節點值全部相加除總節點個數就是該子樹平均值
//求那一個節點下的子樹平均值是全域最大平均值
class SubTreeWithMaximumAverage 
{
    class RefValue
    {
        public NaryTreeNode maxNode;
    }

    public NaryTreeNode getMaxAverageSubTree(NaryTreeNode root)
    {
        RefValue maxSubTree = new RefValue();
        float[] res = getSumAndAverage(root, maxSubTree);
        return maxSubTree.maxNode;
    }
    // postorder traveral, bottom-up approach
    public float[] getSumAndAverage(NaryTreeNode root, RefValue maxSubTree)
    {
        if(root==null) return new float[]{0,0, 0};
       //當前節點總和，當前最大平均及節點個數
        float sum = root.val; // 當前節點的值
        float maxAverage = 0; // 最大平均數未知
        float childCount = 1; //當前節點也算一個節點

        if(root.nodes.size() &gt; 0)
        {
            for(NaryTreeNode child: root.nodes)
            {   //取得每節點的節點子樹總和值，最大平均值及子樹節點個數
                float[] res = getSumAndAverage(child, maxSubTree);     
                sum+= res[0]; //計算當前節點的總和值    
                childCount+=res[2];// 計算當前節點的                      
                if(maxAverage &lt; res[1]) //比較所有個個子樹的最大平均值
                {                 
                    System.out.print(maxAverage +  &quot; &lt; &quot; + res[1]); 
                    maxAverage = res[1]; // 更新當前節點的最大平均值
                    maxSubTree.maxNode = child; //更新全域最大平均值節點
                    System.out.println(&quot; [&quot; + maxSubTree.maxNode.val +&quot;]&quot;);
                }
            }
            //計算當前節點平均值
            float average = sum / (childCount);
            if(maxAverage &lt; average)
            {                 
                System.out.print(maxAverage +  &quot; &lt; &quot; + average); 
                maxAverage = average;
                maxSubTree.maxNode = root;
                System.out.println(&quot; [&quot; + maxSubTree.maxNode.val +&quot;]&quot;);
            }
        }
        //傳回當前節點子樹總和值，當前最大平均值及子樹節點個數
        return new float[]{sum, maxAverage, childCount };
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_5"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_6" name="code_6" class="center">
<a class=".title">Subtree Of Another Tree</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_6">
<code class="language-java">

class SubtreeOfAnotherTree 
{
    public boolean isSubtree(TreeNode s, TreeNode t) {        
        return s!=null &amp;&amp; (
            sameStructure(s,t) || //根節點樹是否等於傳入的樹t
            isSubtree(s.left,t) || //左節點樹是否等於傳入的樹t
            isSubtree(s.right,t)  //右節點樹是否等於傳入的樹t
        ); // 以此類推，是否某個節點樹等於傳入的樹t
    }
    
    public boolean sameStructure(TreeNode a, TreeNode b)
    {
        if(a==null &amp;&amp; b ==null) // 空值樹是相同結構
            return true;
        
        if(a!=null &amp;&amp; b !=null &amp;&amp;
          a.val == b.val) // 當前節點相等，就往下檢查該子樹的節點是否都相等
        {   //對同位左右節點比較      
            return sameStructure(a.left, b.left) &amp;&amp; sameStructure(a.right, b.right);
        }   
        
        return false;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_6"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_7" name="code_7" class="center">
<a class=".title">Substrings Of Size Kwith K Distinct Chars</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_7">
<code class="language-java">
import java.util.ArrayList;
class SubstringsOfSizeKwithKDistinctChars 
{
    public List&lt;String&gt; substringsOfSizeKwithKDistinctChars(String s, int k)
    {
        List&lt;String&gt; res = new ArrayList&lt;&gt;(); //存解答的子字串
        Set&lt;String&gt; set = new HashSet&lt;&gt;(); //
        int[] m = new int[256]; // 存字母出現次數,假設ASCII code is used

        for(int i=0, j = 0;i &lt; s.length() &amp;&amp; j &lt; s.length(); )
        {
            if(m[s.charAt(i)]==0) // 第一次出現此字母
            {
                m[s.charAt(i++)]++; // 計算此字母出現次數，移動尾指標(快指標)
            }
            else  // 同樣的字母又出現一次，移動頭指標(慢指標)直到此字母在此[j,i]區間只出現過一次.
            {
                m[s.charAt(j++)]--; 
            }

            // 當前[j,i] 區間就是保證一個字母只能出現一次
            if(i-j==k) {  // 如果長度為K,由於字母一次只在此區間出現一次，那這子字串肯定是只有K個獨特字元。
                String sub = s.substring(j,i); // 取該區間的子字串
                //用 Set 確定，重覆的答案只存一次。
                if(!set.contains(sub)) { res.add(sub); }
                set.add(sub); // 這答案不能再出現，存入set，方便下次檢查.
                m[s.charAt(j++)]--; // 這區間不再計入答案，移動頭指標，也得更新字母頻表.
            }
            
        }
        return res;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_7"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_8" name="code_8" class="center">
<a class=".title">Substrings Of Exactly K Distinct Chars</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_8">
<code class="language-java">

class SubstringsOfExactlyKDistinctChars 
{

    public int substringswithExactlyKDistinctChars(String s, int K)
    {
        CategoryCounter&lt;Character&gt; w1 = new CategoryCounter&lt;Character&gt;();
        CategoryCounter&lt;Character&gt; w2 = new CategoryCounter&lt;Character&gt;();
        int count = 0, left1=0, left2 = 0;
        for(int i=0;i&lt;s.length();i++)
        {
            Character c = s.charAt(i);
            w1.add(c);
            w2.add(c);
            while(w1.kinds() &gt; K) w1.remove(s.charAt(left1++));
            while(w2.kinds() &gt;= K) w2.remove(s.charAt(left2++));
            count += left2-left1;
        }
        return count;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_8"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_9" name="code_9" class="center">
<a class=".title">Subarrays With K Different Integers</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_9">
<code class="language-java">
import java.util.*;
/*
  [1,2,3] 有多少子陣列?
  形公式可求出: (1+3)*3/2 = 6
  子陣列: [1], [2], [3], [1,2], [2,3], [1,2,3]
  也可用執行樹狀態圖(backtracking 來畫):
  在[1,3]區間中，只包含[3]的子陣列數量 count([3])= f([1,3]) - f([1,2]) = 6 - (1+2)*2/2 = 6-3 = 3
  在[1,2]區間中，只包含[2]的子陣列數量 count([2])= f([1,2]) - f([1,1]) = 3 - 1 = 2
  https://math.stackexchange.com/questions/1941224/number-of-occurrences-in-contiguous-subarrays
*/
class SubarraysWithKDifferentIntegers 
{
    //Longest SubString With K Distinct Characters
    //要了解該程式，必須懂得解 
    //傳回陣A所有子陣列中，剛有k個種類的數字的子陣列數量.
    public int subarraysWithKDistinct(int[] A, int K) {        
        CategoryCounter&lt;Integer&gt; w1 = new CategoryCounter&lt;Integer&gt;();
        CategoryCounter&lt;Integer&gt; w2 = new CategoryCounter&lt;Integer&gt;();
        int left1=0, left2 =0;
        int count = 0;
        
        for(int i=0;i &lt; A.length;++i)
        {
            int x = A[i];
            w1.add(x);
            w2.add(x);
            
            //當前i位置就有K+種類，移除當前left1位置的字母來更新種類數直至w1只有K種.
            //w1 此時的  [left1, i] 的區間包括K種類及K以下種類的子區間
            while(w1.kinds() &gt; K ) w1.remove(A[left1++]);

            //當前i位置就有K+種類，移除當前left2位置的字母來更新種類數直至w2只有K-1種.
            //w2 此時的 [left2, i] 的區間包括K-1及K-1以下種類的子區間
            while(w2.kinds() &gt;= K ) w2.remove(A[left2++]);
            
            // w1區間長度 - w2區間長度 = 只有包含K種類區間的子陣列數目 
            count+= left2-left1;            
        }
        
        return count;
    }

 }

</code>
</pre>
</div>

<template id="my-label-button-code_9"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_10" name="code_10" class="center">
<a class=".title">Search Suggestion System</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_10">
<code class="language-java">

/* @@DESCRIPTION
1268. Search Suggestion System 搜索推荐系統. 建議列表. 自動完成表.
在每次打入一個字母時，下拉選單會自動提示最接近當前輸入關鍵字字首的產品名稱.最多提示三個產品，並按照字母順序。
可用對應26個字母的字首樹資料結構來解決這題. 每個字首樹節點還得儲存當前字首對應的產品推荐表以方便快速查尋.
產品清單必須排序後，才存入字首樹中。
*/

public class SearchSuggestionSystem  {
    // System Design interview for auto suggestions: https://www.youtube.com/watch?v=xrYTjaK5QVM
    // https://leetcode.com/problems/search-suggestions-system
     class Trie { // 26字母的Trie樹結構
     Trie[] sub = new Trie[26];
     List&lt;String&gt; suggestion = new LinkedList&lt;&gt;();//每個節點存至該子字串的產品
     }
 
     // autocomplete/typehead
     // suggest 3 items based on a searchWord currently typed.
     // 根據當前產品搜尋關鍵字，建議至少3個產品。
     public List&lt;List&lt;String&gt;&gt; suggestedProducts(String[] products, String searchWord) {
         Arrays.sort(products); // 產品必須照字母排序先.
         
         List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();
         Trie root = new Trie();
         for(String p: products) //每個產品照字母排序，存入對應的Trie樹節點位置.
         {
             Trie r = root;//取得Tire樹根節點位置
             for(char c : p.toCharArray())
             {
                 if(r.sub[c-'a']==null) r.sub[c-'a'] = new Trie(); // 建立當前Tire樹所需要對應字母的Tire樹
 
                 r = r.sub[c-'a'];// 取得當前字母對應的Tire樹位置。
                 // 如果建議的產品小於三個，繼續加到表中。
                 if(r.suggestion.size() &lt; 3) r.suggestion.add(p);
             }
         }
         
         for(char c: searchWord.toCharArray())//遍歷產品搜尋關鍵字的每個字元
         {
             if(root!=null) root = root.sub[c-'a']; // 取得當前字母對應的Tire樹
             // 沒有就存空表，不然存當前字母對應Tire樹推
             res.add( (root==null) ? Arrays.asList() : root.suggestion);
         }
         //答案有對應同一關鍵字中，每個區間的搜尋結果.
         return res;
     }
 
 }

</code>
</pre>
</div>

<template id="my-label-button-code_10"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_11" name="code_11" class="center">
<a class=".title">Search Matrix</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_11">
<code class="language-java">

public class SearchMatrix 
{   // o(n):排除解法
    public boolean searchMatrix(int[][] matrix, int target) {
        //二維陣列為空值，或大小為零，就傳回找不到此值。
        if(matrix==null || matrix.length==0 || matrix[0].length==0 ) return false;
        int col = matrix[0].length-1;//最右邊的位置
        int row = 0;//第一行
        
        while(row &lt; matrix.length &amp;&amp; col &gt;= 0)
        {
            if(matrix[row][col]==target) return true; //找到該值
            if(matrix[row][col] &lt; target) row++; // 排除此行
            else col--; // 排除此列
        }
        
        return false; //找不到該值
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_11"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_12" name="code_12" class="center">
<a class=".title">Rottin Oranges</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_12">
<code class="language-java">
import java.util.LinkedList;
/* @@DESCRIPTION
994. Rotting Oranges 爛橙子
0 = 沒橙子在此， 1 = 爛橙子在此, 2 = 好橙子在此,
給一個九宮格或更大的宮格.裡面有相鄰的橙子，也可能有不相鄰的橙子或沒有橙子。
每一分鐘，爛橙子會弄爛四方相鄰新橙子. 算出爛橙子弄爛所有橙子所需時間。不可能全部弄爛就傳回負一.
解法是使用廣度優先搜索，將爛橙子座標當成起始佇列元素. 計算新橙子個數。 每一佇列迴圈周期，針對所有欄橙子的四方查是否有
新橙子，有就弄爛放入佇列，個數減一，所需分鐘加一. 如果某個好橙子不鄰接任何爛橙子，代表不可能全部弄爛. 
*/

public class RottinOranges   {
    //https://leetcode.com/problems/rotting-oranges/
    // Zombie in Matrix: https://leetcode.com/discuss/interview-question/411357/
    // Minium hours to send file to all available servers
    public int orangesRotting(int[][] grid) {
        //使用廣優搜，必須用佇列(隊列)
        Queue&lt;Integer[]&gt; q = new LinkedList&lt;&gt;();
        int initalFreshOrangeCount =0; // 初始好橙子數
        // 設定廣優搜起點，遍歷整個網格
        for(int i=0;i&lt;grid.length;i++)
            for(int j=0;j&lt;grid[0].length;j++)
            {   // 以爛橙子當做廣優搜起點
                if(grid[i][j]==2) q.offer(new Integer[] {i,j});
                if(grid[i][j]==1) initalFreshOrangeCount++;//計算網格上的初始初始好橙子數
            }
        
        if(initalFreshOrangeCount==0) return 0; // 特別狀況(邊角案例)，沒有好橙子。不需要繼處理.
        // 四方向陣列
        int[][] dir = new int[][]{{0,1},{1,0},{0,-1},{-1,0}};
        // 如果一開始沒有任何好橙子只有爛橙子，等於0分鐘就全爛了.
        // 如果一開始有一個好橙子及鄰接的一個爛橙子，當前爛橙子弄爛好橙子後，該新的爛橙子會在佇列。
        // 最後一次新的爛橙子組，沒有鄰接的好橙子弄爛，該次是不能計算。用-1來初始才是正確的.
        int time = -1; 
        
        while(q.size() &gt; 0) // 還有爛橙子的話
        {
            int size = q.size(); //當前爛橙子數
            for(int i=0;i&lt;size;i++) // 遍歷所有當前爛橙子組
            {
                Integer[] pos = q.poll(); // 取出當前爛橙子                        
                for(int j=0;j&lt;dir.length;j++) // 查看當前爛橙子的鄰接節點是否有好橙子
                {  // 計算當前鄰接位置
                    int nx= pos[0] + dir[j][0];
                    int ny =pos[1] + dir[j][1];
                    //當前鄰接位置必須在網格內 
                    if(nx &lt; 0 || ny &lt; 0 || nx &gt;= grid[0].length || ny &gt;= grid.length) continue;
                    
                    if(grid[ny][nx]==1) // 當前鄰接位置有好橙子
                    { 
                        grid[ny][nx] = 2; // 弄爛當前好橙子，將好橙子設成爛橙子
                        initalFreshOrangeCount--;// 好橙子變少一個
                        q.offer(new Integer[]{ny,nx}); //存入當前爛橙子位置，好再下次弄爛其鄰接節點好橙子.
                    }
                }      
            }
            
            time++;
        }
        
        //初始好橙子數為零，代表全被弄爛了。
        return (initalFreshOrangeCount==0) ? time:-1; //-1 also means it's not possible to rotten every orange.
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_12"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_13" name="code_13" class="center">
<a class=".title">Reorder Data In Log File</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_13">
<code class="language-java">

public class ReorderDataInLogFile 
{
    // 有digial log及letter log 兩種。
    // (1)letter log 在digital log 之前.
    // (2)letter log 照第二子串字串a-z排。如果第二字串都相等，用第一字串a-z排.
    // (3)digital log 照原順序排.
    public String[] reorderLogFiles(String[] logs) {
        Arrays.sort(logs, (log1, log2) -&gt; {
            String[] split1 = log1.split(&quot; &quot;, 2); //用空白拆字串，只要前兩個拆下來的子字串。
            String[] split2 = log2.split(&quot; &quot;, 2); //用空白拆字串，只要前兩個拆下來的子字串。
            boolean isDigit1 = Character.isDigit(split1[1].charAt(0));//查第二個子字串是否為數字
            boolean isDigit2 = Character.isDigit(split2[1].charAt(0));//查第二個子字串是否為數字
            if (!isDigit1 &amp;&amp; !isDigit2) {//兩個字串的第二子字串都不是數字.
                int cmp = split1[1].compareTo(split2[1]);//第二字串a-z排
                if (cmp != 0) return cmp; //第二字串不相等，用第二字串排.
                return split1[0].compareTo(split2[0]); //第二字串相等，用第一字串a-z排
            }
            //其它 11, 10, 01 狀況
            // 11:都是數字log, 傳回0代表相等，暗示使用原來排序。
            // 10: 只有log1是數字log，傳回1 代表，左邊log1排到後面。
            // 01: 只有log2是數字log，傳回-1 代表，右邊log2排到後面。
            return isDigit1 ? (isDigit2 ? 0 : 1) : -1;
        });
        return logs;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_13"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_14" name="code_14" class="center">
<a class=".title">Prison Cells After N Days</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_14">
<code class="language-java">
import java.util.HashSet;
class PrisonCellsAfterNDays  {

    public int[] prisonAfterNDays(int[] cells, int N) {
        // 陣列為空值，沒有元素，或著N代表第零天，就傳回原始陣列。
        if(cells==null || cells.length == 0 || N &lt;= 0) return cells;

            Set&lt;String&gt; set = new HashSet&lt;&gt;();//以整個cell陣列內容當鍵值存每天prision的狀態.
            
            while(0 &lt; N) //共有N天的狀態要處理
            {
                int[] next = nextDayCell(cells); //取得下一天的狀態
                String curKey = Arrays.toString(next);// 下一天陣列內容狀態轉成字串，方便存取
                // 此狀態存在過，代表己經開始進入重覆狀態的環
                if(set.contains(curKey))
                {                
                    N%=set.size(); //N的餘數代表狀態陣列中對應的位置就是答案。
                    // 由於我們沒有天數對照狀態表，我們用nexyDayCall重新計算.
                    while(0 &lt; N--) cells  = nextDayCell(cells);
                    
                    return cells; //這就是N的餘數所代表的prison狀態
                }
                else
                {  //此狀態沒存過,記錄下來
                    set.add(curKey);
                }
                                
                cells = next; // 處理完後，當前prision狀態就是下個prison狀態。  
                N-=1;// 天數過了一天
            }
            
            return cells;
        }
        
        public int[] nextDayCell(int[] cells)
        {   //建立新陣列來存下一天的狀態
            int[] temp = new int[cells.length];
            // 陣列第一個及最後位置的值必為零。因為無法得知第一位置左鄰居值及最後位右鄰居值。
            // 計算下一天的狀態,除了第一及最後位置外，遍歷所有位置。從第二個位置遍歷至倒數第一個. 
            for(int i=1;i&lt;cells.length-1;i++) 
            {  // 下一天的同位置的狀態，是左右鄰居都為0或1，也就是相等時，下一天同位置的值為1.
                temp[i] = (cells[i-1]==cells[i+1]) ? 1:0;        
            }
            return temp;//傳回下一天狀態.
        }

}

</code>
</pre>
</div>

<template id="my-label-button-code_14"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_15" name="code_15" class="center">
<a class=".title">Partition Label</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_15">
<code class="language-java">
/* @@DESCRIPTION
763. Partition Labels. 劃分字母區間.
將只包含小寫字母的字串盡可能的畫分成多個區間，同一字母只能出現在一個區間中，傳回每個區間的長度.
解法是遍歷整個字串，用包含26個元素的陣列對照表記錄每個字母出現的最後位置. 再遍歷整個字串，當前字串的位置如果等於當前最大最後位置即可計算區間長度.

*/
import java.util.ArrayList;
public class PartitionLabel 
{
    public List&lt;Integer&gt; partitionLabels(String S) {
        int[] last = new int[26];
        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
        //建立26個小寫字母，每個字在字串上出現的最後位置的對照表
        for(int i=0;i&lt;S.length();i++)
            last[S.charAt(i)-'a'] = i;           
        // lastMax是當前區間最大最後位置。 start 是區間起始位置
        int lastMax = 0, start = 0; 
        //遍歷整個字串，處理每個字母
        for(int i=0;i&lt;S.length();i++)
        {   //當前字母的最後位置跟之前某字母的最後位置比，取最大最後位置者.
            //當前最大最後位置者，可能是當前字母，也可能是之前某個在字串上的字母。
            lastMax = Math.max( last[S.charAt(i)-'a'], lastMax);           
            //如果當前最大最後位置，是當前索引，表代當前字母及所有之前字母只出現在這個區間。
            if(lastMax==i)
            {   // 計算區間長度，並存入ArrayList.
                res.add(lastMax-start+1);                    
                start = i+1; //記錄下個區間起始位置，好計算下個區間長度.
            }
        }
        
        return res;//傳回所有劃分字母區間
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_15"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_16" name="code_16" class="center">
<a class=".title">Optimal Utilization</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_16">
<code class="language-java">
import java.util.*;
/*  @@DESCRIPTION
Amazon 題: Optimal Utilization. 最佳效用值. 
兩組陣列，每組選一數字，找出小於等於並最接近目標數的兩數之和。
解法可用左右雙指標最佳解,二元搜尋或TreeMap.
*/
class OptimalUtilization 
{ // quite correct result.

    public int binarySearch(int[][] sorted, int target, boolean lowerBound)
    {
        int l = 0;
        int r = sorted.length -1;
        int mid = 0;
        int lastKeyPos = -1;
        while(l &lt;= r)
        {
            mid = (l+r)/2;
            int x = sorted[mid][1];

            if(target &lt; x) r= mid-1;
            else if(target &gt; x) l= mid +1;
            else
            {
                lastKeyPos = mid;
                if(lowerBound) r= mid-1;
                else l = mid +1;                
            }
        }

        return (lastKeyPos==-1) ? -(l+1): lastKeyPos;
    }

    // get target sum or closet sum answer from two non-sorted array
    // if no target answer, we only pick the closet sum answer. 
    // for example, target = 20. if next sum answer is 19,18, we only pick all answers of 19.
    // better than Brute Force. 
    public List&lt;List&lt;Integer&gt;&gt; getOptimalUtilization(int[][] a, int[][] b, int target)
    {   
        Arrays.sort(a, (i,j) -&gt; i[1]-j[1]);
        Arrays.sort(b, (i,j) -&gt; i[1]-j[1]);

        int l = 0;
        int r = b.length-1;
        int minCloset = Integer.MAX_VALUE;
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();

        while(l &lt; a.length &amp;&amp; r &gt;= 0)
        {
            int sum = a[l][1] + b[r][1];
            int diff = sum - target ;

            if(sum &gt; target ) r--;
            else {
                
                if(diff&lt;= 0)
                {
                    diff = Math.abs(diff);
                    if(minCloset &gt; diff)
                    {
                        minCloset = diff;
                        res.clear(); 
                        res.add(Arrays.asList( a[l][0], b[r][0]));                  
                    }
                    else if(minCloset == diff)
                    {
                        res.add(Arrays.asList( a[l][0], b[r][0]));                  
                    }
                }

                l++;
            }

        }

        return res;
    }

    // binary search approach
    public List&lt;List&lt;Integer&gt;&gt; binarySearch_getOptimalUtilization(int[][] a, int[][] b, int target)
    {   
        Arrays.sort(a, (i,j) -&gt; i[1]-j[1] ); 
        Arrays.sort(b, (i,j) -&gt; i[1]-j[1] ); 
        List&lt;int[]&gt; candidates = new ArrayList&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        int k =  b.length-1;
        
        while(k  &gt;= 0) 
        {
            int complement = target - b[k][1];
            int index = binarySearch(a, complement, true); 
           // System.out.println(&quot;found at &quot; + index + &quot; for key = &quot; + complement );
           if(index &lt; 0) { 
            index = -index -1; // index of the least integer greater than key
            index = index -1; // index of the greatest integer less than key
           }

            while(index &gt;= 0 &amp;&amp; index &lt; a.length) 
            {
            int diff = target - (a[index][1]+ b[k][1]);
            candidates.add(new int[]{a[index][0], b[k][0], diff }  );
            index--;
            }
           
            k--;
        }

        Collections.sort(candidates, (i , j) -&gt;  i[2]-j[2]  );

        Integer[] lastDiff = { null};

        candidates.forEach( p -&gt; {            
            if(lastDiff[0]==null || lastDiff[0]==p[2])
            {
  //              System.out.println(&quot;(&quot; + Arrays.toString(p) + &quot;)&quot;);
                res.add(Arrays.asList(p[0],p[1]) );
                lastDiff[0] = p[2];
            }
        });

        return res;
    }
    
    // same as binarsearch. TreeMap can be used for two dimension array source
    public List&lt;List&lt;Integer&gt;&gt; TreeMap_getOptimalUtilization(int[][] a, int[][] b, int target)
    {   
        TreeMap&lt;Integer,Integer&gt; pos = new TreeMap&lt;&gt;();
        List&lt;int[]&gt; candidates = new ArrayList&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();

        for(int i=0; i &lt; a.length;i++)
        {
            pos.put(a[i][1],a[i][0]);
        }

        Arrays.sort(b, (i,j) -&gt; i[1]-j[1] ); 

        int k = b.length -1;
        while(k&gt;0)
        {
            int complement = target-b[k][1];
            Map&lt;Integer,Integer&gt; candidate = pos.headMap(complement, true);

            for(Map.Entry&lt;Integer,Integer&gt; e : candidate.entrySet())
            {
                int index = e.getValue();
                int value = e.getKey();
                int diff = target - (value+ b[k][1]);
                candidates.add(new int[]{ index , b[k][0], diff});
            }
            
            k--;
        }

        Collections.sort(candidates, (i , j) -&gt;  i[2]-j[2]  );

        Integer[] lastDiff = { null};

        candidates.forEach( p -&gt; {            
            if(lastDiff[0]==null || lastDiff[0]==p[2])
            {
//                System.out.println(&quot;(&quot; + Arrays.toString(p) + &quot;)&quot;);
                res.add(Arrays.asList(p[0],p[1]) );
                lastDiff[0] = p[2];
            }
        });

        return res;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_16"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_17" name="code_17" class="center">
<a class=".title">Number Of Clusters</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_17">
<code class="language-java">

// 
public class NumberOfClusters  {
    // questions: https://www.glassdoor.com/Interview/Problem-2d-grid-each-node-has-1-colors-find-number-of-clusters-of-a-given-color-red-blue-green-blue-gre-QTN_2930567.htm
    // https://leetcode.com/problems/number-of-islands/
    public int[] numberOfClusters(char[][] grid) {
        //設定顏色及該顏色群集(色塊)數量的位置
        char[] colors = new char[] {'0','1','2'};
        int[] count = new int[] { 0,0,0};

        for(int i=0;i&lt;grid.length;i++)
        {
            for(int j=0;j&lt;grid[0].length;j++)
            {   //沒必要訪問已訪問的節點
                if(grid[i][j]=='v') continue; 

                for(int k=0;k&lt;colors.length;k++)
                {   //針對未訪問的位置，遍歷同一顏色來計算該顏色群集數
                     if(grid[i][j]==colors[k]) 
                    {
                        dfs(grid, i, j, colors[k]);
                        count[k]++;//計算該顏色群集數
                        break; //當前節點己訪問,且是該顏色，沒必要查其它顏色
                    }
                }
            }
        }

      //  System.out.println(&quot;counts: &quot; + Arrays.toString(count));
        return count;
    }
    
    public void dfs(char[][] grid, int y, int x, char target)
    {   // 不在grid範圍內的不用查。
        if(x &lt; 0 || x &gt;= grid[0].length || y &lt; 0 || y &gt;= grid.length ) return;        
        if(grid[y][x]!= target) return;// 非要查的顏色不用深度遍歷
        
        grid[y][x]= 'v'; // 將該位置或節點設定已經訪問過
        // 遍歷當前節點的所有鄰接節點，由於是grid, 只有四個鄰接節點要去訪問。
        dfs(grid, y+1, x, target);
        dfs(grid, y-1, x, target);
        dfs(grid, y, x+1, target);
        dfs(grid, y, x-1, target);
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_17"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_18" name="code_18" class="center">
<a class=".title">Nth Geometric Progression</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_18">
<code class="language-java">
class NthGeometricProgression   {

    public char[] getNthGP(double secondTerm, double thirdTerm, int nth)
    {
        double r = thirdTerm/ secondTerm;
        double a = secondTerm/r;
        double result = a*Math.pow(r, nth-1);
        String str = String.valueOf(result);
        int pos = str.indexOf('.');

        if(pos &gt; 0) // trim up to 
        {
           int decimalPlaces = 3;
           str = str.substring(0, Math.min(pos+decimalPlaces+1, str.length())); 
        }

    //    System.out.println(&quot;res =&gt; [&quot; + str + &quot;]&quot;);
        return str.toCharArray();
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_18"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_19" name="code_19" class="center">
<a class=".title">Most Common Word</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_19">
<code class="language-java">

/*  @@DESCRIPTION
Amazon 題: 最常用字.
給一段文章及禁用字(粗話字)清單. 將禁用字排除在外，找出文章中的最高頻字.
最佳解是不能排序。將禁用字轉小寫存入HashSet排除重覆字。文章轉小寫拆成字組. 針對非禁用字計數. 不斷地更新當前最大值及當前最高頻字.
*/
class MostCommonWord 
{
    public String mostCommonWord(String paragraph, String[] banned) {
        // W means non-word character. + means more than one non-word can be used. 
        String[] words = paragraph.split(&quot;\\W+&quot;); 
        HashSet&lt;String&gt; bannedWords = new HashSet&lt;&gt;(); //除去重覆元素，只要獨特(distinct)元素用.
        HashMap&lt;String,Integer&gt; m = new HashMap&lt;&gt;();//記錄字出現次數(frequency)
        String maxWord = null;
        int max = 0; // 記錄全域最高頻字的出現次數,用以快速記錄全域&quot;唯一&quot;最高頻字
        for(String b : banned) // 建造禁用字表，重覆的禁用字不需要，
        bannedWords.add(b.toLowerCase()); //轉小寫方便比較字串或當哈希表鍵值。
        
        for(String w: words) //遍歷文章段落上每個字
        {
            w = w.toLowerCase(); //轉成小寫好比較字串
            if(!bannedWords.contains(w)) //如果不是禁用字
            {   //計算該字的出現次數
                m.put(w, m.getOrDefault(w,0)+1);
                int count =m.get(w); //取出該字出現次數
                if(count &gt; max) //如果該字比全域最高頻字的出現次數還高
                {
                    maxWord = w; //記錄成全域最高頻字
                    max = count; //記錄成全域最高頻字的出現次數
                }
            }
        }
        
        return maxWord; // //傳回全域最高頻字
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_19"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_20" name="code_20" class="center">
<a class=".title">Minimum Cost To Connect Rope</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_20">
<code class="language-java">
import java.util.PriorityQueue;

/*  @@DESCRIPTION
Amazon 題: 連接所有繩子的最小成本
有一堆不同長度的繩子. 每次連接兩繩子的成本就是兩繩長度總和.
請問連接所有繩子的最小成本為何?
由於最小成本必定是要每次都只連接兩個最短繩子,解法是用最小堆積優先佇列存入所有繩長度.
每次取出兩最短繩長度相加. 新連成的繩子也可能還是最短繩之一,所以要把新繩子長度再放入佇列. 這樣一直計算下去，最後所有相加的總和就是最小成本。
*/

class MinimumCostToConnectRope 
{
    public int minCostToConnectRope(int[] ropes)
    {
        int res = 0; //總長度
        //用最小堆積，由小到大排.
        PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();
        for(int len : ropes) { minHeap.add(len); }

        while(minHeap.size() &gt; 1)//至少有兩個就執行
        {   //從最小堆積取當前最小兩長度值，兩長度值就是最小成本值.
            int combinedLen = minHeap.poll() + minHeap.poll();
            res += combinedLen; // 總和至總成本值
            //新繩子也要，新繩子最終也被連成總繩子，也可能是最短繩。
            minHeap.offer(combinedLen);
        }

        return res;//傳回總成本,必須是最正的最小成本
    }

    public void performTest()
    {
        Helper.equals(minCostToConnectRope(new int[]{2, 4, 3}) , 14, &quot;[2,4,3]: &quot;);
        Helper.equals(minCostToConnectRope(new int[]{8, 4, 6, 12}) , 58, &quot;[8,4,6,12]: &quot;);
        Helper.equals(minCostToConnectRope(new int[]{2, 2, 3, 3}) , 20, &quot;[2, 2, 3, 3]: &quot;);
        Helper.equals(minCostToConnectRope(new int[]{1, 2, 5, 10, 35, 89}) , 224, &quot;[1, 2, 5, 10, 35, 89]: &quot;);

    }

    public String toString() { 
        return &quot;Minimum Time to merge files/Minimum Cost to connect Ropes ([E]) [https://leetcode.com/discuss/interview-question/344677]&quot;;
    }
}
</code>
</pre>
</div>

<template id="my-label-button-code_20"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_21" name="code_21" class="center">
<a class=".title">Min Cost To Connect All Nodes Or Repair Edges</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_21">
<code class="language-java">
import java.util.*;
class UF {
    private int[] parent;
    private int[] rank;
    private int count;

    public UF(int N)
    {
        count = N;
        parent = new int[N];
        rank = new int[N];
        for(int i=0;i&lt;N;i++)
        {
            parent[i]=i;
            rank[i]=0;
        }
    }

    public int find(int x)
    {
        while(x!=parent[x])
        {
            parent[x] = parent[parent[x]]; // path compresion
            x = parent[x];
        }

        return x;
    }

    // union by rank
    public void union(int x, int y)
    {
        int rootX = find(x);
        int rootY = find(y);
        if(rootX==rootY) return;
        if(rank[rootX] &lt; rank[rootY])
        {
            parent[rootX] = rootY;
        }
        else
        {
            parent[rootY] = rootX;
            if(rank[rootX] == rank[rootY]) rank[rootX]++;            
        }
        count--;
    }

    public int count() { return count; }
    public boolean connected(int x, int y) { return find(x)==find(y); }
}

class MinCostToConnectAllNodesOrRepairEdges  {

    public static int minCost(int n, int[][] edges, int[][] newEdges) {
        UF uf = new UF(n + 1); // + 1 because nodes are 1-based
        
        Queue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;(newEdges.length, (e1, e2) -&gt; Integer.compare(e1[2], e2[2]));
        HashSet&lt;String&gt; added = new HashSet&lt;&gt;();
        
        for (int[] edge : newEdges) {
            pq.offer(edge);
            added.add(edge[0]+&quot;,&quot;+edge[1]);
        }
                
        for (int[] edge : edges) {
            if(!added.contains(edge[0]+&quot;,&quot;+edge[1])) // ensure the same broken edge is not added.
            {
                pq.offer(new int[]{edge[0],edge[1],0});
            }
        }
        
        int totalCost = 0;
        // 2 because nodes are 1-based and we have 1 unused component at index 0
        while (!pq.isEmpty() &amp;&amp; uf.count() != 2) {
            int[] edge = pq.poll();
            if (!uf.connected(edge[0], edge[1])) {
                uf.union(edge[0], edge[1]);
                totalCost += edge[2];
            }
        }
        return totalCost;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_21"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_22" name="code_22" class="center">
<a class=".title">Merge Two Sorted List</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_22">
<code class="language-java">
/*  @@DESCRIPTION
Merge Two Sorted LinkedList. 合併兩個有序鍊接表.
*/
class MergeTwoSortedList 
{  //使用合併排序法(Merged sort)的合併方法
    public Node mergeTwoLists(Node l1, Node l2) {
        Node dummy = new Node(0);//需要一個標兵，假的資料，方便傳回鍊頭.
        Node temp = dummy;//該標兵同時也是一個新鍊表頭，用來存方合併後的資料.
        // 兩鍊表都還有元素沒遍歷過
        while(l1 !=null &amp;&amp; l2 != null)
        {  // 取兩鍊表當前較小的節點
            Node smaller = (l1.val &lt; l2.val) ? l1:l2;
            temp.next = smaller; // 加到新鍊表尾           
            temp = temp.next; // 新鍊表當前頭下移至尾，好連接下筆新資料.
            // 兩鍊表當前較小的節點，己被取出。必須移動該鍊表當前頭，好讀取下筆資料.
            if(l1.val &lt; l2.val) l1=l1.next;
            else l2 = l2.next;
        }
        //只有一鍊表還有資料沒遍歷完，將所有資料一一連接到新鍊表尾部.
        while(l1!=null) 
        {
            temp.next = l1;  // 加到新鍊表尾  
            temp = temp.next; // 新鍊表當前頭下移至尾，好連接下筆新資料.
            l1 = l1.next; // 必須移動該鍊表當前頭，好讀取下筆資料.
        }
        // 同上，但處理另一個可能性.
        while(l2!=null)
        {
            temp.next = l2; // 加到新鍊表尾  
            temp = temp.next; // 新鍊表當前頭下移至尾，好連接下筆新資料.
            l2 = l2.next; // 必須移動該鍊表當前頭，好讀取下筆資料.
        }
        //標邱的用途來了，直接傳回正確的新鍊頭.
        return dummy.next;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_22"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_23" name="code_23" class="center">
<a class=".title">Merge Intervals</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_23">
<code class="language-java">
import java.util.*;
class MergeIntervals 
{
    public int[][] merge(int[][] intervals) {
        // 空值或只有一個元素時，不用合併。原始陣列就是答案.
		if (intervals== null || intervals.length &lt;= 1) return intervals;

		// 區間排序用起點排，若兩起點相等，用終點排序。
		Arrays.sort(intervals, (i,j) -&gt; i[0]==j[0] ? i[1]-j[1]:i[0]-j[0]);

		LinkedList&lt;int[]&gt; llRes = new LinkedList&lt;&gt;();//方便快速插入刪除的資料結構
		llRes.add(intervals[0]); // 標兵,簡化邏輯,減少程式碼檢查
        
		for (int i=1;i &lt; intervals.length;i++) {
            int[] merged = llRes.getLast();   
            //上面排序後，前起點必定小於當前起點.                     
			if (intervals[i][0] &lt;= merged[1])// 前個終點大於當前起點，兩區間相交(overlapped)
            { // 已知排序後，合併區間
				merged[1] = Math.max(merged[1], intervals[i][1]); 
                // 將最後一個換成合併好的區間.
                llRes.removeLast(); 
               llRes.addLast(merged);
            }
			else { // 不相交區間 disjoint intervals                          
				llRes.add(intervals[i]);
			}
		}
        //轉換linked List成陣列
		return llRes.toArray(new int[llRes.size()][]);
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_23"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_24" name="code_24" class="center">
<a class=".title">Longest String With Three Consecutive Characters</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_24">
<code class="language-java">

class LongestStringWithThreeConsecutiveCharacters   {
    
    // only work for leetcode 1405. Longest Happy String. at most 3 characters. not a general solution
    public void LongestStringWithAtMostKChar(Map&lt;Character, int[]&gt; map, int K, StringBuilder result) {
        PriorityQueue&lt;Map.Entry&lt;Character, int[]&gt;&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; (b.getValue()[0] - a.getValue()[0]));
        for(Map.Entry&lt;Character, int[]&gt; e : map.entrySet()) {
            q.add(e);
        }
        boolean f = false;
        while(!q.isEmpty()) {
            Map.Entry&lt;Character, int[]&gt; current = q.poll();
            if(current.getValue()[0] &gt; 0 &amp;&amp; current.getValue()[1] &lt; K &amp;&amp; !f) {
                result.append(current.getKey());
                map.put(current.getKey(), new int[]{current.getValue()[0] - 1, current.getValue()[1] + 1});
                f = true;
            } else {
                map.put(current.getKey(), new int[]{current.getValue()[0], 0});   
            }
        }
        if(f) {
            LongestStringWithAtMostKChar(map, K, result);
        }
    }

    // INCORRECT. Find the right solution online.
    public String LongestStringWithKConsecutiveCharacters(HashMap&lt;Character, Integer&gt; m, int k)
    {
        System.out.print(&quot;K = &quot; + k + &quot; | &quot;);
        int maxRepeat = k;
        PriorityQueue&lt;Character&gt; pq = new PriorityQueue&lt;&gt;( (c1, c2) -&gt; ( m.get(c1)==m.get(c2) ? c1-c2 :m.get(c2)-m.get(c1) ) );
        
        Iterator&lt;Map.Entry&lt;Character,Integer&gt;&gt; ite = m.entrySet().iterator();

        while(ite.hasNext())
        {
            Map.Entry&lt;Character,Integer&gt; e = ite.next();
            if(e.getValue()&lt;=0) ite.remove();
        }
        
        for(Character c : m.keySet()) { pq.add(c); }

        StringBuilder s = new StringBuilder();
        Character lastChar = null;

        while(pq.size() &gt; 0)
        {            
            Character c = pq.poll(); // get max value

            if(lastChar == c)
            {
               if(pq.isEmpty()) return s.toString();// + &quot;.... (unable to finish) : NOT POSSIBLE &quot;;
                Character next = pq.poll();
                pq.add(c); // add back;
                c = next;
            }
            
            int count = m.get(c);
        //    System.out.print(&quot; pq:&quot; + pq + &quot; , c=&quot;+ c + &quot; | &quot;);

            if(count &gt; 0)
            {
                for(int i=0;  i &lt; Math.min(maxRepeat,count) ; i++)
                {
                    s.append(c);
                    m.put(c,m.get(c)-1);
                }

                if(m.get(c)&gt;0) pq.add(c); // add back 
            }
            lastChar = c;
        }

        return s.toString();
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_24"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_25" name="code_25" class="center">
<a class=".title">Longest Plaindromic Substring</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_25">
<code class="language-java">
class LongestPlaindromicSubstring  {
    // 動態規畫解
    public String longestPalindrome(String s) {
        if(s==null || s.length() &lt; 2) return s;
        // 存全域最大長度用的左右位置
        int left = 0, right = 0;
        int len = s.length();

        //用來存位置i至位置j的字串是否為迴文的記錄表格. 若索引位置小等於2
        boolean[][] isPalindrome = new boolean[len][len]; // isPalindrome[i][j] 
        // 內走一步範圍的字串是迴文，當前區間才可能是迴文.
        // isPalindrome[i][j] = isPalindrome[i+1][j-1] &amp;&amp; s[i]==s[j];              
        
        // 如果 i&lt;j, 不合理.
        // 如果 i==j, 同一個字。 必定是迴文. 沒有內部子字串.
        // 如果 j-i&gt;=2, 有至少一個字元長的內部子字串。
        // 如果 j-i=1, 兩個字，不一定是迴文。沒有內部子字串。
        for(int j=1; j &lt; s.length();j++) 
            for(int i=0; i &lt; j ; i++)
            {
                //j-i &lt;2 means current length doesnt have an inner string to check. true by default.
                //j-i=2 means there is one charater in between. it must be palindrome itself. true by default.
                boolean isInnerPalindrome = isPalindrome[i+1][j-1] || j-i &lt;=2;
                
                if(isInnerPalindrome &amp;&amp; s.charAt(i)==s.charAt(j) )
                {
                     isPalindrome[i][j] = true;
                    if(j-i &gt; right-left) // update current max length
                    {
                        right = j;
                        left = i;
                    }
                }
            }
        return s.substring(left,right+1);
    }
    // 最大長度迴文中點擴散搜尋法
    public String longestPalindrome_ExpandFromCenter(String s) {
        String max = &quot;&quot;;
        // 針對字串上的每個字為起始點，找出可能的最大迴文長度.
        for(int i=0;i&lt; s.length();i++)
        {
            String s1 = expandFromCenter(s, i, i); //針對單數長度迴文搜尋最大長度
            String s2 = expandFromCenter(s, i, i+1); //針對雙數長度迴文搜尋最大長度
            String curMax = (s1.length() &gt; s2.length()) ? s1:s2; //取當前較大長度字串
            max = (curMax.length() &gt; max.length()) ? curMax:max;//取全域最大長度字串            
        }
        
        return max;
    }
    // 以單中點或雙中點，左右雙指標搜尋迴文最大長度
    public String expandFromCenter(String s, int l, int r)
    {   // 找最大迴文長度
        while(l&gt;=0 &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r))
        { // 在整個字串區間範圍內，當前位置字相等，擴大搜尋範圍。直到當前位置字不相等.
            l--; r++; 
        }
        // 計算當前最大長度，當前左右值是排除值，需要各往中點走一步才是正確的值。
        int len = ((r-1)-(l+1)); //單中點原點長度是0，雙中點原點長度是-1.        
        return s.substring(l+1, r); // 傳回當前最大長度字串, 原點位置時，傳回空字串,零長度。
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_25"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_26" name="code_26" class="center">
<a class=".title">K Closet Pointsto Origin</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_26">
<code class="language-java">
import java.util.Arrays;
/*  @@DESCRIPTION
K Close Potins to Origin. 離原點最近的K個點.
*/
class KClosetPointstoOrigin   {

    public int[][] KClosetPoints_Sort(int[][] points, int K) { // 用距離公式及排序       
        Arrays.sort(points, (p1, p2) -&gt; (p1[0]*p1[0] +p1[1]*p1[1]) - (p2[0]*p2[0] +p2[1]*p2[1]) );
        // int[][] temp = new int[K];
        // for(int i=0;i&lt;K;i++) temp[i]=points[i];
        // return temp;
        return Arrays.copyOfRange(points, 0, K); // 只要前K最近的點
    }

    public int[][] KClosetPoints_PQ(int[][] points, int K) {
        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;int[]&gt;(  
            (p1, p2) -&gt; (p2[0]*p2[0] +p2[1]*p2[1]) - (p1[0]*p1[0] +p1[1]*p1[1])  );
        // 用最大堆積的N*Log(K)技巧取最小K個. 最大堆積，取資料時，是由大到小的順序取出.

        //N*lok(K) 技巧，只要留排序好後，後面K個值. 
        // 最大堆積就得到最小k個值.最小堆積就得到最大k個值.
        for(int[] p:points) 
        {
            pq.offer(p);
            if(pq.size() &gt; K)  pq.poll();
        }
        // 留下的K個就是最小的K個，但最大堆積的存放順序是大到小的順序，需要反轉才是由小到大的順序。
        int[][] res = new int[K][2]; // 分配一組 K個座標大小的陣列
        while(K &gt; 0) res[--K] = pq.poll(); // 反轉存入陣列
        return res; //傳回前K最近的點
    }
    //快速排序法改成O(N)快速排選法: 原理，先分割分組排序，然後用分割中點索引值判斷，
    public int[][] KClosetPoints_QSelect(int[][] points, int K) {
        int len =  points.length, l = 0, r = len - 1;
        while (l &lt;= r) {
            int mid = partition(points, l, r);
//當前分割中點就是第k位,由於是零基底陣列，K左邊值的就是沒排序好的正確答案。            
            if (mid == K) break; 
            if (mid &lt; K) {
                l = mid + 1; //快選右邊，縮左邊邊界.
            } else {
                r = mid - 1; // 快選左邊，縮右邊邊界.
            }
        }
        // 傳回答案，答案不是ascending order.
        return Arrays.copyOfRange(points, 0, K);
    }
    //分割分組排序法:這裡使用最左值為軸值
    private int partition(int[][] arr, int l, int r) {
        int[] pivot = arr[l];// (swap code part 1) 以左邊值為分割值，暫存分割值

        while (l &lt; r) { // 在當前分割分組區間,而且l跟r不能相撞.
            // 右方陣列值大於分割值是合理的，繼續直到找出小於分割值的右陣列值。
            // 找不到時，r 最終等於l就停止.
            while (l &lt; r &amp;&amp; compare(arr[r], pivot) &gt;= 0) r--; 
            arr[l] = arr[r]; // (swap code part 2) 該值換到arr[l]位置 
            // 左方陣列值(非軸值)大於分割值是合理的，繼續直到找出大於分割值的右陣列值。
            // 找不到時，l 最終等於r就停止.
            while (l &lt; r &amp;&amp; compare(arr[l], pivot) &lt;= 0) l++;
            arr[r] = arr[l]; // (swap code part 3)
        } //若原陣列該區間已排序好，最後則換回來.

        arr[l] = pivot;//(swap code part 4) 當前l就是原始軸值應該在的位置
        return l;
    }
    
    private int compare(int[] p1, int[] p2) { // 排序的方式: 照距離由大至小
        return p1[0] * p1[0] + p1[1] * p1[1] - p2[0] * p2[0] - p2[1] * p2[1];
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_26"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_27" name="code_27" class="center">
<a class=".title">Java Collections</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_27">
<code class="language-java">
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.Collection;
import java.util.Collections;
import java.util.PriorityQueue;
import java.util.Queue;

import java.util.Iterator;


public class JavaCollections , IImportTechnique  {
    public void performTest()
    {
        System.out.println(&quot;Priorty Queue:&quot;);
        PriorityQueue&lt;Integer&gt; pq=new PriorityQueue&lt;&gt;(); // 預設的PQ是最小值堆積(Min Heap)，小排到大，意味著小值先出.
        int[] points = new int[] { 1,10,3,6,5,8,7,4,9,2}; int K = 3;

        for(int pValue: points) { pq.offer(pValue); } //存入最小值堆積，讓堆積自已排.

        // 印出堆積的內容，這方法只印出內部陣列的順序，不是最堆積的順序.
        for(Integer p: pq) { System.out.print(p+ &quot; &quot;); } System.out.println();        

        Iterator itr = pq.iterator();          // 用代器，同上.
        while (itr.hasNext()) { System.out.print(itr.next()+ &quot; &quot;);  } System.out.println();
        // 印出照堆積順序排列的值.
        while(pq.size() &gt; 0) { System.out.print(pq.poll()+ &quot; &quot;); } System.out.println();

        // 最大堆積，revereOrder只適用 primitive type.
        Queue&lt;Integer&gt; pq2=new PriorityQueue&lt;&gt;(Collections.reverseOrder()); 
        
        for(int pValue: points) { pq2.offer(pValue); } //存入最大值堆積，讓堆積自已排.
        // 照堆積順序列印結果.
        while(pq2.size() &gt; 0) { System.out.print(pq2.poll()+ &quot; &quot;); } System.out.println();
   
        // 使用最大堆積取得最小K個數的 N*log(K) time complexity 技巧.
        // 最大堆積，由小排到大. 邊加入值， 堆積大於K個，就提出最大值.。最後最小的K個
        for(int pValue: points) 
        {
            pq2.offer(pValue); //邊加入值
            if(pq2.size() &gt; K)  pq2.poll(); // 堆積大於K個，就提出最大值.
        }

        // 照堆積順序列印結果.        
        while(!pq2.isEmpty()) { System.out.print(pq2.poll() + &quot; &quot;); } System.out.println();
    
        // add() vs offer(), remove() vs poll(), element() vs peek().
        // add() from Collection can't return false and throw an exception if an element cannot be added.
        // offer() from Queue returns false if an element cannot be added.
        // when the queue is empty, element() and remove() from Collection throws NoSuchElementException, while poll() &amp; peek() return null.
        /*
           add Throws:
            IllegalStateException - if the element cannot be added at this time due to capacity restrictions
            ClassCastException - if the class of the specified element prevents it from being added to this queue.
                for example, adding another type of object into a non-generic ArrayList.
            NullPointerException - if the specified element is null and this queue does not permit null elements
            IllegalArgumentException - if some property of this element prevents it from being added to this queue
        */

        System.out.println(&quot;HashMap:&quot;);

        HashMap&lt;Integer, String&gt; m = new HashMap&lt;&gt;();
        m.put(11, &quot;AB&quot;);
        m.put(2, &quot;CD&quot;);
        m.put(33, &quot;EF&quot;);
        m.put(9, &quot;GH&quot;);
        m.put(3, &quot;IJ&quot;);    

        for(Map.Entry e: m.entrySet() ) { System.out.print(&quot;{&quot; + e.getKey() + &quot;=&gt;&quot; + e.getValue() + &quot;},&quot;); }  System.out.println();

        HashMap&lt;Integer,String&gt; m2 = (HashMap)m.clone();
        
        for(Map.Entry&lt;Integer,String&gt; e: m2.entrySet() ) { System.out.print(&quot;{&quot; + e.getKey() + &quot;=&gt;&quot; + e.getValue() + &quot;},&quot;); } System.out.println();   
        m2.clear();
        m2.putAll(m);        Iterator mItr = m2.entrySet().iterator();
        while(mItr.hasNext()) { Map.Entry e = (Map.Entry)mItr.next(); System.out.print(&quot;{&quot; + e.getKey() + &quot;=&gt;&quot; + e.getValue() + &quot;},&quot;); } System.out.println();

        /*  HashSet &amp; HashMap doesn't maintain any kind of order of its elements.
            LinkedHashSet &amp; LinkedHashMap maintains insertion order.
            TreeSet &amp; TreeMap sort the entries in ascending order of keys and they don't allow null key and throw NullPointerException.
            Set -&gt; contains
            Map -&gt; containsKey, containsValue
        */        

        Set&lt;Integer&gt; set = m2.keySet();
        Iterator&lt;Integer&gt; ite2 = set.iterator();
        while(ite2.hasNext()) { System.out.print(ite2.next() + &quot;,&quot;); } System.out.println();

        Collection&lt;String&gt; values = m2.values();
        for(String s: values) { System.out.print(s + &quot;,&quot;); } System.out.println();
        Iterator&lt;String&gt; ite3 = values.iterator();
        while(ite3.hasNext()) { System.out.print(ite3.next() + &quot;,&quot;); } System.out.println();

        System.out.println(&quot;hello&quot;);

    }
    
    public String toString() { 
        return &quot;Mastering JavaCollectionsn [https://beginnersbook.com/2013/12/how-to-loop-hashmap-in-java/]&quot;;
    }
}

/*

- Use Comparator when you need more flexibilit
** The compareTo() method will return a positive number if one object is greater than the other, negative if it&rsquo;s lower, and zero if they are the same.

import java.util.Comparator;

public class MyComparator implements Comparator&lt;String&gt;
{
   @Override // ascending order based on String length
   public int compare(String x, String y) { return x.length() - y.length();}
}

or you can replace everything before Comparator using new keyword as below.

Collections.sort(strArr, new Comparator&lt;String&gt;
{
   @Override // ascending order based on String length
   public int compare(String x, String y) { return x.length() - y.length();}
});

Using Comparator with lambda expressions as below:
Collections.sort(strArr, (x, y) -&gt; x.length() - y.length()  );

You always use compareTo for a String/object.
Collections.sort(strArr, (s1, s2) -&gt; s1.compareTo(s2));

even shorter with
Collections.sort(strArr, Comparator.naturalOrder() );

    // ascending order means to arrange values from smallest to largest.
    // descending order means to arrange values from largest to smallest.

    // ascending order based on value
    public int compare(Integer x, Integer y) { return x - y;}
    // descending order based on value
    public int compare(Integer x, Integer y) { return y - x;}

    // sort by id in ascending order. when ids are the same, sort by their name in alphabetic order.
    public int compare(User x, User y) { return x.id == y.id ? x.name.compareTo(y)  : x.id-y.id  ;}
    (x,y) -&gt; x.id==y.id ? x.name.compareTo(y) : x.id-y.id;

    // sort by map value in ascending order. When map value are the same, sort by the name in alphabetic order.
    public int compare(String s1, String s2) { return count.get(s1) == count.get(s2) ? s1.compareTo(s2)  : count.get(s1)-count.get(s2); }
    (s1,s2) -&gt; count.get(s1)==count.get(s2) ? s1.compareTo(s2) : count.get(s1)-count.get(s2);

    Sorting a Map with TreeMap
    Map&lt;String, Integer&gt; m  = new TreeMap&lt;&gt;();
    m.put(&quot;DEF&quot;, 10);
    m.put(&quot;ABC&quot;, 20);
    System.out.println(m);

    Sorting a Set with TreeSet
    Set&lt;String&gt; s  = new TreeSet&lt;&gt;();
    s.put(&quot;DEF&quot;);
    s.put(&quot;ABC&quot;);
    System.out.println(m);
*/
</code>
</pre>
</div>

<template id="my-label-button-code_27"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_28" name="code_28" class="center">
<a class=".title">Generate Parentheses</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_28">
<code class="language-java">
import java.util.List;
/*  @@DESCRIPTION
generate parenthesis. 產生有效的雙括號.
*/

class GenerateParentheses  {
    
    public List&lt;String&gt; generateParentheses(int n) {
        List&lt;String&gt; res = new ArrayList&lt;&gt;();
        dfs(&quot;&quot;, n, n, res);   
        return res;
    }
    
    public void dfs(String s, int left, int right, List&lt;String&gt; res)
    {
        if(left &gt; right) return; // 左括號的數量不能小於右括號，否則不是有效雙括號.
        if(left &lt;0 || right &lt; 0) return; //超過所要求的括號數量
        if(left==0 &amp;&amp; right==0) res.add(s); // 剛好是題目要求的雙括號數量
        
        dfs(s+&quot;(&quot;, left-1, right, res); //如果下一個是左括號的狀態分支
        dfs(s+&quot;)&quot;, left, right-1, res); //如果下一個是右括號的狀態分支
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_28"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_29" name="code_29" class="center">
<a class=".title">Find Unique Pairs With Given Sum</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_29">
<code class="language-java">

/*  @@DESCRIPTION
Amazon 題: 最大值的兩數之和. 但陣列中的數字是可以重覆的
找出一組陣列中總和為90的兩數. 如果有超過一組兩數，傳回有單個最大值的那組.  同一元素不可從覆使用.
*/
public class FindUniquePairsWithGivenSum 
{
    public List&lt;List&lt;Integer&gt;&gt; findUniquePairsWithGivenSum(int[] nums, int target)
    {  //存對應數查照表，陣列上的各數可能是另一數的對應數。一陣列可以多個同一數字元素。
        Map&lt;Integer, List&lt;Integer&gt;&gt; pos = new HashMap&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        for(int i=0;i&lt;nums.length;i++) 
        { 
            List&lt;Integer&gt; ls = pos.get(target-nums[i]); // 查是否對應的數存在

            if(ls!= null &amp;&amp; ls.size() &gt; 0) //在當前數之前，有相對應的數存在
            {  // to DO. get rid of duplication.
                    int x = nums[i];  // 取得當前數
                    int y = nums[ls.get(0)]; // 取得相對應數
                    int left = x &gt; y ? x:y; // 較大值在左
                    int right = x &gt; y ? y:x; // 較小值在右
                    res.add(Arrays.asList(left, right)); //左大右小的答案格式
                    ls.remove(0); // 清除當前符合條件，不需要再使用.
            }
            else
            {   //如果對應的數不存在，記錄當前數，並存下索引位置.
                pos.put(nums[i], pos.getOrDefault(nums[i], new ArrayList&lt;Integer&gt;()) );
                pos.get(nums[i]).add(i); // 由於陣列內的整數可以重覆出現，用ArrayList存每個位置.
            }
        }

        return res;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_29"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_30" name="code_30" class="center">
<a class=".title">Find Pair With Given Sum</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_30">
<code class="language-java">

/*  @@DESCRIPTION
Amazon 題:多組的兩數之和.
找出一組陣列中總和為90的兩數. 如果有超過一組兩數，傳回每一組. 同一元素不可從覆使用.
*/
public class FindPairWithGivenSum 
{
    public List&lt;List&lt;Integer&gt;&gt; findPairWithGivenSum(int[] nums, int target)
    {   //存對應數查照表，陣列上的各數可能是另一數的對應數。一陣列可以多個同一數字元素。
        Map&lt;Integer, List&lt;Integer&gt;&gt; pos = new HashMap&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        int max = Integer.MIN_VALUE;

        for(int i=0;i&lt;nums.length;i++) 
        { 
            List&lt;Integer&gt; ls = pos.get(target-nums[i]);// 查是否對應的數存在

            if(ls!= null &amp;&amp; ls.size() &gt; 0) //在當前數之前，有相對應的數存在
            {
                    int idx1 = ls.get(0); // 在對照表裡的數是在當前數之前存的，索引值肯定較小。                   
                    int idx2 = i; // 當前索引值
                    int curMax = Math.max(nums[idx1],nums[idx2]); // 兩者取較大數值

                    ls.remove(0); // 清除當前符合條件，不需要再使用.
                    
                    if(curMax &gt; max) // 如果該值是全局最大值, 這就是答案.
                    { 
                        max = curMax;
                        res.clear(); // 只要全局最大值答案，清除之前的已經不符合的答案.
                        res.add(Arrays.asList(idx1,idx2)); //答案格式必需照索引值大小排.
                    }

            }
            else
            {  //如果對應的數不存在，記錄當前數，並存下索引位置.
                pos.put(nums[i], pos.getOrDefault(nums[i], new ArrayList&lt;Integer&gt;()) );
                pos.get(nums[i]).add(i); // 由於陣列內的整數可以重覆出現，用ArrayList存每個位置.
            }
        }

        return res;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_30"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_31" name="code_31" class="center">
<a class=".title">Find N Unique Integers Sum Up To Zero</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_31">
<code class="language-java">
import java.util.*;
class FindNUniqueIntegersSumUpToZero  {
    // 給一個陣列的長度，找出讓此陣列所有整數元素總和為零的整數值
    public int[] sumZero(int n) {
        
        int half = n/2; // 將陣列砍半，自己來設值
        int[] arr = new int[n];
        for(int i=0;i&lt; half;i++)
        {
            arr[i]=-(n-i); // 左半是負值
            arr[n-i-1]= (n-i); // 右半是正值，全部相加為零。
        }
                    
        return arr;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_31"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_32" name="code_32" class="center">
<a class=".title">Favorite Genres</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_32">
<code class="language-java">

/*  @@DESCRIPTION
Amazon 題:最喜愛的歌曲風格.
給一堆歌手歌曲名單. 也給你告訴每個歌曲的風格. 請輸出每個人的歌曲風格.
*/

class FavoriteGenres 
{
    public Map&lt;String, List&lt;String&gt;&gt; favoriteGenres(Map&lt;String, List&lt;String&gt;&gt; userSongs,//歌手歌曲名單 
    Map&lt;String, List&lt;String&gt;&gt; songGenres) // 風格對歌曲名對照表
    {
        Map&lt;String, Integer&gt; genreCount = new HashMap&lt;&gt;(); //某種歌曲風格的數量
        Map&lt;String, String&gt; song2Genre = new HashMap&lt;&gt;(); // 歌曲名對風格對照表
        Map&lt;String, List&lt;String&gt;&gt; m = new HashMap&lt;&gt;();  //  使用者名字及其風格.
        
        //將 [風格對歌曲名對照表] 轉換成 [歌曲名對風格對照表]
        //鍵值及對映值本身不可以有重覆值才能如此做.
        for(Map.Entry&lt;String, List&lt;String&gt;&gt; e : songGenres.entrySet())
        {
            // 取出每個風格相對應的歌曲清單
            for(String song: e.getValue())
            {
                song2Genre.put(song, e.getKey()); //將此風格的歌曲變成鍵值
            }
        }
         
        System.out.println(song2Genre);

        for(Map.Entry&lt;String, List&lt;String&gt;&gt; e : userSongs.entrySet())
        {  
            List&lt;String&gt; songs = e.getValue(); //取出每個人相對應的喜愛歌曲清單
            String singer = e.getKey(); // 歌手名
            genreCount.clear(); // 該歌手歌曲風格數量

            //預設值應該是不在比較範圍值內的最小值,才不影嚮求最大值計算結果。
             int max = Integer.MIN_VALUE;
            for(String song: songs) // 用該歌手的歌曲計算該歌手歌曲風格數量
            {
                String genre = song2Genre.get(song);
                genreCount.put(genre, genreCount.getOrDefault(genre,0) +1 );
                // 計算該風格的歌曲數量是否是最多歌的風格. 查是否該風格是該歌手的最常唱的風格
                max = Math.max( max, genreCount.get(genre)); //也可用PrioryQueue, 但慢而且沒必要.
            }

            // 由於只需要該歌手唱最多的風格，查最大值即可.
            for(Map.Entry&lt;String,Integer&gt; gc: genreCount.entrySet())
            {
                if(max==gc.getValue()) 
                {// 開始存入該歌手最常唱的風格，如果有一個以上風格的歌曲數量一樣，也等於該歌手風格.
                    m.put(singer, m.getOrDefault(singer, new ArrayList&lt;String&gt;()));
                    m.get(singer).add(gc.getKey());
                }
            }

        }

        return m;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_32"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_33" name="code_33" class="center">
<a class=".title">Critical Routers Or Connections</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_33">
<code class="language-java">

import java.util.ArrayList;
import java.util.List;
import java.util.HashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;



public class CriticalRoutersOrConnections  
{   // 找出圖上關節點的程式
    class Graph&lt;T&gt;
    {
        private Map&lt;T, List&lt;T&gt;&gt; adjList = new HashMap&lt;&gt;();
        private int time = 0;

        public void addEdges(T[][] edges)
        {
            for(int i=0;i&lt;edges.length;i++)
            {   // 將二維陣列的值，轉成無向圖的雙向節點
                addEdge(edges[i][0], edges[i][1]);
            }
        }

        public void clear()
        {
            adjList.clear();
        }

        public void addEdge(T u, T v)
        {
            addEdge(u, v, true); // 建立無向圖(雙向圖)
        }

        public void addEdge(T u, T v, boolean biDir)
        {
            adjList.put(u, adjList.getOrDefault(u, new ArrayList&lt;T&gt;())); 
            adjList.get(u).add(v);
            if(biDir)
            {   //空值就先建立強型ArrayList，然後存值
                adjList.put(v, adjList.getOrDefault(v, new ArrayList&lt;T&gt;()));
                adjList.get(v).add(u);
            }
        }        

        public void findCutPoints(T node, Map&lt;T, Boolean&gt; visited, Map&lt;T, T&gt; parent,  Map&lt;T, Integer&gt; disc, Map&lt;T, Integer&gt; low, Set&lt;T&gt; ap, Map&lt;T, List&lt;T&gt;&gt; bridges)
        {
            int children = 0;
            visited.put(node, true);
            time++;
            disc.put(node, time);
            low.put(node, time);
                        
            for(T adjNode: adjList.get(node)) //遍歷鄰接節點
            {
                if(visited.get(adjNode)==false) // 若未訪問該鄰接節點
                {
                    children++; //計算當前主節點有多少孩節點
                    parent.put(adjNode,node); //當前鄰接節點的父親是當前主節點
                    findCutPoints(adjNode, visited, parent, disc, low, ap, bridges);
                    low.put(node, Math.min(low.get(node), low.get(adjNode) ) );
                    
                    // this piece of code is to determine cut points
                    if(ap!=null)
                    {
                        if(parent.get(node)==null &amp;&amp; children &gt; 1) ap.add(node);
                        if(parent.get(node) != null &amp;&amp; low.get(adjNode) &gt;= disc.get(node)) // &gt; for bridges, &gt;= for points
                            ap.add(node);
                    }

                    // this piece of code is to determine. &gt; for bridges, &gt;= for points
                    if(bridges != null)
                    {
                        if(low.get(adjNode) &gt; disc.get(node)) {
                            bridges.put(node, bridges.getOrDefault(node, new ArrayList&lt;T&gt;()) );
                            bridges.get(node).add(adjNode);
                        }
                    }

                }
                else if(visited.get(adjNode)== true &amp;&amp; adjNode != parent.get(node) )
                {
                    low.put(node, Math.min(low.get(node), disc.get(adjNode) ) );
                }

            }
        }

        public Set&lt;T&gt; findCutPoints()
        {
            Map&lt;T, Boolean&gt; visited = new HashMap&lt;&gt;();
            Map&lt;T, T&gt; parent= new HashMap&lt;&gt;();  //每個節點的父鄰節節點,就是第一個訪問此點的節點.
            Map&lt;T, Integer&gt; low= new HashMap&lt;&gt;();
            Map&lt;T, Integer&gt; disc= new HashMap&lt;&gt;(); //存每個節點是第幾個被訪問的?
            Set&lt;T&gt; ap = new HashSet&lt;T&gt;();
            time = 0;// 共有多少節點被訪問，0可代表該節點是第一個被訪問的.
            for(T node: adjList.keySet()) //為每節點預設
            {
                visited.put(node, false); // 設成從未訪問過
                parent.put(node, null); // root by deafult，自已是自己父親.
                low.put(node, 0);  
                disc.put(node, 0); // 該節點是第幾個被訪問?這是未知的。
            }
    
            for(T node: adjList.keySet())
            {
                if(visited.get(node)==false)
                findCutPoints(node, visited, parent, disc, low, ap, null);
            }

            return ap;
        }

        public Map&lt;T, List&lt;T&gt;&gt; findBridges()
        {
            Map&lt;T, Boolean&gt; visited = new HashMap&lt;&gt;();
            Map&lt;T, T&gt; parent= new HashMap&lt;&gt;();
            Map&lt;T, Integer&gt; low= new HashMap&lt;&gt;();
            Map&lt;T, Integer&gt; disc= new HashMap&lt;&gt;();
            Map&lt;T, List&lt;T&gt;&gt; bridges = new HashMap&lt;&gt;();

            time = 0;

            for(T node: adjList.keySet())
            {
                visited.put(node, false);
                parent.put(node, null); // root by deafult
                low.put(node, 0);
                disc.put(node, 0);
            }
    
            for(T node: adjList.keySet())
            {
                if(visited.get(node)==false)
                findCutPoints(node, visited, parent, disc, low, null, bridges);
            }

            return bridges;
        }
    }

    public void performTest()
    {
        Graph&lt;Integer&gt;  g = new Graph&lt;&gt;();

        // https://leetcode.com/discuss/interview-question/436073/
        g.addEdges(new Integer[][] { {0, 1}, {0, 2}, {1, 3}, {2, 3}, {2, 5}, {5, 6}, {3, 4} });
        System.out.println(&quot;Cut Points :&quot; +  g.findCutPoints() );

        // https://leetcode.com/problems/critical-connections-in-a-network/
        g.clear();
        g.addEdges(new Integer[][] { {1, 2}, {1, 3}, {3, 4}, {1, 4}, {4, 5}} );
        System.out.println(&quot;Bridges (Cut Edges) :&quot; + g.findBridges() );
        g.clear();
        g.addEdges(new Integer[][] { {1, 2}, {1, 3}, {2, 3}, {2, 4}, {2, 5}, {4, 6}, {5, 6} } );
        System.out.println(&quot;Bridges (Cut Edges) :&quot; + g.findBridges() );
        g.clear();
        g.addEdges(new Integer[][] { {1, 2}, {1, 3}, {2, 3}, {3, 4}, {3, 6}, {4, 5}, {6, 7}, {6, 9}, {7, 8}, {8, 9} } );
        System.out.println(&quot;Bridges (Cut Edges) :&quot; + g.findBridges() );
    }

    public String toString() { return &quot;Critical Routers &amp; Connections, Articulation Points/Cut Point, Bridges/Cut Edges ([E]**):&quot;;}

}

</code>
</pre>
</div>

<template id="my-label-button-code_33"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_34" name="code_34" class="center">
<a class=".title">Copy Random Linked List</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_34">
<code class="language-java">
import java.util.HashMap;
/*  @@DESCRIPTION
Copy Random LinkedList. 拷貝帶有指向其它節點的鍊接表.
*/

public class CopyRandomLinkedList   {
    public Node copyRandomListWithDummyNode(Node head)   {
        if(head==null) return null;        
        HashMap&lt;Node, Node&gt; m = new HashMap&lt;Node, Node&gt;(); // 舊鍊表指標對映到新鍊表指標
        Node dummy = new Node(0); // 使用dummy，簡化程式碼
        
        // 迴圈遍歷整個舊鍊表, 同時建立新指標及遍歷新鍊表
        for(Node cur = head, temp = dummy; cur!=null; cur=cur.next, temp=temp.next)
        { 
            temp.next = new Node(cur.val); // 建立新指鏢
            m.put(cur, temp.next); 
        }
                
        // 迴圈遍歷整個舊新鍊表，將舊鍊表指鏢對映的位置存入新鍊表的random指鏢
        for(Node cur = head, temp = dummy.next; cur!=null; cur=cur.next, temp=temp.next)
        {
            if(cur.random!=null) temp.random = m.get(cur.random); //存對應的random
        }
        
        return dummy.next; // 傳回新鍊表的頭
    }

    public Node copyRandomListWithoutDummyNode(Node head)   {
        if(head==null) return null;        
        HashMap&lt;Node, Node&gt; m = new HashMap&lt;Node, Node&gt;();

        // 遍歷整個已有鍊表，直接存舊鍊表指標對映到新鍊表指標
        for(Node cur = head; cur!=null; cur=cur.next)
        {
            m.put(cur, new Node(cur.val));// 存新建立的指標
        }

        // 再遍歷整個已有鍊表，直接取出新鍊表指標，然後同時設定對應的next及random.  
        for(Node cur = head; cur!=null; cur=cur.next)
        {
            m.get(cur).next = m.get(cur.next); //存對應的next
            m.get(cur).random = m.get(cur.random);//存對應的random
        }

        return m.get(head);
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_34"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_35" name="code_35" class="center">
<a class=".title">Category Counter</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_35">
<code class="language-java">
import java.util.Map;
// 種類計數器,計算同物件及不同物件種類數
// 如三隻狗，五隻鳥，十隻馬，九隻猴。共有四種動物。
// 如三個4,五個6,七個8。共有三種數字。
// 如三個a,六個d,九個f，十個k。共有四種字母。
// 形狀，面積大小，體積，等等任何可以自已分門別類的都可用類似種類計數器的方式。
class CategoryCounter&lt;E&gt; 
{
    Map&lt;E,Integer&gt; m = new HashMap&lt;&gt;();
    int kinds = 0; 
    
    public CategoryCounter() {}
    
    public void add(E x)
    {
        m.put(x, m.getOrDefault(x,0)+1); // x 種類的物品多了一個。
        if(m.get(x)==1) kinds++;// 如果此種類的物品剛有了一個，代表多了一個品種。
    }
    
    public void remove(E x)
    {
        m.put(x, m.get(x)-1); // 少一個這種類
        if(m.get(x)==0) kinds--;// 如果此種類的物品變回零個，代表這品種已經沒了。
    }
    
    public int kinds() { return kinds; }
}

</code>
</pre>
</div>

<template id="my-label-button-code_35"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_36" name="code_36" class="center">
<a class=".title">Binary Search</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_36">
<code class="language-java">
public class BinarySearch , IImportTechnique 
{
    // 傳回所找元素的位置，找不到，則傳回該元素該被插入的位置(insertion position)
    // lowerBound(低值邊界，左邊界): true -&gt; 有重覆元素時，傳回重覆元素的左邊界或靠低值的邊界
    // lowerBound(低值邊界，左邊界): false-&gt; 有重覆元素時，傳回重覆元素的右邊界或靠右值的邊界
    // 將負插入位置轉成正值後減一就是，該元素該被插入的位置.
    public int binarySearch(int[] arr, int key, boolean lowerBound)
    {  // 傳入的陣列必須是要排序好,才能Binar Search.
        int left = 0; int right = arr.length - 1; // 設定雙指標遍歷區間範圍
        int lastKeyPos = -1;//最後一個找到的鍵值位置， -1為沒找到鍵值.

        while(left &lt;= right) //陣列只有一個元素時，left==right時，也得執行.
        {
            int mid = left+(right-left) / 2; //免integer overflow的寫法
            int cur  = arr[mid];

            if(key &gt; cur) left = mid+1; //要找的值大於當前中點值，往右找，縮左邊邊界.
            else if(key &lt; cur) right = mid-1; //要找的值小於當前中點值，往左找，縮右邊邊界.
            else // key == cur // 找到了
            {
                lastKeyPos = mid; // 記錄當前位置

                if(lowerBound) right = mid-1; //如果是要找左邊界位置，縮右邊邊界,往左繼續找同一值。
                else left = mid+1; //如果是要找右邊界位置，縮左邊邊界,往右繼續找同一值。
            }
        
        }
        //鍵值找不到，就轉成該鍵值元素該被插入的位置. 不然，傳回找到鍵置的索引位置.
        return (lastKeyPos==-1) ? -(left+1) : lastKeyPos;
    }

    public void performTest()
    {
        int[] nums = new int[] { 1,2,2,2,2,3,3,3,4,4,6,6,6,7,8,9,10};
        

        System.out.print(&quot;Array: &quot;);
        for(int i=0;i &lt; nums.length; i++) System.out.print(String.format(&quot;[%2s]&quot;, nums[i]));
        System.out.println();

        System.out.print(&quot;Pos:   &quot;);
        for(int i=0;i &lt; nums.length; i++) System.out.print(String.format(&quot;{%2s}&quot;, i));
        System.out.println();

        System.out.println(&quot;\nLowerBound BinarySearch&quot;);
        for(int i=0;i &lt; 12; i++)
        {
            int insertPosition =  binarySearch(nums, i, true);
            System.out.println(&quot;key = &quot; + i + &quot; =&gt; &quot; + insertPosition);
        }

        System.out.println(&quot;\nUpperBound BinarySearch&quot;);
        for(int i=0;i &lt; 12; i++)
        {
            int insertPosition =  binarySearch(nums, i, false);
            System.out.println(&quot;key = &quot; + i + &quot; =&gt; &quot; + insertPosition);
        }

        System.out.println(&quot;Positive insert position = the actual found key position.&quot;);
        System.out.println(&quot;Negative insert postion (-insertPos -1) = the position of the least integer greater than key &quot;);
    }

    public String toString() { 
        return &quot;Binary Search []&quot;;
    }
}

</code>
</pre>
</div>

<template id="my-label-button-code_36"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>


  
	</body>
</html>
