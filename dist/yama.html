<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Atomic Habit</title>
    <link rel="stylesheet" type="text/css" href="prism.css" />
    <style>
      .center {
          margin: auto;
          width: 820px;
          border: 1px solid black;
          padding: 0 0 0 0;
          font-size: 11px;
          line-height: 14px;
        }

      .noscrollbar {
        overflow: hidden;
      }

      .token.number {
        color: lightblue;
      }

      
    </style>
		<script src="prism.js" type="text/javascript"></script>
		<script src="main.js" type="text/javascript"></script>

<script>


  </script>
	</head>
	<body>
	
  <!-- table of contents -->
	<ul>
    <li id="li_1" name="li_1" data-id=""><input type="checkbox" id="checkbox_1" name="checkbox_1" /><a href="#code_1">Window</a></li>
<li id="li_2" name="li_2" data-id=""><input type="checkbox" id="checkbox_2" name="checkbox_2" /><a href="#code_2">Union Find</a></li>
<li id="li_3" name="li_3" data-id=""><input type="checkbox" id="checkbox_3" name="checkbox_3" /><a href="#code_3">Treasure Island 2</a></li>
<li id="li_4" name="li_4" data-id=""><input type="checkbox" id="checkbox_4" name="checkbox_4" /><a href="#code_4">Treasure Island</a></li>
<li id="li_5" name="li_5" data-id=""><input type="checkbox" id="checkbox_5" name="checkbox_5" /><a href="#code_5">Top K Frequently Mentioned Keywords</a></li>
<li id="li_6" name="li_6" data-id=""><input type="checkbox" id="checkbox_6" name="checkbox_6" /><a href="#code_6">Sub Tree With Maximum Average</a></li>
<li id="li_7" name="li_7" data-id=""><input type="checkbox" id="checkbox_7" name="checkbox_7" /><a href="#code_7">Subtree Of Another Tree</a></li>
<li id="li_8" name="li_8" data-id=""><input type="checkbox" id="checkbox_8" name="checkbox_8" /><a href="#code_8">Substrings Of Size Kwith K Distinct Chars</a></li>
<li id="li_9" name="li_9" data-id=""><input type="checkbox" id="checkbox_9" name="checkbox_9" /><a href="#code_9">Substrings Of Exactly K Distinct Chars</a></li>
<li id="li_10" name="li_10" data-id=""><input type="checkbox" id="checkbox_10" name="checkbox_10" /><a href="#code_10">Subarrays With K Different Integers</a></li>
<li id="li_11" name="li_11" data-id=""><input type="checkbox" id="checkbox_11" name="checkbox_11" /><a href="#code_11">Search Suggestion System</a></li>
<li id="li_12" name="li_12" data-id=""><input type="checkbox" id="checkbox_12" name="checkbox_12" /><a href="#code_12">Search Matrix</a></li>
<li id="li_13" name="li_13" data-id=""><input type="checkbox" id="checkbox_13" name="checkbox_13" /><a href="#code_13">Rottin Oranges</a></li>
<li id="li_14" name="li_14" data-id=""><input type="checkbox" id="checkbox_14" name="checkbox_14" /><a href="#code_14">Reorder Data In Log File</a></li>
<li id="li_15" name="li_15" data-id=""><input type="checkbox" id="checkbox_15" name="checkbox_15" /><a href="#code_15">Prison Cells After N Days</a></li>
<li id="li_16" name="li_16" data-id=""><input type="checkbox" id="checkbox_16" name="checkbox_16" /><a href="#code_16">Partition Label</a></li>
<li id="li_17" name="li_17" data-id=""><input type="checkbox" id="checkbox_17" name="checkbox_17" /><a href="#code_17">Optimal Utilization</a></li>
<li id="li_18" name="li_18" data-id=""><input type="checkbox" id="checkbox_18" name="checkbox_18" /><a href="#code_18">Number Of Clusters</a></li>
<li id="li_19" name="li_19" data-id=""><input type="checkbox" id="checkbox_19" name="checkbox_19" /><a href="#code_19">Nth Geometric Progression</a></li>
<li id="li_20" name="li_20" data-id=""><input type="checkbox" id="checkbox_20" name="checkbox_20" /><a href="#code_20">Most Common Word</a></li>
<li id="li_21" name="li_21" data-id=""><input type="checkbox" id="checkbox_21" name="checkbox_21" /><a href="#code_21">Minimum Cost To Connect Rope</a></li>
<li id="li_22" name="li_22" data-id=""><input type="checkbox" id="checkbox_22" name="checkbox_22" /><a href="#code_22">Min Cost To Connect All Nodes Or Repair Edges</a></li>
<li id="li_23" name="li_23" data-id=""><input type="checkbox" id="checkbox_23" name="checkbox_23" /><a href="#code_23">Merge Two Sorted List</a></li>
<li id="li_24" name="li_24" data-id=""><input type="checkbox" id="checkbox_24" name="checkbox_24" /><a href="#code_24">Merge Intervals</a></li>
<li id="li_25" name="li_25" data-id=""><input type="checkbox" id="checkbox_25" name="checkbox_25" /><a href="#code_25">Longest String With Three Consecutive Characters</a></li>
<li id="li_26" name="li_26" data-id=""><input type="checkbox" id="checkbox_26" name="checkbox_26" /><a href="#code_26">Longest Plaindromic Substring</a></li>
<li id="li_27" name="li_27" data-id=""><input type="checkbox" id="checkbox_27" name="checkbox_27" /><a href="#code_27">K Closet Pointsto Origin</a></li>
<li id="li_28" name="li_28" data-id=""><input type="checkbox" id="checkbox_28" name="checkbox_28" /><a href="#code_28">Java Collections</a></li>
<li id="li_29" name="li_29" data-id=""><input type="checkbox" id="checkbox_29" name="checkbox_29" /><a href="#code_29">Generate Parentheses</a></li>
<li id="li_30" name="li_30" data-id=""><input type="checkbox" id="checkbox_30" name="checkbox_30" /><a href="#code_30">Find Unique Pairs With Given Sum</a></li>
<li id="li_31" name="li_31" data-id=""><input type="checkbox" id="checkbox_31" name="checkbox_31" /><a href="#code_31">Find Pair With Given Sum</a></li>
<li id="li_32" name="li_32" data-id=""><input type="checkbox" id="checkbox_32" name="checkbox_32" /><a href="#code_32">Find N Unique Integers Sum Up To Zero</a></li>
<li id="li_33" name="li_33" data-id=""><input type="checkbox" id="checkbox_33" name="checkbox_33" /><a href="#code_33">Favorite Genres</a></li>
<li id="li_34" name="li_34" data-id=""><input type="checkbox" id="checkbox_34" name="checkbox_34" /><a href="#code_34">Critical Routers Or Connections</a></li>
<li id="li_35" name="li_35" data-id=""><input type="checkbox" id="checkbox_35" name="checkbox_35" /><a href="#code_35">Copy Random Linked List</a></li>
<li id="li_36" name="li_36" data-id=""><input type="checkbox" id="checkbox_36" name="checkbox_36" /><a href="#code_36">Binary Search</a></li>

  </ul>
  
  
<div id="code_1" name="code_1" class="center">
<a class=".title">Window</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_1">
<code class="language-java">
import java.util.Map;
//記錄某物品(數字，字元，字串或物件，事件等等)出現的次數.也同時計算到底有多少種不同種類的物品(the number of type)
class Window&lt;E&gt;
{
    Map&lt;E,Integer&gt; m = new HashMap&lt;&gt;();
    int kinds = 0; // the total number of types available in the map
    
    public Window() {}
    
    public void add(E x)
    {
        m.put(x, m.getOrDefault(x,0)+1);
        if(m.get(x)==1) kinds++;
    }
    
    public void remove(E x)
    {
        m.put(x, m.get(x)-1);
        if(m.get(x)==0) kinds--;
    }
    
    public int kinds() { return kinds; }
}

</code>
</pre>
</div>

<template id="my-label-button-code_1"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_2" name="code_2" class="center">
<a class=".title">Union Find</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_2">
<code class="language-java">
// https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/unionfind-suan-fa-ying-yong

class UnionFind {
    // 记录连通分量个数
    private int count;
    // 存储若干棵树
    private int[] parent;
    // 记录树的&ldquo;重量&rdquo;
    private int[] size;

    public UF(int n) {
        this.count = n;
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i &lt; n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    /* 将 p 和 q 连通 */
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;

        // 小树接到大树下面，较平衡
        if (size[rootP] &gt; size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
    }

    /* 判断 p 和 q 是否互相连通 */
    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        // 处于同一棵树上的节点，相互连通
        return rootP == rootQ;
    }

    /* 返回节点 x 的根节点 */
    private int find(int x) {
        while (parent[x] != x) {
            // 进行路径压缩
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    public int count() {
        return count;
    }
}

public class Test
{
public boolean equationsPossible(String[] equations) {
    // 26 个英文字母
    UF uf = new UF(26);
    // 先让相等的字母形成连通分量
    for (String eq : equations) {
        if (eq.charAt(1) == '=') {
            char x = eq.charAt(0);
            char y = eq.charAt(3);
            uf.union(x - 'a', y - 'a');
        }
    }
    // 检查不等关系是否打破相等关系的连通性
    for (String eq : equations) {
        if (eq.charAt(1) == '!') {
            char x = eq.charAt(0);
            char y = eq.charAt(3);
            // 如果相等关系成立，就是逻辑冲突
            if (uf.connected(x - 'a', y - 'a'))
                return false;
        }
    }
    return true;
}

public  void solve(char[][] board) {
    if (board.length == 0) return;

    int m = board.length;
    int n = board[0].length;
    // 给 dummy 留一个额外位置
    UF uf = new UF(m * n + 1);
    int dummy = m * n;
    // 将首列和末列的 O 与 dummy 连通
    for (int i = 0; i &lt; m; i++) {
        if (board[i][0] == 'O')
            uf.union(i * n, dummy);
        if (board[i][n - 1] == 'O')
            uf.union(i * n + n - 1, dummy);
    }
    // 将首行和末行的 O 与 dummy 连通
    for (int j = 0; j &lt; n; j++) {
        if (board[0][j] == 'O')
            uf.union(j, dummy);
        if (board[m - 1][j] == 'O')
            uf.union(n * (m - 1) + j, dummy);
    }
    // 方向数组 d 是上下左右搜索的常用手法
    int[][] d = new int[][]{{1,0}, {0,1}, {0,-1}, {-1,0}};
    for (int i = 1; i &lt; m - 1; i++) 
        for (int j = 1; j &lt; n - 1; j++) 
            if (board[i][j] == 'O')
                // 将此 O 与上下左右的 O 连通
                for (int k = 0; k &lt; 4; k++) {
                    int x = i + d[k][0];
                    int y = j + d[k][1];
                    if (board[x][y] == 'O')
                        uf.union(x * n + y, i * n + j);
                }
    // 所有不和 dummy 连通的 O，都要被替换
    for (int i = 1; i &lt; m - 1; i++) 
        for (int j = 1; j &lt; n - 1; j++) 
            if (!uf.connected(dummy, i * n + j))
                board[i][j] = 'X';
}
    
public static void main(String[] args)
{
    
}
    
}

</code>
</pre>
</div>

<template id="my-label-button-code_2"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_3" name="code_3" class="center">
<a class=".title">Treasure Island 2</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_3">
<code class="language-java">
import java.util.LinkedList;
class TreasureIsland2 
{   //求從某起點至其中一個終點的最短步數
    public int minimumRoute(char[][] maze)
    {
        Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;();
        int[][] dir = new int[][] { {0,1}, {0,-1}, {1,0}, {-1,0} };

        for(int i=0;i&lt; maze.length;i++)
        {
            for(int j=0; j &lt; maze[0].length;j++)
            {
                if(maze[i][j]=='S')
                {
                    q.add(new int[] {j, i});
                }
            }
        }
        
        int count = 0;
        while(q.size() &gt; 0)
        {
            int size = q.size();

            for(int i=0;i&lt;size;i++)
            {
                int[] pos = q.poll();
                for(int k=0;k&lt;dir.length;k++)
                {
                    int nx = pos[0] + dir[k][0];
                    int ny = pos[1] + dir[k][1];
                    if(nx &lt;0 || nx &gt;= maze[0].length || ny &lt;0 || ny &gt;= maze.length) continue;

                    if(maze[ny][nx]=='O') 
                    {
                        maze[ny][nx] = 'D'; // visited
                        q.add(new int[] {nx, ny });
                    }
                    else if(maze[ny][nx]=='X')
                    {
                        return count; // found it
                    }
                }
            }
            count++;
        }

        return count;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_3"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_4" name="code_4" class="center">
<a class=".title">Treasure Island</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_4">
<code class="language-java">
import java.util.ArrayList;
class TreasureIsland 
{   //求並印出一起點至一終點的最短路徑
    public List&lt;int[]&gt; minimumRoute(char[][] maze)
    {
        Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;();
        int count = 0;
        int[][] dir = new int[][] { {0,1},{1,0},{ 0,-1},{-1,0}};
        q.offer(new int[]{0,0});
        maze[0][0]= (char)count++;

        while(q.size() &gt; 0)
        {
            int size = q.size();
            for(int i=0;i&lt;size;i++)
            {
                int[] pos = q.poll();
               // System.out.println(Arrays.toString(pos));
                for(int j=0;j&lt;dir.length;j++)
                {
                    int nx = pos[0] + dir[j][0];
                    int ny = pos[1] + dir[j][1];
                    if(nx &lt; 0 || nx &gt;= maze[0].length || ny &lt; 0 || ny &gt;= maze.length) continue;
                    if(maze[ny][nx]=='O') // only O is walkable
                    {
                        q.offer(new int[] {nx,ny});
                        maze[ny][nx]= (char)count;
                    }
                    else if(maze[ny][nx]=='X')
                    { // found the target
                        System.out.println(&quot;Steps: &quot; + (count));
                        List&lt;int[]&gt; res = createSolution(maze, pos[0], pos[1]);  
                        return res;
                    }
                }

            }
            count++;
        }

        return null;        
    }

    public List&lt;int[]&gt; createSolution(char[][] maze, int lastX, int lastY)
    {
        List&lt;int[]&gt; res = new ArrayList&lt;&gt;();
        Stack&lt;int[]&gt; s = new Stack&lt;&gt;();
        System.out.println(&quot;Creating the solution.&quot;);
        s.push(new int[] {lastX,lastY} );
        int count = (int)(maze[lastY][lastX]);
        count--;
        
        for(int i=0;i&lt;maze.length;i++)
        {
            for(int j=0;j&lt;maze[0].length;j++)
            {
                System.out.print(((char)(maze[i][j]+'0')) + &quot;|&quot;);
            }
            System.out.println();
        }

        while(count &gt;= 0)
        {
            int[][] dir = new int[][] { {0,1},{1,0},{ 0,-1},{-1,0}};
            for(int i=0;i&lt;dir.length;i++)
            {
                int nx = lastX + dir[i][0];
                int ny = lastY + dir[i][1];
                if(nx &lt; 0 || nx &gt;= maze[0].length || ny &lt; 0 || ny &gt;= maze.length) continue;
                if((int)maze[ny][nx]==count) 
                {
                    s.push(new int[] {nx, ny});
                    lastX = nx; lastY = ny;
                    count--;
                    break;
                }
            }
        }

        while(!s.isEmpty()) { res.add(s.pop()); };
        
        return res;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_4"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_5" name="code_5" class="center">
<a class=".title">Top K Frequently Mentioned Keywords</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_5">
<code class="language-java">

/* @@DESCRIPTION
692. TOP K Frequent words. 前K個最高頻字或元素.
給一堆可能從覆的關鍵字，一堆評價文章。找出前K個最高頻字.同頻字要依照字母順序排.
解法是將每個評價文轉成小寫並拆成字組存入HashSet排除從覆字.儲存每字出現字數到對照表。
依出現次數由大排到小. 取前K個。
更快的方法是，使用最小堆積優先佇列. 用K log(K)的方法，讓佇列只留下最高頻字數的前K個.
將佇列提出的順序反轉就是前K個.
*/

public class TopKFrequentlyMentionedKeywords 
{   // related problems:
    // https://leetcode.com/problems/top-k-frequent-words/
    // https://leetcode.com/problems/top-k-frequent-elements/
    // solution from 35 - 79 = about 45 lines
    public List&lt;String&gt; nlogn_Sort(Map&lt;String,Integer&gt; m, int k)
    {   // sort in a descending order based on word frequency from large to small.
        List&lt;String&gt; res = new ArrayList(m.keySet());
        Collections.sort(res, (w1, w2) -&gt; (m.get(w1) == m.get(w2) ? w1.compareTo(w2) : m.get(w2)-m.get(w1)) );
        return res;
    }

    public List&lt;String&gt; nlogk_Sort(Map&lt;String,Integer&gt; m, int k)
    {   
        // create a min heap to sort from small to large. add to sort. remove to get rid of smallest item.
        PriorityQueue&lt;String&gt; q = new PriorityQueue&lt;&gt;( (w1, w2) -&gt; (m.get(w1) == m.get(w2) ? w2.compareTo(w1) : m.get(w1)-m.get(w2)));
        // if you use max heap, you won't be able to lock insert/delete into log(k) time complexity as we did below.
        for (Map.Entry&lt;String, Integer&gt; entry : m.entrySet()) {
            q.offer(entry.getKey());
            if (q.size() &gt; k) { q.poll(); }  // ensure each insertion only uses log(k)       
        }
    
        //get all elements from the heap
        List&lt;String&gt; res = new ArrayList&lt;&gt;();        
        while (q.size() &gt; 0) {
            String w = q.poll();
            res.add(w);
        }    
        Collections.reverse(res); //reverse the order        
        return res;
    }

    public List&lt;String&gt; TopKFrequent(String[] keywords, String[] reviews, int k, boolean nlogksort )
    {
        Set&lt;String&gt; keywordSet = new HashSet&lt;&gt;(Arrays.asList(keywords)); // remove duplicates from keywrods
        Map&lt;String, Integer&gt; m = new HashMap&lt;&gt;();

        for(String r: reviews)
        {   // split based on non-character. characters:[a-zA-Z0-9_]
            String[] strs = r.split(&quot;\\W&quot;);
            Set&lt;String&gt; inReview = new HashSet&lt;&gt;(Arrays.asList(strs));
            for(String w:inReview)
            {  
                w = w.toLowerCase();  // comparision is CASE-INSENSITIVE
                if(keywordSet.contains(w))
                {
                    m.put(w, m.getOrDefault(w,0)+1);
                }
            }
        }

       List&lt;String&gt; res = nlogksort ? nlogk_Sort(m,k) : nlogn_Sort(m, k);
       return res.subList(0,k); // [0,K)
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_5"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_6" name="code_6" class="center">
<a class=".title">Sub Tree With Maximum Average</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_6">
<code class="language-java">

class SubTreeWithMaximumAverage 
{
    class RefValue
    {
        public NaryTreeNode maxNode;
    }
    public NaryTreeNode getMaxAverageSubTree(NaryTreeNode root)
    {
        RefValue maxSubTree = new RefValue();
        float[] res = getSumAndAverage(root, maxSubTree);
        return maxSubTree.maxNode;
    }

    public float[] getSumAndAverage(NaryTreeNode root, RefValue maxSubTree)
    {
        if(root==null) return new float[]{0,0, 0};
 
        float sum = root.val;
        float maxAverage = 0;
        float childCount = 0;
        if(root.nodes.size() &gt; 0)
        {
            for(NaryTreeNode child: root.nodes)
            {
                float[] res = getSumAndAverage(child, maxSubTree);     
                sum+= res[0];    
                childCount+=res[2];                      
                if(maxAverage &lt; res[1])
                {                 
                    System.out.print(maxAverage +  &quot; &lt; &quot; + res[1]); 
                    maxAverage = res[1];
                    maxSubTree.maxNode = child;
                    System.out.println(&quot; [&quot; + maxSubTree.maxNode.val +&quot;]&quot;);
                }
            }

            float average = sum / (childCount+1);
            if(maxAverage &lt; average)
            {                 
                System.out.print(maxAverage +  &quot; &lt; &quot; + average); 
                maxAverage = average;
                maxSubTree.maxNode = root;
                System.out.println(&quot; [&quot; + maxSubTree.maxNode.val +&quot;]&quot;);
            }
        }

        return new float[]{sum, maxAverage, childCount + 1};
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_6"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_7" name="code_7" class="center">
<a class=".title">Subtree Of Another Tree</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_7">
<code class="language-java">

class SubtreeOfAnotherTree 
{
    public boolean isSubtree(TreeNode s, TreeNode t) {        
        return traverse(s, t);
    }
    
    public boolean traverse(TreeNode s, TreeNode t)
    {
        return s!=null &amp;&amp; (
            sameStructure(s,t) ||
            traverse(s.left,t) ||
            traverse(s.right,t)
        );
    }
    
    public boolean sameStructure(TreeNode a, TreeNode b)
    {
        if(a==null &amp;&amp; b ==null) // touch bottom of the tree
            return true;
        
        if(a!=null &amp;&amp; b !=null &amp;&amp;
          a.val == b.val)
        {
            return sameStructure(a.left, b.left) &amp;&amp; sameStructure(a.right, b.right);
        }   
        
        return false;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_7"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_8" name="code_8" class="center">
<a class=".title">Substrings Of Size Kwith K Distinct Chars</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_8">
<code class="language-java">
import java.util.ArrayList;
class SubstringsOfSizeKwithKDistinctChars 
{
    public List&lt;String&gt; substringsOfSizeKwithKDistinctChars(String s, int k)
    {
        List&lt;String&gt; res = new ArrayList&lt;&gt;();
        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        int[] m = new int[256];

        for(int i=0, j = 0;i &lt; s.length() &amp;&amp; j &lt; s.length(); )
        {
            if(m[s.charAt(i)]==0)
            {
                m[s.charAt(i++)]++;

            }
            else 
            {
                m[s.charAt(j++)]--;
            }
            if(i-j==k) { 
                String sub = s.substring(j,i);
                // use both hashSet and list to remove duplicate and maintain the original order 
                if(!set.contains(sub)) { res.add(sub); }
                set.add(sub);
                m[s.charAt(j++)]--;
            }
            
        }
        return res;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_8"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_9" name="code_9" class="center">
<a class=".title">Substrings Of Exactly K Distinct Chars</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_9">
<code class="language-java">

class SubstringsOfExactlyKDistinctChars 
{

    public int substringswithExactlyKDistinctChars(String s, int K)
    {
        Window&lt;Character&gt; w1 = new Window&lt;Character&gt;();
        Window&lt;Character&gt; w2 = new Window&lt;Character&gt;();
        int count = 0, left1=0, left2 = 0;
        for(int i=0;i&lt;s.length();i++)
        {
            Character c = s.charAt(i);
            w1.add(c);
            w2.add(c);
            while(w1.kinds() &gt; K) w1.remove(s.charAt(left1++));
            while(w2.kinds() &gt;= K) w2.remove(s.charAt(left2++));
            count += left2-left1;
        }
        return count;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_9"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_10" name="code_10" class="center">
<a class=".title">Subarrays With K Different Integers</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_10">
<code class="language-java">
import java.util.*;
class SubarraysWithKDifferentIntegers 
{
    //Longest SubString With K Distinct Characters

    public int subarraysWithKDistinct(int[] A, int K) {        
        Window&lt;Integer&gt; w1 = new Window&lt;Integer&gt;();
        Window&lt;Integer&gt; w2 = new Window&lt;Integer&gt;();
        int left1=0, left2 =0;
        int count = 0;
        
        for(int i=0;i &lt; A.length;++i)
        {
            int x = A[i];
            w1.add(x);
            w2.add(x);
            
            while(w1.kinds() &gt; K )
                w1.remove(A[left1++]);
            
            while(w2.kinds() &gt;= K )
                w2.remove(A[left2++]);
            
            count+= left2-left1;            
        }
        
        return count;
    }

 }

</code>
</pre>
</div>

<template id="my-label-button-code_10"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_11" name="code_11" class="center">
<a class=".title">Search Suggestion System</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_11">
<code class="language-java">

/* @@DESCRIPTION
1268. Search Suggestion System 搜索推荐系統. 建議列表. 自動完成表.
在每次打入一個字母時，下拉選單會自動提示最接近當前輸入關鍵字字首的產品名稱.最多提示三個產品，並按照字母順序。
可用對應26個字母的字首樹資料結構來解決這題. 每個字首樹節點還得儲存當前字首對應的產品推荐表以方便快速查尋.
產品清單必須排序後，才存入字首樹中。
*/

public class SearchSuggestionSystem  {
    // System Design interview for auto suggestions: https://www.youtube.com/watch?v=xrYTjaK5QVM
    // https://leetcode.com/problems/search-suggestions-system
     class Trie {
     Trie[] sub = new Trie[26];
     List&lt;String&gt; suggestion = new LinkedList&lt;&gt;();
     }
 
     // autocomplete/typehead
     // suggest 3 items based on a searchWord currently typed.
     public List&lt;List&lt;String&gt;&gt; suggestedProducts(String[] products, String searchWord) {
         Arrays.sort(products);
         
         List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();
         Trie root = new Trie();
         for(String p: products) // pre-compute suggest list based on sorted order
         {
             Trie r = root;
             for(char c : p.toCharArray())
             {
                 if(r.sub[c-'a']==null) r.sub[c-'a'] = new Trie();
 
                 r = r.sub[c-'a'];
                 
                 if(r.suggestion.size() &lt; 3) r.suggestion.add(p);
             }
         }
         
         for(char c: searchWord.toCharArray())
         {
             if(root!=null) root = root.sub[c-'a'];
             res.add( (root==null) ? Arrays.asList() : root.suggestion);
         }
         
         return res;
     }
 
 }

</code>
</pre>
</div>

<template id="my-label-button-code_11"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_12" name="code_12" class="center">
<a class=".title">Search Matrix</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_12">
<code class="language-java">

public class SearchMatrix 
{
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix==null || matrix.length==0 || matrix[0].length==0 ) return false;
        int col = matrix[0].length-1;
        int row = 0;
        
        while(row &lt; matrix.length &amp;&amp; col &gt;= 0)
        {
            if(matrix[row][col]==target) return true;
            if(matrix[row][col] &lt; target) row++;
            else col--;
        }
        
        return false;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_12"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_13" name="code_13" class="center">
<a class=".title">Rottin Oranges</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_13">
<code class="language-java">
import java.util.LinkedList;
/* @@DESCRIPTION
994. Rotting Oranges 爛橙子
給一個九宮格或更大的宮格.裡面有相鄰的橙子，也可能有不相鄰的橙子或沒有橙子。
每一分鐘，爛橙子會弄爛四方相鄰新橙子. 算出爛橙子弄爛所有橙子所需時間。不可能全部弄爛就傳回負一.
解法是使用廣度優先搜索，將爛橙子座標當成起始佇列元素. 計算新橙子個數。 每一佇列迴圈周期，針對所有欄橙子的四方查是否有新橙子，有就弄爛放入佇列，個數減一. 
所需分鐘加一. 如果新橙子不為零，代表不可能全部弄爛.
 
*/

public class RottinOranges   {
    //https://leetcode.com/problems/rotting-oranges/
    // Zombie in Matrix: https://leetcode.com/discuss/interview-question/411357/
    // Minium hours to send file to all available servers
    public int orangesRotting(int[][] grid) {
        Queue&lt;Integer[]&gt; q = new LinkedList&lt;&gt;();
        int count =0;
        // push source noddes
        for(int i=0;i&lt;grid.length;i++)
            for(int j=0;j&lt;grid[0].length;j++)
            {
                if(grid[i][j]==2) q.offer(new Integer[] {i,j});
                if(grid[i][j]==1) count++;
            }
        
        if(count==0) return 0; // speicial case. no fresh orange at all from start.
        
        int[][] dir = new int[][]{{0,1},{1,0},{0,-1},{-1,0}};
        int time = -1;
        
        while(q.size() &gt; 0)
        {
            int size = q.size();            
            for(int i=0;i&lt;size;i++) // make sure to go through all nodes in current queue
            {
                Integer[] pos = q.poll(); // get position                        
                for(int j=0;j&lt;dir.length;j++) // get adjacents of adjcent node.
                {
                    int nx= pos[0] + dir[j][0];
                    int ny =pos[1] + dir[j][1];

                    if(nx &lt; 0 || ny &lt; 0 || nx &gt;= grid[0].length || ny &gt;= grid.length) continue;
                    
                    if(grid[ny][nx]==1) // push an adjecent neighor which is a fresh orange in this case
                    { // in scoope
                        count--;
                        grid[ny][nx] = 2; // rotten the tomato, mark as visited
                        q.offer(new Integer[]{ny,nx}); 
                    }
                }      
            }
            
            time++;
        }
        
        return (count==0) ? time:-1; //-1 also means it's not possible to rotten every orange.
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_13"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_14" name="code_14" class="center">
<a class=".title">Reorder Data In Log File</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_14">
<code class="language-java">

public class ReorderDataInLogFile 
{
    public String[] reorderLogFiles(String[] logs) {
        Arrays.sort(logs, (log1, log2) -&gt; {
            String[] split1 = log1.split(&quot; &quot;, 2);
            String[] split2 = log2.split(&quot; &quot;, 2);
            boolean isDigit1 = Character.isDigit(split1[1].charAt(0));
            boolean isDigit2 = Character.isDigit(split2[1].charAt(0));
            if (!isDigit1 &amp;&amp; !isDigit2) {
                int cmp = split1[1].compareTo(split2[1]);
                if (cmp != 0) return cmp;
                return split1[0].compareTo(split2[0]);
            }
            return isDigit1 ? (isDigit2 ? 0 : 1) : -1;
        });
        return logs;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_14"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_15" name="code_15" class="center">
<a class=".title">Prison Cells After N Days</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_15">
<code class="language-java">
import java.util.HashSet;
class PrisonCellsAfterNDays  {

    public int[] prisonAfterNDays(int[] cells, int N) {
        if(cells==null || cells.length == 0 || N &lt;= 0) return cells;
            Set&lt;String&gt; set = new HashSet&lt;&gt;();
            
            while(0 &lt; N)
            {
                int[] next = nextDayCell(cells);
                String curKey = Arrays.toString(next);
                
                if(set.contains(curKey))
                {                
                    N%=set.size();
                    while(0 &lt; N--) cells  = nextDayCell(cells);
                    
                    return cells;
                }
                else
                {
                    set.add(curKey);
                }
                
                cells = next;   
                N-=1;
            }
            
            return cells;
        }
        
        public int[] nextDayCell(int[] cells)
        {
            int[] temp = new int[cells.length];
            
            for(int i=1;i&lt;cells.length-1;i++)
            {
                temp[i] = (cells[i-1]==cells[i+1]) ? 1:0;        
            }
            return temp;
        }

}

</code>
</pre>
</div>

<template id="my-label-button-code_15"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_16" name="code_16" class="center">
<a class=".title">Partition Label</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_16">
<code class="language-java">
/* @@DESCRIPTION
763. Partition Labels. 劃分字母區間.
將只包含小寫字母的字串盡可能的畫分成多個區間，同一字母只能出現在一個區間中，傳回每個區間的長度.
解法是遍歷整個字串，用包含26個元素的陣列對照表記錄每個字母出現的最後位置. 再遍歷整個字串，當前字串的位置如果等於當前最大最後位置即可計算區間長度.

*/
import java.util.ArrayList;
public class PartitionLabel 
{
    public List&lt;Integer&gt; partitionLabels(String S) {
        int[] last = new int[26];
        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
        
        for(int i=0;i&lt;S.length();i++)
            last[S.charAt(i)-'a'] = i;           
        
        int lastMax = 0, start = 0;
        for(int i=0;i&lt;S.length();i++)
        {
            lastMax = Math.max( last[S.charAt(i)-'a'], lastMax);           
            
            if(lastMax==i)
            {
                res.add(lastMax-start+1);                    
                start = i+1;
            }
        }
        
        return res;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_16"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_17" name="code_17" class="center">
<a class=".title">Optimal Utilization</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_17">
<code class="language-java">
import java.util.*;
/*  @@DESCRIPTION
Amazon 題: Optimal Utilization. 最佳效用值. 
兩組陣列，每組選一數字，找出小於等於並最接近目標數的兩數之和。
解法可用左右雙指標最佳解,二元搜尋或TreeMap.
*/
class OptimalUtilization 
{ // quite correct result.

    public int binarySearch(int[][] sorted, int target, boolean lowerBound)
    {
        int l = 0;
        int r = sorted.length -1;
        int mid = 0;
        int lastKeyPos = -1;
        while(l &lt;= r)
        {
            mid = (l+r)/2;
            int x = sorted[mid][1];

            if(target &lt; x) r= mid-1;
            else if(target &gt; x) l= mid +1;
            else
            {
                lastKeyPos = mid;
                if(lowerBound) r= mid-1;
                else l = mid +1;                
            }
        }

        return (lastKeyPos==-1) ? -(l+1): lastKeyPos;
    }

    // get target sum or closet sum answer from two non-sorted array
    // if no target answer, we only pick the closet sum answer. 
    // for example, target = 20. if next sum answer is 19,18, we only pick all answers of 19.
    // better than Brute Force. 
    public List&lt;List&lt;Integer&gt;&gt; getOptimalUtilization(int[][] a, int[][] b, int target)
    {   
        Arrays.sort(a, (i,j) -&gt; i[1]-j[1]);
        Arrays.sort(b, (i,j) -&gt; i[1]-j[1]);

        int l = 0;
        int r = b.length-1;
        int minCloset = Integer.MAX_VALUE;
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();

        while(l &lt; a.length &amp;&amp; r &gt;= 0)
        {
            int sum = a[l][1] + b[r][1];
            int diff = sum - target ;

            if(sum &gt; target ) r--;
            else {
                
                if(diff&lt;= 0)
                {
                    diff = Math.abs(diff);
                    if(minCloset &gt; diff)
                    {
                        minCloset = diff;
                        res.clear(); 
                        res.add(Arrays.asList( a[l][0], b[r][0]));                  
                    }
                    else if(minCloset == diff)
                    {
                        res.add(Arrays.asList( a[l][0], b[r][0]));                  
                    }
                }

                l++;
            }

        }

        return res;
    }

    // binary search approach
    public List&lt;List&lt;Integer&gt;&gt; binarySearch_getOptimalUtilization(int[][] a, int[][] b, int target)
    {   
        Arrays.sort(a, (i,j) -&gt; i[1]-j[1] ); 
        Arrays.sort(b, (i,j) -&gt; i[1]-j[1] ); 
        List&lt;int[]&gt; candidates = new ArrayList&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        int k =  b.length-1;
        
        while(k  &gt;= 0) 
        {
            int complement = target - b[k][1];
            int index = binarySearch(a, complement, true); 
           // System.out.println(&quot;found at &quot; + index + &quot; for key = &quot; + complement );
           if(index &lt; 0) { 
            index = -index -1; // index of the least integer greater than key
            index = index -1; // index of the greatest integer less than key
           }

            while(index &gt;= 0 &amp;&amp; index &lt; a.length) 
            {
            int diff = target - (a[index][1]+ b[k][1]);
            candidates.add(new int[]{a[index][0], b[k][0], diff }  );
            index--;
            }
           
            k--;
        }

        Collections.sort(candidates, (i , j) -&gt;  i[2]-j[2]  );

        Integer[] lastDiff = { null};

        candidates.forEach( p -&gt; {            
            if(lastDiff[0]==null || lastDiff[0]==p[2])
            {
  //              System.out.println(&quot;(&quot; + Arrays.toString(p) + &quot;)&quot;);
                res.add(Arrays.asList(p[0],p[1]) );
                lastDiff[0] = p[2];
            }
        });

        return res;
    }
    
    // same as binarsearch. TreeMap can be used for two dimension array source
    public List&lt;List&lt;Integer&gt;&gt; TreeMap_getOptimalUtilization(int[][] a, int[][] b, int target)
    {   
        TreeMap&lt;Integer,Integer&gt; pos = new TreeMap&lt;&gt;();
        List&lt;int[]&gt; candidates = new ArrayList&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();

        for(int i=0; i &lt; a.length;i++)
        {
            pos.put(a[i][1],a[i][0]);
        }

        Arrays.sort(b, (i,j) -&gt; i[1]-j[1] ); 

        int k = b.length -1;
        while(k&gt;0)
        {
            int complement = target-b[k][1];
            Map&lt;Integer,Integer&gt; candidate = pos.headMap(complement, true);

            for(Map.Entry&lt;Integer,Integer&gt; e : candidate.entrySet())
            {
                int index = e.getValue();
                int value = e.getKey();
                int diff = target - (value+ b[k][1]);
                candidates.add(new int[]{ index , b[k][0], diff});
            }
            
            k--;
        }

        Collections.sort(candidates, (i , j) -&gt;  i[2]-j[2]  );

        Integer[] lastDiff = { null};

        candidates.forEach( p -&gt; {            
            if(lastDiff[0]==null || lastDiff[0]==p[2])
            {
//                System.out.println(&quot;(&quot; + Arrays.toString(p) + &quot;)&quot;);
                res.add(Arrays.asList(p[0],p[1]) );
                lastDiff[0] = p[2];
            }
        });

        return res;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_17"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_18" name="code_18" class="center">
<a class=".title">Number Of Clusters</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_18">
<code class="language-java">

public class NumberOfClusters  {
    // questions: https://www.glassdoor.com/Interview/Problem-2d-grid-each-node-has-1-colors-find-number-of-clusters-of-a-given-color-red-blue-green-blue-gre-QTN_2930567.htm
    // https://leetcode.com/problems/number-of-islands/
    public int[] numberOfClusters(char[][] grid) {
        char[] colors = new char[] {'0','1','2'};
        int[] count = new int[] { 0,0,0};

        for(int i=0;i&lt;grid.length;i++)
        {
            for(int j=0;j&lt;grid[0].length;j++)
            {
                for(int k=0;k&lt;colors.length;k++)
                {
                    if(grid[i][j]==colors[k]) 
                    {
                        dfs(grid, i, j, colors[k]);
                        count[k]++;
                        break; // break; no need to check other colors.
                    }
                }
            }
        }

      //  System.out.println(&quot;counts: &quot; + Arrays.toString(count));
        return count;
    }
    
    public void dfs(char[][] grid, int y, int x, char target)
    {
        if(x &lt; 0 || x &gt;= grid[0].length || y &lt; 0 || y &gt;= grid.length ) return;        
        if(grid[y][x]!= target) return;
        
        grid[y][x]= 'v'; //marked as visited
        
        dfs(grid, y+1, x, target);
        dfs(grid, y-1, x, target);
        dfs(grid, y, x+1, target);
        dfs(grid, y, x-1, target);
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_18"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_19" name="code_19" class="center">
<a class=".title">Nth Geometric Progression</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_19">
<code class="language-java">
class NthGeometricProgression   {

    public char[] getNthGP(double secondTerm, double thirdTerm, int nth)
    {
        double r = thirdTerm/ secondTerm;
        double a = secondTerm/r;
        double result = a*Math.pow(r, nth-1);
        String str = String.valueOf(result);
        int pos = str.indexOf('.');

        if(pos &gt; 0) // trim up to 
        {
           int decimalPlaces = 3;
           str = str.substring(0, Math.min(pos+decimalPlaces+1, str.length())); 
        }

    //    System.out.println(&quot;res =&gt; [&quot; + str + &quot;]&quot;);
        return str.toCharArray();
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_19"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_20" name="code_20" class="center">
<a class=".title">Most Common Word</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_20">
<code class="language-java">

/*  @@DESCRIPTION
Amazon 題: 最常用字.
給一段文章及禁用字清單. 找出文章中非禁用字的最高頻字.
最佳解是不能排序。將禁用字轉小寫存入HashSet排除從覆字。文章轉小寫拆成字組. 針對非禁用字計數. 不斷地更新當前最大值及當前最高頻字.
*/
class MostCommonWord 
{
    public String mostCommonWord(String paragraph, String[] banned) {
        String[] words = paragraph.split(&quot;\\W+&quot;); // split by all non-character. + means more than one non-character can be used. 
        HashSet&lt;String&gt; set = new HashSet&lt;&gt;();
        HashMap&lt;String,Integer&gt; m = new HashMap&lt;&gt;();
        String maxWord = null;
        int max = 0;
        for(String b : banned)
            set.add(b.toLowerCase());
        
        for(String w: words)
        {
            w = w.toLowerCase();
            if(!set.contains(w))
            {
                m.put(w, m.getOrDefault(w,0)+1);
                int count =m.get(w);
                if(count &gt; max)
                {
                    maxWord = w;
                    max = count;
                }
            }
        }
        
        return maxWord;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_20"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_21" name="code_21" class="center">
<a class=".title">Minimum Cost To Connect Rope</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_21">
<code class="language-java">
import java.util.PriorityQueue;

/*  @@DESCRIPTION
Amazon 題: 連接所有繩子的最小成本
有一堆不同長度的繩子. 每次連接兩繩子的成本就是兩繩長度總和.
請問連接所有繩子的最小成本為何?
由於最小成本必定是要每次都只連接兩個最短繩子,解法是用最小堆積優先佇列存入所有繩長度.
每次取出兩最短繩長度相加. 新連成的繩子也可能還是最短繩之一,所以要把新繩子長度再放入佇列. 這樣一直計算下去，最後所有相加的總和就是最小成本。
*/

class MinimumCostToConnectRope 
{
    public int minCostToConnectRope(int[] ropes)
    {
        int res = 0;
        PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();
        for(int len : ropes) { minHeap.add(len); }

        while(minHeap.size() &gt; 1)
        {
            int combinedLen = minHeap.poll() + minHeap.poll();
            res += combinedLen;
            minHeap.offer(combinedLen);
        }

        return res;
    }

    public void performTest()
    {
        Helper.equals(minCostToConnectRope(new int[]{2, 4, 3}) , 14, &quot;[2,4,3]: &quot;);
        Helper.equals(minCostToConnectRope(new int[]{8, 4, 6, 12}) , 58, &quot;[8,4,6,12]: &quot;);
        Helper.equals(minCostToConnectRope(new int[]{2, 2, 3, 3}) , 20, &quot;[2, 2, 3, 3]: &quot;);
        Helper.equals(minCostToConnectRope(new int[]{1, 2, 5, 10, 35, 89}) , 224, &quot;[1, 2, 5, 10, 35, 89]: &quot;);

    }

    public String toString() { 
        return &quot;Minimum Time to merge files/Minimum Cost to connect Ropes ([E]) [https://leetcode.com/discuss/interview-question/344677]&quot;;
    }
}
</code>
</pre>
</div>

<template id="my-label-button-code_21"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_22" name="code_22" class="center">
<a class=".title">Min Cost To Connect All Nodes Or Repair Edges</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_22">
<code class="language-java">
import java.util.*;
class UF {
    private int[] parent;
    private int[] rank;
    private int count;

    public UF(int N)
    {
        count = N;
        parent = new int[N];
        rank = new int[N];
        for(int i=0;i&lt;N;i++)
        {
            parent[i]=i;
            rank[i]=0;
        }
    }

    public int find(int x)
    {
        while(x!=parent[x])
        {
            parent[x] = parent[parent[x]]; // path compresion
            x = parent[x];
        }

        return x;
    }

    // union by rank
    public void union(int x, int y)
    {
        int rootX = find(x);
        int rootY = find(y);
        if(rootX==rootY) return;
        if(rank[rootX] &lt; rank[rootY])
        {
            parent[rootX] = rootY;
        }
        else
        {
            parent[rootY] = rootX;
            if(rank[rootX] == rank[rootY]) rank[rootX]++;            
        }
        count--;
    }

    public int count() { return count; }
    public boolean connected(int x, int y) { return find(x)==find(y); }
}

class MinCostToConnectAllNodesOrRepairEdges  {

    public static int minCost(int n, int[][] edges, int[][] newEdges) {
        UF uf = new UF(n + 1); // + 1 because nodes are 1-based
        
        Queue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;(newEdges.length, (e1, e2) -&gt; Integer.compare(e1[2], e2[2]));
        HashSet&lt;String&gt; added = new HashSet&lt;&gt;();
        
        for (int[] edge : newEdges) {
            pq.offer(edge);
            added.add(edge[0]+&quot;,&quot;+edge[1]);
        }
                
        for (int[] edge : edges) {
            if(!added.contains(edge[0]+&quot;,&quot;+edge[1])) // ensure the same broken edge is not added.
            {
                pq.offer(new int[]{edge[0],edge[1],0});
            }
        }
        
        int totalCost = 0;
        // 2 because nodes are 1-based and we have 1 unused component at index 0
        while (!pq.isEmpty() &amp;&amp; uf.count() != 2) {
            int[] edge = pq.poll();
            if (!uf.connected(edge[0], edge[1])) {
                uf.union(edge[0], edge[1]);
                totalCost += edge[2];
            }
        }
        return totalCost;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_22"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_23" name="code_23" class="center">
<a class=".title">Merge Two Sorted List</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_23">
<code class="language-java">
/*  @@DESCRIPTION
Merge Two Sorted LinkedList. 合併兩個有序鍊接表.
*/
class MergeTwoSortedList 
{
    public Node mergeTwoLists(Node l1, Node l2) {
        Node dummy = new Node(0);
        Node temp = dummy;
        
        while(l1 !=null &amp;&amp; l2 != null)
        {
            Node smaller = (l1.val &lt; l2.val) ? l1:l2;
            temp.next = smaller;             
            temp = temp.next;
            
            if(l1.val &lt; l2.val) l1=l1.next;
            else l2 = l2.next;
        }
        
        while(l1!=null)
        {
            temp.next = l1;
            temp = temp.next;
            l1 = l1.next;
        }
        
        while(l2!=null)
        {
            temp.next = l2;
            temp = temp.next;
            l2 = l2.next;
        }
        
        return dummy.next;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_23"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_24" name="code_24" class="center">
<a class=".title">Merge Intervals</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_24">
<code class="language-java">
import java.util.*;
class MergeIntervals 
{
    public int[][] merge(int[][] intervals) {
		if (intervals== null || intervals.length &lt;= 1) return intervals;

		// Sort by ascending starting point
		Arrays.sort(intervals, (i,j) -&gt; i[0]==j[0] ? i[1]-j[1]:i[0]-j[0]);

		LinkedList&lt;int[]&gt; llRes = new LinkedList&lt;&gt;();
		llRes.add(intervals[0]);
        
		for (int i=1;i &lt; intervals.length;i++) {
            int[] merged = llRes.getLast();                        
			if (intervals[i][0] &lt;= merged[1]) // Overlapping intervals
            {
                llRes.removeLast();
				merged[1] = Math.max(merged[1], intervals[i][1]);
                llRes.addLast(merged);
            }
			else { // disjoint intervals                          
				llRes.add(intervals[i]);
			}
		}

		return llRes.toArray(new int[llRes.size()][]);
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_24"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_25" name="code_25" class="center">
<a class=".title">Longest String With Three Consecutive Characters</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_25">
<code class="language-java">

class LongestStringWithThreeConsecutiveCharacters   {
    
    // only work for leetcode 1405. Longest Happy String. at most 3 characters. not a general solution
    public void LongestStringWithAtMostKChar(Map&lt;Character, int[]&gt; map, int K, StringBuilder result) {
        PriorityQueue&lt;Map.Entry&lt;Character, int[]&gt;&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; (b.getValue()[0] - a.getValue()[0]));
        for(Map.Entry&lt;Character, int[]&gt; e : map.entrySet()) {
            q.add(e);
        }
        boolean f = false;
        while(!q.isEmpty()) {
            Map.Entry&lt;Character, int[]&gt; current = q.poll();
            if(current.getValue()[0] &gt; 0 &amp;&amp; current.getValue()[1] &lt; K &amp;&amp; !f) {
                result.append(current.getKey());
                map.put(current.getKey(), new int[]{current.getValue()[0] - 1, current.getValue()[1] + 1});
                f = true;
            } else {
                map.put(current.getKey(), new int[]{current.getValue()[0], 0});   
            }
        }
        if(f) {
            LongestStringWithAtMostKChar(map, K, result);
        }
    }

    // INCORRECT. Find the right solution online.
    public String LongestStringWithKConsecutiveCharacters(HashMap&lt;Character, Integer&gt; m, int k)
    {
        System.out.print(&quot;K = &quot; + k + &quot; | &quot;);
        int maxRepeat = k;
        PriorityQueue&lt;Character&gt; pq = new PriorityQueue&lt;&gt;( (c1, c2) -&gt; ( m.get(c1)==m.get(c2) ? c1-c2 :m.get(c2)-m.get(c1) ) );
        
        Iterator&lt;Map.Entry&lt;Character,Integer&gt;&gt; ite = m.entrySet().iterator();

        while(ite.hasNext())
        {
            Map.Entry&lt;Character,Integer&gt; e = ite.next();
            if(e.getValue()&lt;=0) ite.remove();
        }
        
        for(Character c : m.keySet()) { pq.add(c); }

        StringBuilder s = new StringBuilder();
        Character lastChar = null;

        while(pq.size() &gt; 0)
        {            
            Character c = pq.poll(); // get max value

            if(lastChar == c)
            {
               if(pq.isEmpty()) return s.toString();// + &quot;.... (unable to finish) : NOT POSSIBLE &quot;;
                Character next = pq.poll();
                pq.add(c); // add back;
                c = next;
            }
            
            int count = m.get(c);
        //    System.out.print(&quot; pq:&quot; + pq + &quot; , c=&quot;+ c + &quot; | &quot;);

            if(count &gt; 0)
            {
                for(int i=0;  i &lt; Math.min(maxRepeat,count) ; i++)
                {
                    s.append(c);
                    m.put(c,m.get(c)-1);
                }

                if(m.get(c)&gt;0) pq.add(c); // add back 
            }
            lastChar = c;
        }

        return s.toString();
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_25"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_26" name="code_26" class="center">
<a class=".title">Longest Plaindromic Substring</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_26">
<code class="language-java">
class LongestPlaindromicSubstring  {
    // 動態規畫解
    public String longestPalindrome(String s) {
        if(s==null || s.length() &lt; 2) return s;
        // 存全域最大長度用的左右位置
        int left = 0, right = 0;
        int len = s.length();

        //用來存位置i至位置j的字串是否為迴文的記錄表格. 若索引位置小等於2
        boolean[][] isPalindrome = new boolean[len][len];                
        // j starts from 1. must compare at least two chars. one char from j, another char from i.
        
        for(int j=1; j &lt; s.length();j++) 
            for(int i=0; i &lt; j ; i++)
            {
                //j-i &lt;=2 means current length doesnt have an inner string to check.
                boolean isInnerPalindrome = isPalindrome[i+1][j-1] || j-i &lt;=2;
                
                if(isInnerPalindrome &amp;&amp; s.charAt(i)==s.charAt(j) )
                {
                     isPalindrome[i][j] = true;
                    if(j-i &gt; right-left) // update current max length
                    {
                        right = j;
                        left = i;
                    }
                }
            }
        return s.substring(left,right+1);
    }
    // 最大長度迴文中點擴散搜尋法
    public String longestPalindrome_ExpandFromCenter(String s) {
        String max = &quot;&quot;;
        // 針對字串上的每個字為起始點，找出可能的最大迴文長度.
        for(int i=0;i&lt; s.length();i++)
        {
            String s1 = expandFromCenter(s, i, i); //針對單數長度迴文搜尋最大長度
            String s2 = expandFromCenter(s, i, i+1); //針對雙數長度迴文搜尋最大長度
            String curMax = (s1.length() &gt; s2.length()) ? s1:s2; //取當前較大長度字串
            max = (curMax.length() &gt; max.length()) ? curMax:max;//取全域最大長度字串            
        }
        
        return max;
    }
    // 以單中點或雙中點，左右雙指標搜尋迴文最大長度
    public String expandFromCenter(String s, int l, int r)
    {   // 找最大迴文長度
        while(l&gt;=0 &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r))
        { // 在整個字串區間範圍內，當前位置字相等，擴大搜尋範圍。直到當前位置字不相等.
            l--; r++; 
        }
        // 計算當前最大長度，當前左右值是排除值，需要各往中點走一步才是正確的值。
        int len = ((r-1)-(l+1)); //單中點原點長度是0，雙中點原點長度是-1.        
        return s.substring(l+1, r); // 傳回當前最大長度字串, 原點位置時，傳回空字串,零長度。
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_26"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_27" name="code_27" class="center">
<a class=".title">K Closet Pointsto Origin</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_27">
<code class="language-java">
import java.util.Arrays;
/*  @@DESCRIPTION
K Close Potins to Origin. 離原點最近的K個點.
*/
class KClosetPointstoOrigin   {

    public int[][] KClosetPoints_Sort(int[][] points, int K) { // 用距離公式及排序       
        Arrays.sort(points, (p1, p2) -&gt; (p1[0]*p1[0] +p1[1]*p1[1]) - (p2[0]*p2[0] +p2[1]*p2[1]) );
        // int[][] temp = new int[K];
        // for(int i=0;i&lt;K;i++) temp[i]=points[i];
        // return temp;
        return Arrays.copyOfRange(points, 0, K); // 只要前K最近的點
    }

    public int[][] KClosetPoints_PQ(int[][] points, int K) {
        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;int[]&gt;(  
            (p1, p2) -&gt; (p2[0]*p2[0] +p2[1]*p2[1]) - (p1[0]*p1[0] +p1[1]*p1[1])  );
        // 用最大堆積的N*Log(K)技巧取最小K個. 最大堆積，取資料時，是由大到小的順序取出.

        //N*lok(K) 技巧，將所有大於最小K個的值都取出不要.
        for(int[] p:points) 
        {
            pq.offer(p);
            if(pq.size() &gt; K)  pq.poll();
        }
        // 留下的K個就是最小的K個，但最大堆積的存放順序是大到小的順序，需要反轉才是由小到大的順序。
        int[][] res = new int[K][2]; // 分配一組 K個座標大小的陣列
        while(K &gt; 0) res[--K] = pq.poll(); // 反轉存入陣列
        return res; //傳回前K最近的點
    }
    //快速排序法改成O(N)快速排選法: 原理，先分割分組排序，然後用分割中點索引值判斷，
    public int[][] KClosetPoints_QSelect(int[][] points, int K) {
        int len =  points.length, l = 0, r = len - 1;
        while (l &lt;= r) {
            int mid = partition(points, l, r);
//當前分割中點就是第k位,由於是零基底陣列，K左邊值的就是沒排序好的正確答案。            
            if (mid == K) break; 
            if (mid &lt; K) {
                l = mid + 1; //快選右邊，縮左邊邊界.
            } else {
                r = mid - 1; // 快選左邊，縮右邊邊界.
            }
        }
        // 傳回答案，答案不是ascending order.
        return Arrays.copyOfRange(points, 0, K);
    }
    
    private int partition(int[][] arr, int l, int r) {
        int[] pivot = arr[l];// (swap code part 1) 以左邊值為分割值，暫存分割值

        while (l &lt; r) { // 在當前分割分組區間,而且l跟r不能相撞.
            // 右方陣列值大於分割值是合理的，繼續直到找出小於分割值的右陣列值。
            // 找不到時，r 最終等於l就停止.
            while (l &lt; r &amp;&amp; compare(arr[r], pivot) &gt;= 0) r--; 
            arr[l] = arr[r]; // (swap code part 2) 該值換到arr[l]位置 
            // 左方陣列值(非軸值)大於分割值是合理的，繼續直到找出大於分割值的右陣列值。
            // 找不到時，l 最終等於r就停止.
            while (l &lt; r &amp;&amp; compare(arr[l], pivot) &lt;= 0) l++;
            arr[r] = arr[l]; // (swap code part 3)
        } //若原陣列該區間已排序好，最後則換回來.

        arr[l] = pivot;//(swap code part 4) 當前l就是原始軸值應該在的位置
        return l;
    }
    
    private int compare(int[] p1, int[] p2) { // 排序的方式: 照距離由大至小
        return p1[0] * p1[0] + p1[1] * p1[1] - p2[0] * p2[0] - p2[1] * p2[1];
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_27"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_28" name="code_28" class="center">
<a class=".title">Java Collections</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_28">
<code class="language-java">
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.Collection;
import java.util.Collections;
import java.util.PriorityQueue;
import java.util.Queue;

import java.util.Iterator;


public class JavaCollections , IImportTechnique  {
    public void performTest()
    {
        System.out.println(&quot;Priorty Queue:&quot;);
        PriorityQueue&lt;Integer&gt; pq=new PriorityQueue&lt;&gt;(); // 預設的PQ是最小值堆積(Min Heap)，小排到大，意味著小值先出.
        int[] points = new int[] { 1,10,3,6,5,8,7,4,9,2}; int K = 3;

        for(int pValue: points) { pq.offer(pValue); } //存入最小值堆積，讓堆積自已排.

        // 印出堆積的內容，這方法只印出內部陣列的順序，不是最堆積的順序.
        for(Integer p: pq) { System.out.print(p+ &quot; &quot;); } System.out.println();        

        Iterator itr = pq.iterator();          // 用代器，同上.
        while (itr.hasNext()) { System.out.print(itr.next()+ &quot; &quot;);  } System.out.println();
        // 印出照堆積順序排列的值.
        while(pq.size() &gt; 0) { System.out.print(pq.poll()+ &quot; &quot;); } System.out.println();

        // 最大堆積，revereOrder只適用 primitive type.
        Queue&lt;Integer&gt; pq2=new PriorityQueue&lt;&gt;(Collections.reverseOrder()); 
        
        for(int pValue: points) { pq2.offer(pValue); } //存入最大值堆積，讓堆積自已排.
        // 印出照堆積順序排列的值.
        while(pq2.size() &gt; 0) { System.out.print(pq2.poll()+ &quot; &quot;); } System.out.println();
   
        // 使用最大堆積取得最小K個數的 N*log(K) time complexity 技巧.
        // 最大堆積，由小排到大. 邊加入值， 堆積大於K個，就提出最大值.。最後最小的K個
        for(int pValue: points) 
        {
            pq2.offer(pValue); //邊加入值
            if(pq2.size() &gt; K)  pq2.poll(); // 堆積大於K個，就提出最大值.
        }

        // print the result        
        while(!pq2.isEmpty()) { System.out.print(pq2.poll() + &quot; &quot;); } System.out.println();
    
        // add() vs offer(), remove() vs poll(), element() vs peek().
        // add() from Collection can't return false and throw an exception if an element cannot be added.
        // offer() from Queue returns false if an element cannot be added.
        // when the queue is empty, element() and remove() from Collection throws NoSuchElementException, while poll() &amp; peek() return null.
        /*
           add Throws:
            IllegalStateException - if the element cannot be added at this time due to capacity restrictions
            ClassCastException - if the class of the specified element prevents it from being added to this queue.
                for example, adding another type of object into a non-generic ArrayList.
            NullPointerException - if the specified element is null and this queue does not permit null elements
            IllegalArgumentException - if some property of this element prevents it from being added to this queue
        */

        System.out.println(&quot;HashMap:&quot;);

        HashMap&lt;Integer, String&gt; m = new HashMap&lt;&gt;();
        m.put(11, &quot;AB&quot;);
        m.put(2, &quot;CD&quot;);
        m.put(33, &quot;EF&quot;);
        m.put(9, &quot;GH&quot;);
        m.put(3, &quot;IJ&quot;);    

        for(Map.Entry e: m.entrySet() ) { System.out.print(&quot;{&quot; + e.getKey() + &quot;=&gt;&quot; + e.getValue() + &quot;},&quot;); }  System.out.println();

        HashMap&lt;Integer,String&gt; m2 = (HashMap)m.clone();
        
        for(Map.Entry&lt;Integer,String&gt; e: m2.entrySet() ) { System.out.print(&quot;{&quot; + e.getKey() + &quot;=&gt;&quot; + e.getValue() + &quot;},&quot;); } System.out.println();   
        m2.clear();
        m2.putAll(m);        Iterator mItr = m2.entrySet().iterator();
        while(mItr.hasNext()) { Map.Entry e = (Map.Entry)mItr.next(); System.out.print(&quot;{&quot; + e.getKey() + &quot;=&gt;&quot; + e.getValue() + &quot;},&quot;); } System.out.println();

        /*  HashSet &amp; HashMap doesn't maintain any kind of order of its elements.
            LinkedHashSet &amp; LinkedHashMap maintains insertion order.
            TreeSet &amp; TreeMap sort the entries in ascending order of keys and they don't allow null key and throw NullPointerException.
            Set -&gt; contains
            Map -&gt; containsKey, containsValue
        */        

        Set&lt;Integer&gt; set = m2.keySet();
        Iterator&lt;Integer&gt; ite2 = set.iterator();
        while(ite2.hasNext()) { System.out.print(ite2.next() + &quot;,&quot;); } System.out.println();

        Collection&lt;String&gt; values = m2.values();
        for(String s: values) { System.out.print(s + &quot;,&quot;); } System.out.println();
        Iterator&lt;String&gt; ite3 = values.iterator();
        while(ite3.hasNext()) { System.out.print(ite3.next() + &quot;,&quot;); } System.out.println();

        System.out.println(&quot;hello&quot;);

    }
    
    public String toString() { 
        return &quot;Mastering JavaCollectionsn [https://beginnersbook.com/2013/12/how-to-loop-hashmap-in-java/]&quot;;
    }
}

/*

- Use Comparator when you need more flexibilit
** The compareTo() method will return a positive number if one object is greater than the other, negative if it&rsquo;s lower, and zero if they are the same.

import java.util.Comparator;

public class MyComparator implements Comparator&lt;String&gt;
{
   @Override // ascending order based on String length
   public int compare(String x, String y) { return x.length() - y.length();}
}

or you can replace everything before Comparator using new keyword as below.

Collections.sort(strArr, new Comparator&lt;String&gt;
{
   @Override // ascending order based on String length
   public int compare(String x, String y) { return x.length() - y.length();}
});

Using Comparator with lambda expressions as below:
Collections.sort(strArr, (x, y) -&gt; x.length() - y.length()  );

You always use compareTo for a String/object.
Collections.sort(strArr, (s1, s2) -&gt; s1.compareTo(s2));

even shorter with
Collections.sort(strArr, Comparator.naturalOrder() );

    // ascending order means to arrange values from smallest to largest.
    // descending order means to arrange values from largest to smallest.

    // ascending order based on value
    public int compare(Integer x, Integer y) { return x - y;}
    // descending order based on value
    public int compare(Integer x, Integer y) { return y - x;}

    // sort by id in ascending order. when ids are the same, sort by their name in alphabetic order.
    public int compare(User x, User y) { return x.id == y.id ? x.name.compareTo(y)  : x.id-y.id  ;}
    (x,y) -&gt; x.id==y.id ? x.name.compareTo(y) : x.id-y.id;

    // sort by map value in ascending order. When map value are the same, sort by the name in alphabetic order.
    public int compare(String s1, String s2) { return count.get(s1) == count.get(s2) ? s1.compareTo(s2)  : count.get(s1)-count.get(s2); }
    (s1,s2) -&gt; count.get(s1)==count.get(s2) ? s1.compareTo(s2) : count.get(s1)-count.get(s2);

    Sorting a Map with TreeMap
    Map&lt;String, Integer&gt; m  = new TreeMap&lt;&gt;();
    m.put(&quot;DEF&quot;, 10);
    m.put(&quot;ABC&quot;, 20);
    System.out.println(m);

    Sorting a Set with TreeSet
    Set&lt;String&gt; s  = new TreeSet&lt;&gt;();
    s.put(&quot;DEF&quot;);
    s.put(&quot;ABC&quot;);
    System.out.println(m);
*/
</code>
</pre>
</div>

<template id="my-label-button-code_28"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_29" name="code_29" class="center">
<a class=".title">Generate Parentheses</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_29">
<code class="language-java">
import java.util.List;
/*  @@DESCRIPTION
generate parenthesis. 產生有效的雙括號.
*/

class GenerateParentheses  {
    
    public List&lt;String&gt; generateParentheses(int n) {
        List&lt;String&gt; res = new ArrayList&lt;&gt;();
        dfs(&quot;&quot;, n, n, res);   
        return res;
    }
    
    public void dfs(String s, int left, int right, List&lt;String&gt; res)
    {
        if(left &gt; right) return; // 左括號的數量不能小於右括號，否則不是有效雙括號.
        if(left &lt;0 || right &lt; 0) return; //超過所要求的括號數量
        if(left==0 &amp;&amp; right==0) res.add(s); // 剛好是題目要求的雙括號數量
        
        dfs(s+&quot;(&quot;, left-1, right, res); //如果下一個是左括號的狀態分支
        dfs(s+&quot;)&quot;, left, right-1, res); //如果下一個是右括號的狀態分支
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_29"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_30" name="code_30" class="center">
<a class=".title">Find Unique Pairs With Given Sum</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_30">
<code class="language-java">

/*  @@DESCRIPTION
Amazon 題: 最大值的兩數之和. 但陣列中的數字是可以重覆的
找出一組陣列中總和為90的兩數. 如果有超過一組兩數，傳回有單個最大值的那組.  同一元素不可從覆使用.
*/
public class FindUniquePairsWithGivenSum 
{
    public List&lt;List&lt;Integer&gt;&gt; findUniquePairsWithGivenSum(int[] nums, int target)
    {
        Map&lt;Integer, List&lt;Integer&gt;&gt; pos = new HashMap&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        for(int i=0;i&lt;nums.length;i++) 
        { 
            List&lt;Integer&gt; ls = pos.get(target-nums[i]); // 查是否對應的數存在

            if(ls!= null &amp;&amp; ls.size() &gt; 0) //在當前數之前，有相對應的數存在
            {  // to DO. get rid of duplication.
                    int x = nums[i];  // 取得當前數
                    int y = nums[ls.get(0)]; // 取得相對應數
                    int left = x &gt; y ? x:y; // 較大值在左
                    int right = x &gt; y ? y:x; // 較小值在右
                    res.add(Arrays.asList(left, right)); //左大右小的答案格式
                    ls.remove(0); // 清除當前符合條件，不需要再使用.
            }
            else
            {   //如果對應的數不存在，記錄當前數，並存下索引位置.
                pos.put(nums[i], pos.getOrDefault(nums[i], new ArrayList&lt;Integer&gt;()) );
                pos.get(nums[i]).add(i); // 由於陣列內的整數可以重覆出現，用ArrayList存每個位置.
            }
        }

        return res;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_30"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_31" name="code_31" class="center">
<a class=".title">Find Pair With Given Sum</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_31">
<code class="language-java">

/*  @@DESCRIPTION
Amazon 題:多組的兩數之和.
找出一組陣列中總和為90的兩數. 如果有超過一組兩數，傳回每一組. 同一元素不可從覆使用.
*/
public class FindPairWithGivenSum 
{
    public List&lt;List&lt;Integer&gt;&gt; findPairWithGivenSum(int[] nums, int target)
    {
        Map&lt;Integer, List&lt;Integer&gt;&gt; pos = new HashMap&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        int max = Integer.MIN_VALUE;

        for(int i=0;i&lt;nums.length;i++) 
        { 
            List&lt;Integer&gt; ls = pos.get(target-nums[i]);// 查是否對應的數存在

            if(ls!= null &amp;&amp; ls.size() &gt; 0) //在當前數之前，有相對應的數存在
            {
                    int idx1 = ls.get(0); // 在對照表裡的數是在當前數之前存的，索引值肯定較小。                   
                    int idx2 = i; // 當前索引值
                    int curMax = Math.max(nums[idx1],nums[idx2]); // 兩者取較大數值

                    ls.remove(0); // 清除當前符合條件，不需要再使用.
                    
                    if(curMax &gt; max) // 如果該值是全局最大值, 這就是答案.
                    { 
                        max = curMax;
                        res.clear(); // 只要全局最大值答案，清除之前的已經不符合的答案.
                        res.add(Arrays.asList(idx1,idx2)); //答案格式必需照索引值大小排.
                    }

            }
            else
            {  //如果對應的數不存在，記錄當前數，並存下索引位置.
                pos.put(nums[i], pos.getOrDefault(nums[i], new ArrayList&lt;Integer&gt;()) );
                pos.get(nums[i]).add(i); // 由於陣列內的整數可以重覆出現，用ArrayList存每個位置.
            }
        }

        return res;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_31"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_32" name="code_32" class="center">
<a class=".title">Find N Unique Integers Sum Up To Zero</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_32">
<code class="language-java">
import java.util.*;
class FindNUniqueIntegersSumUpToZero  {

    public int[] sumZero(int n) {
        
        int half = n/2;
        int[] arr = new int[n];
        for(int i=0;i&lt; half;i++)
        {
            arr[i]=-(n-i);
            arr[n-i-1]= (n-i);
        }
                    
        return arr;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_32"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_33" name="code_33" class="center">
<a class=".title">Favorite Genres</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_33">
<code class="language-java">

/*  @@DESCRIPTION
Amazon 題:最喜愛的歌曲風格.
給一堆歌手歌曲名單. 也給你告訴每個歌曲的風格. 請輸出每個人的歌曲風格.
*/

class FavoriteGenres 
{
    public Map&lt;String, List&lt;String&gt;&gt; favoriteGenres(Map&lt;String, List&lt;String&gt;&gt; userSongs,//歌手歌曲名單 
    Map&lt;String, List&lt;String&gt;&gt; songGenres) // 風格對歌曲名對照表
    {
        Map&lt;String, Integer&gt; genreCount = new HashMap&lt;&gt;(); //某種歌曲風格的數量
        Map&lt;String, String&gt; song2Genre = new HashMap&lt;&gt;(); // 歌曲名對風格對照表
        Map&lt;String, List&lt;String&gt;&gt; m = new HashMap&lt;&gt;();  //  使用者名字及其風格.
        
        //將 [風格對歌曲名對照表] 轉換成 [歌曲名對風格對照表]
        //鍵值及對映值本身不可以有重覆值才能如此做.
        for(Map.Entry&lt;String, List&lt;String&gt;&gt; e : songGenres.entrySet())
        {
            // 取出每個風格相對應的歌曲清單
            for(String song: e.getValue())
            {
                song2Genre.put(song, e.getKey()); //將此風格的歌曲變成鍵值
            }
        }
         
        System.out.println(song2Genre);

        for(Map.Entry&lt;String, List&lt;String&gt;&gt; e : userSongs.entrySet())
        {  
            List&lt;String&gt; songs = e.getValue(); //取出每個人相對應的喜愛歌曲清單
            String singer = e.getKey(); // 歌手名
            genreCount.clear(); // 該歌手歌曲風格數量

            //預設值應該是不在比較範圍值內的最小值,才不影嚮求最大值計算結果。
             int max = Integer.MIN_VALUE;
            for(String song: songs) // 用該歌手的歌曲計算該歌手歌曲風格數量
            {
                String genre = song2Genre.get(song);
                genreCount.put(genre, genreCount.getOrDefault(genre,0) +1 );
                // 計算該風格的歌曲數量是否是最多歌的風格. 查是否該風格是該歌手的最常唱的風格
                max = Math.max( max, genreCount.get(genre)); //也可用PrioryQueue, 但慢而且沒必要.
            }

            // 由於只需要該歌手唱最多的風格，查最大值即可.
            for(Map.Entry&lt;String,Integer&gt; gc: genreCount.entrySet())
            {
                if(max==gc.getValue()) 
                {// 開始存入該歌手最常唱的風格，如果有一個以上風格的歌曲數量一樣，也等於該歌手風格.
                    m.put(singer, m.getOrDefault(singer, new ArrayList&lt;String&gt;()));
                    m.get(singer).add(gc.getKey());
                }
            }

        }

        return m;
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_33"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_34" name="code_34" class="center">
<a class=".title">Critical Routers Or Connections</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_34">
<code class="language-java">

import java.util.ArrayList;
import java.util.List;
import java.util.HashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;



public class CriticalRoutersOrConnections  
{   // 找出圖上關節點的程式
    class Graph&lt;T&gt;
    {
        private Map&lt;T, List&lt;T&gt;&gt; adjList = new HashMap&lt;&gt;();
        private int time = 0;

        public void addEdges(T[][] edges)
        {
            for(int i=0;i&lt;edges.length;i++)
            {   // 將二維陣列的值，轉成無向圖的雙向節點
                addEdge(edges[i][0], edges[i][1]);
            }
        }

        public void clear()
        {
            adjList.clear();
        }

        public void addEdge(T u, T v)
        {
            addEdge(u, v, true); // 建立無向圖(雙向圖)
        }

        public void addEdge(T u, T v, boolean biDir)
        {
            adjList.put(u, adjList.getOrDefault(u, new ArrayList&lt;T&gt;())); 
            adjList.get(u).add(v);
            if(biDir)
            {   //空值就先建立強型ArrayList，然後存值
                adjList.put(v, adjList.getOrDefault(v, new ArrayList&lt;T&gt;()));
                adjList.get(v).add(u);
            }
        }        

        public void findCutPoints(T node, Map&lt;T, Boolean&gt; visited, Map&lt;T, T&gt; parent,  Map&lt;T, Integer&gt; disc, Map&lt;T, Integer&gt; low, Set&lt;T&gt; ap, Map&lt;T, List&lt;T&gt;&gt; bridges)
        {
            int children = 0;
            visited.put(node, true);
            time++;
            disc.put(node, time);
            low.put(node, time);
                        
            for(T adjNode: adjList.get(node)) //遍歷鄰接節點
            {
                if(visited.get(adjNode)==false) // 若未訪問該鄰接節點
                {
                    children++; //計算當前主節點有多少孩節點
                    parent.put(adjNode,node); //當前鄰接節點的父親是當前主節點
                    findCutPoints(adjNode, visited, parent, disc, low, ap, bridges);
                    low.put(node, Math.min(low.get(node), low.get(adjNode) ) );
                    
                    // this piece of code is to determine cut points
                    if(ap!=null)
                    {
                        if(parent.get(node)==null &amp;&amp; children &gt; 1) ap.add(node);
                        if(parent.get(node) != null &amp;&amp; low.get(adjNode) &gt;= disc.get(node)) // &gt; for bridges, &gt;= for points
                            ap.add(node);
                    }

                    // this piece of code is to determine. &gt; for bridges, &gt;= for points
                    if(bridges != null)
                    {
                        if(low.get(adjNode) &gt; disc.get(node)) {
                            bridges.put(node, bridges.getOrDefault(node, new ArrayList&lt;T&gt;()) );
                            bridges.get(node).add(adjNode);
                        }
                    }

                }
                else if(visited.get(adjNode)== true &amp;&amp; adjNode != parent.get(node) )
                {
                    low.put(node, Math.min(low.get(node), disc.get(adjNode) ) );
                }

            }
        }

        public Set&lt;T&gt; findCutPoints()
        {
            Map&lt;T, Boolean&gt; visited = new HashMap&lt;&gt;();
            Map&lt;T, T&gt; parent= new HashMap&lt;&gt;();  //每個節點的父鄰節節點,就是第一個訪問此點的節點.
            Map&lt;T, Integer&gt; low= new HashMap&lt;&gt;();
            Map&lt;T, Integer&gt; disc= new HashMap&lt;&gt;(); //存每個節點是第幾個被訪問的?
            Set&lt;T&gt; ap = new HashSet&lt;T&gt;();
            time = 0;// 共有多少節點被訪問，0可代表該節點是第一個被訪問的.
            for(T node: adjList.keySet()) //為每節點預設
            {
                visited.put(node, false); // 設成從未訪問過
                parent.put(node, null); // root by deafult，自已是自己父親.
                low.put(node, 0);  
                disc.put(node, 0); // 該節點是第幾個被訪問?這是未知的。
            }
    
            for(T node: adjList.keySet())
            {
                if(visited.get(node)==false)
                findCutPoints(node, visited, parent, disc, low, ap, null);
            }

            return ap;
        }

        public Map&lt;T, List&lt;T&gt;&gt; findBridges()
        {
            Map&lt;T, Boolean&gt; visited = new HashMap&lt;&gt;();
            Map&lt;T, T&gt; parent= new HashMap&lt;&gt;();
            Map&lt;T, Integer&gt; low= new HashMap&lt;&gt;();
            Map&lt;T, Integer&gt; disc= new HashMap&lt;&gt;();
            Map&lt;T, List&lt;T&gt;&gt; bridges = new HashMap&lt;&gt;();

            time = 0;

            for(T node: adjList.keySet())
            {
                visited.put(node, false);
                parent.put(node, null); // root by deafult
                low.put(node, 0);
                disc.put(node, 0);
            }
    
            for(T node: adjList.keySet())
            {
                if(visited.get(node)==false)
                findCutPoints(node, visited, parent, disc, low, null, bridges);
            }

            return bridges;
        }
    }

    public void performTest()
    {
        Graph&lt;Integer&gt;  g = new Graph&lt;&gt;();

        // https://leetcode.com/discuss/interview-question/436073/
        g.addEdges(new Integer[][] { {0, 1}, {0, 2}, {1, 3}, {2, 3}, {2, 5}, {5, 6}, {3, 4} });
        System.out.println(&quot;Cut Points :&quot; +  g.findCutPoints() );

        // https://leetcode.com/problems/critical-connections-in-a-network/
        g.clear();
        g.addEdges(new Integer[][] { {1, 2}, {1, 3}, {3, 4}, {1, 4}, {4, 5}} );
        System.out.println(&quot;Bridges (Cut Edges) :&quot; + g.findBridges() );
        g.clear();
        g.addEdges(new Integer[][] { {1, 2}, {1, 3}, {2, 3}, {2, 4}, {2, 5}, {4, 6}, {5, 6} } );
        System.out.println(&quot;Bridges (Cut Edges) :&quot; + g.findBridges() );
        g.clear();
        g.addEdges(new Integer[][] { {1, 2}, {1, 3}, {2, 3}, {3, 4}, {3, 6}, {4, 5}, {6, 7}, {6, 9}, {7, 8}, {8, 9} } );
        System.out.println(&quot;Bridges (Cut Edges) :&quot; + g.findBridges() );
    }

    public String toString() { return &quot;Critical Routers &amp; Connections, Articulation Points/Cut Point, Bridges/Cut Edges ([E]**):&quot;;}

}

</code>
</pre>
</div>

<template id="my-label-button-code_34"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_35" name="code_35" class="center">
<a class=".title">Copy Random Linked List</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_35">
<code class="language-java">
import java.util.HashMap;
/*  @@DESCRIPTION
Copy Random LinkedList. 拷貝帶有指向其它節點的鍊接表.
*/

public class CopyRandomLinkedList   {
    public Node copyRandomListWithDummyNode(Node head)   {
        if(head==null) return null;        
        HashMap&lt;Node, Node&gt; m = new HashMap&lt;Node, Node&gt;(); // 舊鍊表指標對映到新鍊表指標
        Node dummy = new Node(0); // 使用dummy，簡化程式碼
        
        // 迴圈遍歷整個舊鍊表, 同時建立新指標及遍歷新鍊表
        for(Node cur = head, temp = dummy; cur!=null; cur=cur.next, temp=temp.next)
        { 
            temp.next = new Node(cur.val); // 建立新指鏢
            m.put(cur, temp.next); 
        }
                
        // 迴圈遍歷整個舊新鍊表，將舊鍊表指鏢對映的位置存入新鍊表的random指鏢
        for(Node cur = head, temp = dummy.next; cur!=null; cur=cur.next, temp=temp.next)
        {
            if(cur.random!=null) temp.random = m.get(cur.random); //存對應的random
        }
        
        return dummy.next; // 傳回新鍊表的頭
    }

    public Node copyRandomListWithoutDummyNode(Node head)   {
        if(head==null) return null;        
        HashMap&lt;Node, Node&gt; m = new HashMap&lt;Node, Node&gt;();

        // 遍歷整個已有鍊表，直接存舊鍊表指標對映到新鍊表指標
        for(Node cur = head; cur!=null; cur=cur.next)
        {
            m.put(cur, new Node(cur.val));// 存新建立的指標
        }

        // 再遍歷整個已有鍊表，直接取出新鍊表指標，然後同時設定對應的next及random.  
        for(Node cur = head; cur!=null; cur=cur.next)
        {
            m.get(cur).next = m.get(cur.next); //存對應的next
            m.get(cur).random = m.get(cur.random);//存對應的random
        }

        return m.get(head);
    }

}

</code>
</pre>
</div>

<template id="my-label-button-code_35"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_36" name="code_36" class="center">
<a class=".title">Binary Search</a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_36">
<code class="language-java">
public class BinarySearch , IImportTechnique 
{
    // 傳回所找元素的位置，找不到，則傳回該元素該被插入的位置(insertion position)
    // lowerBound(低值邊界，左邊界): true -&gt; 有重覆元素時，傳回重覆元素的左邊界或靠低值的邊界
    // lowerBound(低值邊界，左邊界): false-&gt; 有重覆元素時，傳回重覆元素的右邊界或靠右值的邊界
    // 將負插入位置轉成正值後減一就是，該元素該被插入的位置.
    public int binarySearch(int[] arr, int key, boolean lowerBound)
    {
        int left = 0;
        int right = arr.length - 1;
        int lastKeyPos = -1;

        while(left &lt;= right)
        {
            int mid = (left+right) / 2;
            int cur  = arr[mid];

            if(key &gt; cur) left = mid+1;
            else if(key &lt; cur) right = mid-1;
            else // key == cur
            {
                lastKeyPos = mid;

                if(lowerBound) right = mid-1;
                else left = mid+1;
            }
        
        }

        return (lastKeyPos==-1) ? -(left+1) : lastKeyPos;
    }

    public void performTest()
    {
        int[] nums = new int[] { 1,2,2,2,2,3,3,3,4,4,6,6,6,7,8,9,10};
        

        System.out.print(&quot;Array: &quot;);
        for(int i=0;i &lt; nums.length; i++) System.out.print(String.format(&quot;[%2s]&quot;, nums[i]));
        System.out.println();

        System.out.print(&quot;Pos:   &quot;);
        for(int i=0;i &lt; nums.length; i++) System.out.print(String.format(&quot;{%2s}&quot;, i));
        System.out.println();

        System.out.println(&quot;\nLowerBound BinarySearch&quot;);
        for(int i=0;i &lt; 12; i++)
        {
            int insertPosition =  binarySearch(nums, i, true);
            System.out.println(&quot;key = &quot; + i + &quot; =&gt; &quot; + insertPosition);
        }

        System.out.println(&quot;\nUpperBound BinarySearch&quot;);
        for(int i=0;i &lt; 12; i++)
        {
            int insertPosition =  binarySearch(nums, i, false);
            System.out.println(&quot;key = &quot; + i + &quot; =&gt; &quot; + insertPosition);
        }

        System.out.println(&quot;Positive insert position = the actual found key position.&quot;);
        System.out.println(&quot;Negative insert postion (-insertPos -1) = the position of the least integer greater than key &quot;);
    }

    public String toString() { 
        return &quot;Binary Search []&quot;;
    }
}

</code>
</pre>
</div>

<template id="my-label-button-code_36"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>


  
	</body>
</html>
