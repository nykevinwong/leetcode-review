<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Atomic Habit</title>
    <link rel="stylesheet" type="text/css" href="prism.css" />
    <style>
      .center {
          margin: auto;
          width: 820px;
          border: 1px solid black;
          padding: 0 0 0 0;
          font-size: 11px;
          line-height: 14px;
        }

      .noscrollbar {
        overflow: hidden;
      }

      
    </style>
		<script src="prism.js" type="text/javascript"></script>
		<script src="main.js" type="text/javascript"></script>

<script>


  </script>
	</head>
	<body>
	
  <!-- table of contents -->
	<ul>
    <li id="li_1" name="li_1" data-id="98"><input type="checkbox" id="checkbox_1" name="checkbox_1" /><a href="#code_1">LEETCODE 1</a></li>
<li id="li_2" name="li_2" data-id="94"><input type="checkbox" id="checkbox_2" name="checkbox_2" /><a href="#code_2">LEETCODE 2</a></li>
<li id="li_3" name="li_3" data-id="912"><input type="checkbox" id="checkbox_3" name="checkbox_3" /><a href="#code_3">LEETCODE 3</a></li>
<li id="li_4" name="li_4" data-id="77"><input type="checkbox" id="checkbox_4" name="checkbox_4" /><a href="#code_4">LEETCODE 4</a></li>
<li id="li_5" name="li_5" data-id="743"><input type="checkbox" id="checkbox_5" name="checkbox_5" /><a href="#code_5">LEETCODE 5</a></li>
<li id="li_6" name="li_6" data-id="70"><input type="checkbox" id="checkbox_6" name="checkbox_6" /><a href="#code_6">LEETCODE 6</a></li>
<li id="li_7" name="li_7" data-id="703"><input type="checkbox" id="checkbox_7" name="checkbox_7" /><a href="#code_7">LEETCODE 7</a></li>
<li id="li_8" name="li_8" data-id="701"><input type="checkbox" id="checkbox_8" name="checkbox_8" /><a href="#code_8">LEETCODE 8</a></li>
<li id="li_9" name="li_9" data-id="700"><input type="checkbox" id="checkbox_9" name="checkbox_9" /><a href="#code_9">LEETCODE 9</a></li>
<li id="li_10" name="li_10" data-id="52"><input type="checkbox" id="checkbox_10" name="checkbox_10" /><a href="#code_10">LEETCODE 10</a></li>
<li id="li_11" name="li_11" data-id="509"><input type="checkbox" id="checkbox_11" name="checkbox_11" /><a href="#code_11">LEETCODE 11</a></li>
<li id="li_12" name="li_12" data-id="46"><input type="checkbox" id="checkbox_12" name="checkbox_12" /><a href="#code_12">LEETCODE 12</a></li>
<li id="li_13" name="li_13" data-id="450"><input type="checkbox" id="checkbox_13" name="checkbox_13" /><a href="#code_13">LEETCODE 13</a></li>
<li id="li_14" name="li_14" data-id="37"><input type="checkbox" id="checkbox_14" name="checkbox_14" /><a href="#code_14">LEETCODE 14</a></li>
<li id="li_15" name="li_15" data-id="344"><input type="checkbox" id="checkbox_15" name="checkbox_15" /><a href="#code_15">LEETCODE 15</a></li>
<li id="li_16" name="li_16" data-id="297"><input type="checkbox" id="checkbox_16" name="checkbox_16" /><a href="#code_16">LEETCODE 16</a></li>
<li id="li_17" name="li_17" data-id="285"><input type="checkbox" id="checkbox_17" name="checkbox_17" /><a href="#code_17">LEETCODE 17</a></li>
<li id="li_18" name="li_18" data-id="264"><input type="checkbox" id="checkbox_18" name="checkbox_18" /><a href="#code_18">LEETCODE 18</a></li>
<li id="li_19" name="li_19" data-id="250"><input type="checkbox" id="checkbox_19" name="checkbox_19" /><a href="#code_19">LEETCODE 19</a></li>
<li id="li_20" name="li_20" data-id="24"><input type="checkbox" id="checkbox_20" name="checkbox_20" /><a href="#code_20">LEETCODE 20</a></li>
<li id="li_21" name="li_21" data-id="240"><input type="checkbox" id="checkbox_21" name="checkbox_21" /><a href="#code_21">LEETCODE 21</a></li>
<li id="li_22" name="li_22" data-id="236"><input type="checkbox" id="checkbox_22" name="checkbox_22" /><a href="#code_22">LEETCODE 22</a></li>
<li id="li_23" name="li_23" data-id="22"><input type="checkbox" id="checkbox_23" name="checkbox_23" /><a href="#code_23">LEETCODE 23</a></li>
<li id="li_24" name="li_24" data-id="220"><input type="checkbox" id="checkbox_24" name="checkbox_24" /><a href="#code_24">LEETCODE 24</a></li>
<li id="li_25" name="li_25" data-id="206"><input type="checkbox" id="checkbox_25" name="checkbox_25" /><a href="#code_25">LEETCODE 25</a></li>
<li id="li_26" name="li_26" data-id="17"><input type="checkbox" id="checkbox_26" name="checkbox_26" /><a href="#code_26">LEETCODE 26</a></li>
<li id="li_27" name="li_27" data-id="173"><input type="checkbox" id="checkbox_27" name="checkbox_27" /><a href="#code_27">LEETCODE 27</a></li>
<li id="li_28" name="li_28" data-id="145"><input type="checkbox" id="checkbox_28" name="checkbox_28" /><a href="#code_28">LEETCODE 28</a></li>
<li id="li_29" name="li_29" data-id="144"><input type="checkbox" id="checkbox_29" name="checkbox_29" /><a href="#code_29">LEETCODE 29</a></li>
<li id="li_30" name="li_30" data-id="119"><input type="checkbox" id="checkbox_30" name="checkbox_30" /><a href="#code_30">LEETCODE 30</a></li>
<li id="li_31" name="li_31" data-id="117"><input type="checkbox" id="checkbox_31" name="checkbox_31" /><a href="#code_31">LEETCODE 31</a></li>
<li id="li_32" name="li_32" data-id="116"><input type="checkbox" id="checkbox_32" name="checkbox_32" /><a href="#code_32">LEETCODE 32</a></li>
<li id="li_33" name="li_33" data-id="112"><input type="checkbox" id="checkbox_33" name="checkbox_33" /><a href="#code_33">LEETCODE 33</a></li>
<li id="li_34" name="li_34" data-id="110"><input type="checkbox" id="checkbox_34" name="checkbox_34" /><a href="#code_34">LEETCODE 34</a></li>
<li id="li_35" name="li_35" data-id="108"><input type="checkbox" id="checkbox_35" name="checkbox_35" /><a href="#code_35">LEETCODE 35</a></li>
<li id="li_36" name="li_36" data-id="106"><input type="checkbox" id="checkbox_36" name="checkbox_36" /><a href="#code_36">LEETCODE 36</a></li>
<li id="li_37" name="li_37" data-id="105"><input type="checkbox" id="checkbox_37" name="checkbox_37" /><a href="#code_37">LEETCODE 37</a></li>
<li id="li_38" name="li_38" data-id="104"><input type="checkbox" id="checkbox_38" name="checkbox_38" /><a href="#code_38">LEETCODE 38</a></li>
<li id="li_39" name="li_39" data-id="102"><input type="checkbox" id="checkbox_39" name="checkbox_39" /><a href="#code_39">LEETCODE 39</a></li>
<li id="li_40" name="li_40" data-id="101"><input type="checkbox" id="checkbox_40" name="checkbox_40" /><a href="#code_40">LEETCODE 40</a></li>
<li id="li_41" name="li_41" data-id="100"><input type="checkbox" id="checkbox_41" name="checkbox_41" /><a href="#code_41">LEETCODE 41</a></li>

  </ul>
  
  
<div id="code_1" name="code_1" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_1">
<code class="language-java">
/*
有效的二元搜尋樹的特性是
(1)當前節點值大於左節點值及左子樹所有節點值，當前節點值小於右節點值及右子樹所有節點值.
(2)左右子樹必須是有效元二元搜尋樹，當前節點才是個有效二元樹.
(3)一個空節點是一個有效的二元搜尋樹.
(4)二元搜尋樹的左右邊界檢查可用Integer/Long Warpper Class,而且空值代表無限大.
*/
    public boolean isValidBST(TreeNode root) {
        return isValidBST(root, null, null); // null means infinity here.
    }
    
    public boolean isValidBST(TreeNode root, Integer leftBound, Integer rightBound)
    {
        if(root==null) return true;
        
        if( (leftBound==null || leftBound &lt; root.val) &amp;&amp; (rightBound==null || root.val &lt; rightBound) )
        {
            return isValidBST(root.left, leftBound, root.val) &amp;&amp;
                    isValidBST(root.right, root.val, rightBound);
        }
        
        return false;
    }
</code>
</pre>
</div>

<template id="my-label-button-code_1"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_2" name="code_2" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_2">
<code class="language-java">
import java.util.List;

/* 
 中序遍歷(先遍歷左節點)可取得二元搜尋樹的升序排列資料.
 反向中序遍歷(先遍歷右節點)可取得二元搜尋樹的降序排列資料.
 二元搜尋樹跟二元樹的差別是，二元搜尋樹當前節點值大於左子樹所有的鍵值，小於右子樹所有的鍵值.
 中序遍歷可用來做表達式樹(expression tree)及算術表達式樹，如編譯器的基本加減乘除.
 表达式求值也可以使用后缀表达式。后缀表达式求值比中缀表达式更方便，可以先把
 中缀表达式变成后缀表达式，然后再根据后缀表达式求值。
*/

public List&lt;Integer&gt; inorderTraversal(TreeNode root)
{
    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
    dfs(root, res);
    return res;
}

public void dfs(TreeNode root, List&lt;Integer&gt; res)
{
    if(root==null) return;
    dfs(root.left);
    res.add(root.val);
    dfs(root.right);
}


</code>
</pre>
</div>

<template id="my-label-button-code_2"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_3" name="code_3" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_3">
<code class="language-java">
    // bottom-up approach, postorder approach (array)
    public int[] sortArray(int[] nums) {
        if(nums.length&lt;=1) return nums;

        int[] m1 =sortArray(Arrays.copyOfRange(nums,0, nums.length/2) );
        int[] m2 =sortArray(Arrays.copyOfRange(nums,nums.length/2, nums.length) );
        return mergeSort(m1, m2);
    }
    
    public int[] mergeSort(int[] left, int[] right)
    {
        int[] merged = new int[left.length+right.length];
        int i = 0;
        int j = 0;
        int c = 0;
        
        while(i &lt; left.length &amp;&amp; j &lt; right.length)
            merged[c++] = left[i] &lt; right[j] ? left[i++]: right[j++];
        
        while(i &lt; left.length)
            merged[c++] = left[i++];
        
        while(j &lt; right.length)
            merged[c++] = right[j++];
        return merged;
    }
</code>
</pre>
</div>

<template id="my-label-button-code_3"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_4" name="code_4" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_4">
<code class="language-java">
public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) {
    List&lt;List&lt;Integer&gt;&gt; ls = new ArrayList&lt;&gt;();
    combine(n, k, 1, new boolean[n+1], new ArrayList&lt;Integer&gt;(), ls);
    return ls;        
}

public void combine(int n, int k, int start, boolean[] visited, List&lt;Integer&gt; l, List&lt;List&lt;Integer&gt;&gt; ls)
{

    for(int i=start;i&lt;=n;i++)
    {
        if(!visited[i])
        {
            visited[i] = true;
             l.add(i);
  
            if(l.size()==k) 
            {
                ls.add(new ArrayList&lt;Integer&gt;(l));
            }
            else
            {
                combine(n, k, i+1, visited, l, ls);
            }
            l.remove(l.size()-1);
            
            visited[i] = false;
        }
        
    }
}
</code>
</pre>
</div>

<template id="my-label-button-code_4"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_5" name="code_5" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_5">
<code class="language-java">
public int networkDelayTime(int[][] times, int N, int K)
{
    Map&lt;Integer, Map&lt;Integer,Integer&gt;&gt; map = new HashMap&lt;&gt;();
    
    for(int[] time : times)
    {
        map.putIfAbsent(time[0], new HashMap&lt;&gt;());
        map.get(time[0]).put(time[1], time[2]);
    }
    
    //distance, node into pq
    Queue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((a,b) -&gt; (a[0] - b[0]));
    
    pq.add(new int[]{0, K});
    
    boolean[] visited = new boolean[N+1];
    int res = 0;
    
    while(!pq.isEmpty()){
        int[] cur = pq.remove();
        int curNode = cur[1];
        int curDist = cur[0];
        if(visited[curNode]) continue;
        visited[curNode] = true;
        res = curDist;
        N--;
        if(map.containsKey(curNode)){
            for(int next : map.get(curNode).keySet()){
                pq.add(new int[]{curDist + map.get(curNode).get(next), next});
            }
        }
    }
    return N == 0 ? res : -1;
        
}
</code>
</pre>
</div>

<template id="my-label-button-code_5"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_6" name="code_6" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_6">
<code class="language-java">
Map&lt;Integer,Integer&gt; m = new HashMap&lt;&gt;();
    
public int climbStairs(int n) {
    return climb(n);
}

public int climb(int remainStep)
{
    if(remainStep &lt; 0) return 0; // this move doesn't make sense since it must be zero after last step.
    if(remainStep==0) return 1;
    
    if(m.containsKey(remainStep))
    {
        return m.get(remainStep);
    }
    
    int count = climb(remainStep-1) + climb(remainStep-2);
    m.put(remainStep, count);
    return m.get(remainStep);
}
</code>
</pre>
</div>

<template id="my-label-button-code_6"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_7" name="code_7" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_7">
<code class="language-java">

</code>
</pre>
</div>

<template id="my-label-button-code_7"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_8" name="code_8" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_8">
<code class="language-java">

public TreeNode insertIntoBST(TreeNode root, int val) {
    if(root==null) return new TreeNode(val);
    
    if(root.val &gt; val) root.left = insertIntoBST(root.left, val);                
    if(root.val &lt; val) root.right = insertIntoBST(root.right, val);        
    
    return root;
}

//iterative approach   
public TreeNode insertIntoBST(TreeNode root, int val) {
    Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();

    if(root!=null) s.push(root);
        
    while(!s.isEmpty())
    {
        TreeNode node = s.pop();
        
        if(node.val &lt; val) { 
            if(node.right==null) { node.right = new TreeNode(val); return root; }                
            s.push(node.right); 
        }            
        
        if(node.val &gt; val) { 
            if(node.left==null) { node.left = new TreeNode(val); return root; }                
            s.push(node.left); 
        }            
    }
    
    return new TreeNode(val);
}
</code>
</pre>
</div>

<template id="my-label-button-code_8"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_9" name="code_9" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_9">
<code class="language-java">

</code>
</pre>
</div>

<template id="my-label-button-code_9"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_10" name="code_10" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_10">
<code class="language-java">
public int totalNQueens(int n) {
    int[][] board = new int[n][n];
    int[] count = new int[1];
    
    solveNQueen(board, 0, count);
    return count[0];
}

public boolean isValidPos(int board[][], int row, int col) 
{ 
    int i, j; 

    /* Check this row on left side */
    for (j = 0; j &lt; col; j++) 
        if (board[row][j] == 1) 
            return false; 

    /* Check upper diagonal on left side */
    for (i = row, j = col; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) 
        if (board[i][j] == 1) 
            return false; 

    /* Check lower diagonal on left side */
    for (i = row, j = col; j &gt;= 0 &amp;&amp; i &lt; board.length; i++, j--) 
        if (board[i][j] == 1) 
            return false; 

    return true; 
}

public void solveNQueen(int[][] board, int x, int[] count)
{    
    for(int y=0; y &lt; board.length; y++)
    {
        if(isValidPos(board, y,x))
        {
            board[y][x] = 1;
            
            if(x+1 == board[0].length) // finished the whole board
            {
                count[0]++;
            }
            else
            {
                solveNQueen(board, x+1, count);
            }
            
            board[y][x] = 0; // backtrack
        }            
    }

}
</code>
</pre>
</div>

<template id="my-label-button-code_10"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_11" name="code_11" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_11">
<code class="language-java">
/*
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), for N &gt; 1.
 
https://leetcode.com/articles/fibonacci-number/
*/

// top-down recursive solution

    public int fib(int N) {
        if (N &lt;= 1) {
            return N;
        }
        return fib(N-1) + fib(N-2);
    }

// top-down recursive memorization solution
    Map&lt;Integer,Integer&gt; m = new HashMap&lt;&gt;();
    
    public int fib(int n) {
        if(n&lt;=1) return n;
        
        if(m.containsKey(n)) return m.get(n);
        
        m.put(n, fib(n-1)+fib(n-2));
        
        return m.get(n);
    }


// Bottom-Up Approach using Memoization

    public int fib(int N) {
        if (N &lt;= 1) {
            return N;
        }
        return memoize(N);
    }

    public int memoize(int N) {
      int[] cache = new int[N + 1];
      cache[1] = 1;

      for (int i = 2; i &lt;= N; i++) {
          cache[i] = cache[i-1] + cache[i-2];
      }
      return cache[N];
    }

// Top-Down Approach using Memoization  2

class Solution {
    private Integer[] cache = new Integer[31];

    public int fib(int N) {
        if (N &lt;= 1) {
            return N;
        }
        cache[0] = 0;
        cache[1] = 1;
        return memoize(N);
    }

    public int memoize(int N) {
      if (cache[N] != null) {
          return cache[N];
      }
      cache[N] = memoize(N-1) + memoize(N-2);
      return memoize(N);
    }
}

// iterative top-down solution
    public int fib(int N) {
        if (N &lt;= 1) {
            return N;
        }
        if (N == 2) {
            return 1;
        }

        int current = 0;
        int prev1 = 1;
        int prev2 = 1;

        for (int i = 3; i &lt;= N; i++) {
            current = prev1 + prev2;
            prev2 = prev1;
            prev1 = current;
        }
        return current;
    }


// use math golden ratio to perform O(1) solution

    public int fib(int N) {
        double goldenRatio = (1 + Math.sqrt(5)) / 2;
        return (int)Math.round(Math.pow(goldenRatio, N)/ Math.sqrt(5));
    }

</code>
</pre>
</div>

<template id="my-label-button-code_11"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_12" name="code_12" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_12">
<code class="language-java">
public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
    if(nums==null || nums.length==0) return res;        
    int n = nums.length;
    permute(nums, new boolean[n], new ArrayList&lt;Integer&gt;(),res);
    
    return res;
}

public List&lt;Integer&gt; toList(int nums[])
{
    List&lt;Integer&gt; l = new ArrayList&lt;&gt;();
    for(int value : nums) l.add(value);
    return l;        
}

public void permute(int[] nums, boolean[] visited, List&lt;Integer&gt; l, List&lt;List&lt;Integer&gt;&gt; res)
{
    if(l.size()==nums.length) { res.add(new ArrayList&lt;Integer&gt;(l)); return; }                

    for(int i=0; i &lt; nums.length;i++)
    {
        if(!visited[i])
        {
            l.add(nums[i]);
            visited[i]= true;
            permute(nums, visited, l, res);
            visited[i]= false;
            l.remove(l.size()-1);
        }
    }
}
</code>
</pre>
</div>

<template id="my-label-button-code_12"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_13" name="code_13" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_13">
<code class="language-java">

public TreeNode deleteNode(TreeNode root, int value)
{
 if(root==null) return null; // nothing mathced.
 
 if(root.val &gt; value)  
 {   //傳回值要傳給當前左節點
      root.left = deleteNode(root.left, value); 
 }
 else if(root.val &lt; value) 
 {  //傳回值要傳給當前右節點
       root.right = deleteNode(root.right, value); 
 }
 else if(root.val==value)
 {   // cover 00, 01, 10 case
  if(root.left==null || root.right==null) // only one child node 
   return (root.left==null) ? root.right:root.left; 

        // 11 case. two childs
 TreeNode leftMostMinOnRight = root.right;  
  
  while(leftMostMinOnRight.left!=null) leftMostMinOnRight = leftMostMinOnRight.left;
  
  root.val = leftMostMinOnRight.val;
//傳回值要傳回給要刪的節點
  root.right = deleteNode(root.right, root.val);
  
 }

 return root; 
}
</code>
</pre>
</div>

<template id="my-label-button-code_13"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_14" name="code_14" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_14">
<code class="language-java">
public void solveSudoku(char[][] board) {
    if(board == null || board.length == 0)
        return;
    solve(board);
}

public boolean solve(char[][] board){
    for(int i = 0; i &lt; board.length; i++){
        for(int j = 0; j &lt; board[0].length; j++){
            if(board[i][j] == '.'){
                for(char c = '1'; c &lt;= '9'; c++){//trial. Try 1 through 9
                    if(isValid(board, i, j, c)){
                        board[i][j] = c; //Put c for this cell
                        
                        if(solve(board))
                            return true; //If it's the solution return true
                        else
                            board[i][j] = '.'; //Otherwise go back
                    }
                }
                
                return false;
            }
        }
    }
    return true;
}

private boolean isValid(char[][] board, int row, int col, char c){
    for(int i = 0; i &lt; 9; i++) {
        if(board[i][col] != '.' &amp;&amp; board[i][col] == c) return false; //check row
        if(board[row][i] != '.' &amp;&amp; board[row][i] == c) return false; //check column
        
        // mapping 1 to 9 to corresponding 9-box grid cell
        int gridY = 3 * (row / 3) + i / 3; int gridX =  3 * (col / 3) + i % 3;
        if(board[gridY][gridX] != '.' &amp;&amp; board[gridY][gridX] == c) return false; //check 3*3 block
    }
    return true;
}

</code>
</pre>
</div>

<template id="my-label-button-code_14"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_15" name="code_15" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_15">
<code class="language-java">

public void reverseString(char[] s) {
    reverseString(s, 0, s.length-1);
}

public void reverseString(char[] s, int i, int j)
{
    if(i &gt;= j) return;
    char temp = s[i];
    s[i] = s[j];
    s[j] = temp;
    
    reverseString(s, i+1,j-1);
}
</code>
</pre>
</div>

<template id="my-label-button-code_15"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_16" name="code_16" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_16">
<code class="language-java">
public String serialize(TreeNode root) {
    if(root==null) return &quot;&quot;;
    Queue&lt;TreeNode&gt; q= new LinkedList&lt;&gt;();
    StringBuilder sb = new StringBuilder();
    
    if(root!=null) q.offer(root);
    
    while(!q.isEmpty())
    {
        TreeNode node = q.poll();
        
        if(node==null) 
        {
            sb.append(&quot;null,&quot;);
        }
        else
        {
            sb.append(node.val + &quot;,&quot;);
            q.offer(node.left);
            q.offer(node.right);
        }
    }

    sb.deleteCharAt(sb.length()-1);
    return sb.toString();
}
 
// Decodes your encoded data to tree.
public TreeNode deserialize(String data) {
    if(data==&quot;&quot;) return null;
    String[] arr = data.split(&quot;,&quot;);
    
    TreeNode root = new TreeNode(Integer.parseInt(arr[0]));
    Queue&lt;TreeNode&gt; q= new LinkedList&lt;&gt;();
    
    q.offer(root);
    
    for(int i=1; i &lt; arr.length;i++)
    {
        TreeNode node = q.poll();
        
        node.left = (arr[i].equals(&quot;null&quot;)) ? null: new TreeNode(Integer.parseInt(arr[i]));
        i++;
        node.right = (arr[i].equals(&quot;null&quot;)) ? null: new TreeNode(Integer.parseInt(arr[i]));
        if(node.left!=null) q.offer(node.left);
        if(node.right!=null) q.offer(node.right);
    }
    
    return root;
}
</code>
</pre>
</div>

<template id="my-label-button-code_16"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_17" name="code_17" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_17">
<code class="language-java">
package codes;

public class 285_inorder-sucessor-in-BST {
    
}
</code>
</pre>
</div>

<template id="my-label-button-code_17"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_18" name="code_18" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_18">
<code class="language-java">
/*
We have an array k of first n ugly number. We only know, at the beginning, the first one, which is 1. Then
k[1] = min( k[0]x2, k[0]x3, k[0]x5). The answer is k[0]x2. So we move 2's pointer to 1. Then we test:
k[2] = min( k[1]x2, k[0]x3, k[0]x5). And so on. Be careful about the cases such as 6, in which we need to forward both pointers of 2 and 3.

x here is multiplication.
*/
    public int nthUglyNumber(int n) {
        int[] ugly = new int[n];
        ugly[0] = 1;
        int index2 = 0, index3 = 0, index5 = 0;
        int factor2 = 2, factor3 = 3, factor5 = 5;
        for(int i=1;i&lt;n;i++){
            int min = Math.min(Math.min(factor2,factor3),factor5);
            ugly[i] = min;
            if(factor2 == min)
                factor2 = 2*ugly[++index2];
            if(factor3 == min)
                factor3 = 3*ugly[++index3];
            if(factor5 == min)
                factor5 = 5*ugly[++index5];
        }
        return ugly[n-1];
    }
</code>
</pre>
</div>

<template id="my-label-button-code_18"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_19" name="code_19" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_19">
<code class="language-java">
/*
geek-for-geek solution

單值樹根節點值與左右節點值相同，代表此樹是根節點. 以此後序遍歷整個樹.
單值樹(uniValue) 空節點代表一個有效節點，傳回真。但節點不代表一個樹，不能計算成一個uniValue.
單值樹題用排除法及後序遍歷來解比較容易.

七言絕句:
單值樹根左右等     //題目及單值樹特性1 
空節點真不為樹     //單值樹空節點特性
後序遍歷排除解     //RECURSIVE解法
所有孩值為當值.    //如果是多元樹，要記得這點.
任一假非單值樹
當值非左值為假
當值非右值為假
計樹數量傳回真
*/

  public int countUnivalSubtrees(TreeNode root) {
    // Write your solution here
    int[] count = new int[1];
     isUniValueSubTree(root,count);
     return count[0];
  }

// apply bottom-up/postorder traversal approach
  public boolean isUniValueSubTree(TreeNode root, int[] count)
  {
      if(root==null) return true;

      boolean left = isUniValueSubTree(root.left, count);
      boolean right = isUniValueSubTree(root.right, count);

        // If any of the subtrees is not singly, then this 
        // cannot be singly. 

      if(left==false || right == false) return false;
      if(root.left!=null &amp;&amp; root.left.key != root.key) return false;
      if(root.right!=null &amp;&amp; root.right.key != root.key) return false;

      /// now the root's val and its value on left and right are the same.
      count[0]++;
      return true;
  }

boolean isUniValueSubTree(TreeNode node, int[] count)  
    { 
        // Return false to indicate NULL 
        if (node == null) 
            return true; 
           
        // Recursively count in left and right subtrees also 
        boolean left = countSingleRec(node.left, count); 
        boolean right = countSingleRec(node.right, count); 
   
        // If any of the subtrees is not singly, then this 
        // cannot be singly. 
        if (left == false || right == false) 
            return false; 
   
        // If left subtree is singly and non-empty, but data 
        // doesn't match 
        if (node.left != null &amp;&amp; node.val != node.left.val) 
            return false; 
   
        // Same for right subtree 
        if (node.right != null &amp;&amp; node.val != node.right.val) 
            return false; 
   
        // If none of the above conditions is true, then 
        // tree rooted under root is single valued, increment 
        // count and return true. 
        count[0]++; 
        return true; 
    } 
</code>
</pre>
</div>

<template id="my-label-button-code_19"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_20" name="code_20" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_20">
<code class="language-java">
//Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.
//You may not modify the values in the list's nodes, only nodes itself may be changed.
   
  
    public ListNode swapPairs(ListNode head) {
        if(head==null || head.next==null) return head;

        //  [first]-&gt;[second]-&gt;[thrid]

        // 用良好變數名稱.
        ListNode first = head;
        ListNode second = first.next; 

       // 將第一節點next指到第三節點，也就是指到第二節點next
        first.next = second.next;     
        second.next = first;
       

        first.next = swapPairs(first.next); // swap next one
        return second;
    }
</code>
</pre>
</div>

<template id="my-label-button-code_20"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_21" name="code_21" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_21">
<code class="language-java">
// divide-and-conquer approach

public boolean searchMatrix(int[][] matrix, int target) {
    if(matrix==null || matrix.length==0) return false;
    
    return searchMatrix(matrix, target, 0,0, matrix[0].length-1, matrix.length-1);
}


public boolean searchMatrix(int[][] m, int target, int left, int top, int right, int bottom)
{
    // such boundary doesn't exist. no element to check.
    if(left &gt; right || top &gt; bottom) return false;
    
    // only one element. check this element.
    if(left==right &amp;&amp; top==bottom) return m[top][left]==target;
    
    // caluclate pivot point &amp; get value.
    int py = (top+bottom)/2; // or we use top + (bottom-top)/2 to avoid integer overflow.
    int px = (left+right)/2;   // or we use left + (right-left)/2 to avoid integer overflow.      
    int pValue = m[py][px];
    
    if(pValue &lt; target)
    {
        boolean m2Found = searchMatrix(m, target, px+1, top, right, py);
        boolean m3Found = searchMatrix(m, target, left, py+1, px, bottom);
        boolean m4Found = searchMatrix(m, target, px+1, py+1, right, bottom);
        return m2Found || m3Found || m4Found;
    }
    else if(pValue &gt; target)
    {
        boolean m1Found = searchMatrix(m, target, left, top, px, py);
        boolean m2Found = searchMatrix(m, target, px+1, top, right, py);
        boolean m3Found = searchMatrix(m, target, left, py+1, px, bottom);
        return m1Found || m2Found || m3Found;
        
    }
    
    return true; // pivotValue = target. found it.
    
}

</code>
</pre>
</div>

<template id="my-label-button-code_21"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_22" name="code_22" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_22">
<code class="language-java">
/*
要找的節點都必須存在二元樹中，才能用此方法

查左右節點雙空，傳回空。
查任一空時，傳回不空。可以下面檢查.
if(left==null || right==null) // 00,01,10 covers 3 cases // return null or the other value.
            return (left==null) ? right:left;

use both top-down &amp; bottom-up approach
*/
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        
        // this approach won't work if p or q doesn't exist in the binary tree
       if(root==null) return null;
        if(root==p || root==q) return root;

        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        // return null for both null
        // return the one while the other is null.
        if(left==null || right==null) // 00,01,10 covers 3 cases // return null or the other value.
            return (left==null) ? right:left;
         
        return root;      // must use root since we want to ensure the top most ancestor is the answer  
    }
</code>
</pre>
</div>

<template id="my-label-button-code_22"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_23" name="code_23" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_23">
<code class="language-java">
public List&lt;String&gt; generateParenthesis(int n) {
    List&lt;String&gt; res = new ArrayList&lt;&gt;();
//        generate(n, 0, 0, res ,&quot;&quot;);
    generateItreative(n, 0, 0, res, &quot;&quot;);
    return res;
}

public void generate(int n, int left, int right, List&lt;String&gt; res, String cur)
{
    if(left==n &amp;&amp; right==n) { res.add(cur); return; }
    if(right &gt; left) return; // prune this execution tree
    if(right &gt; n || left &gt; n) return; // prune this execution tree
    
    generate(n, left+1, right, res, cur+&quot;(&quot;);
    generate(n, left, right+1, res, cur+&quot;)&quot;);
}


public Object[] arguments(Integer n, Integer left, Integer right, List&lt;String&gt; res, String cur)
{
    return new Object[]{ n,left, right, res, cur };
}


public void generateItreative(int n, int left, int right, List&lt;String&gt; res, String cur)
{
    Stack&lt;Object[]&gt; s = new Stack&lt;Object[]&gt;();
    s.push(arguments(n,0,0, res, &quot;&quot;));
    
    while(!s.isEmpty())
    {
        Object[] argu = s.pop();
        
        n = (int)argu[0];
        left = (int)argu[1]; 
        right = (int)argu[2];
        res = (List&lt;String&gt;)argu[3];
        cur = (String)argu[4];
        
        if(left==n &amp;&amp; right==n) { res.add(cur); continue; }
        if(right &gt; left) continue;  // prune this execution tree
        if(right &gt; n || left &gt; n) continue; // prune this exection tree
        
        // stack push order is reverse order from the call order from the original recurisve function
        s.push( arguments( n, left, right+1, res, cur+&quot;)&quot; ) );
        s.push( arguments( n, left+1, right, res, cur+&quot;(&quot; ) );
        
    }
    
    return;
}

</code>
</pre>
</div>

<template id="my-label-button-code_23"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_24" name="code_24" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_24">
<code class="language-java">
   // n* log(k) solution
   public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
    if(nums==null||nums.length&lt;2||k&lt;0||t&lt;0)
        return false;
 
    TreeSet&lt;Long&gt; set = new TreeSet&lt;Long&gt;();
    for(int i=0; i&lt;nums.length; i++){
        long curr = (long) nums[i];
 
        long leftBoundary = (long) curr-t;
        long rightBoundary = (long) curr+t+1; //right boundary is exclusive, so +1
        SortedSet&lt;Long&gt; sub = set.subSet(leftBoundary, rightBoundary); // at most t
        if(sub.size()&gt;0)
            return true;
 
        set.add(curr);   
 
        if(i&gt;=k){ // or if(set.size()&gt;=k+1) // at most k
            set.remove((long)nums[i-k]);
        }
    }
 
    return false;
    }
</code>
</pre>
</div>

<template id="my-label-button-code_24"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_25" name="code_25" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_25">
<code class="language-java">
/*
Reverse a singly linked list.
Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?
*/
    public ListNode reverseList(ListNode head) 
    {
        
        //  (head)-&gt;5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
        ListNode dummy = new ListNode(0);        
        ListNode cur = head;
    
        //  (cur,head,5)-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
        //  (dummy,0)-&gt;NULL
        
        while(cur!=null)
        {
            ListNode temp = cur; // (temp,cur,head,5)-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL            
            cur = cur.next;      // (temp,head,5)-&gt;(cur,4)-&gt;3-&gt;2-&gt;1-&gt;NULL
            temp.next = dummy.next; // (temp,head,5)-&gt;NULL
            dummy.next = temp;   // (dummy,0)-&gt;(temp,head,5)-&gt;NULL
        }
        
        return dummy.next;
    }

//without dummy node
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        
        while(head != null)
        {
            ListNode next = head.next;
            head.next = prev;
            prev = head;
            head = next;
        }
        
        return prev;
    }
</code>
</pre>
</div>

<template id="my-label-button-code_25"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_26" name="code_26" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_26">
<code class="language-java">
public List&lt;String&gt; letterCombinations(String digits) {
    List&lt;String&gt; res = new ArrayList&lt;&gt;();        
    if(digits==null || digits.length()==0) return res;
    
    HashMap&lt;String,String&gt; m = new HashMap&lt;&gt;();
    
    m.put(&quot;2&quot;,&quot;abc&quot;);
    m.put(&quot;3&quot;,&quot;def&quot;);
    m.put(&quot;4&quot;,&quot;ghi&quot;);
    m.put(&quot;5&quot;,&quot;jkl&quot;);
    m.put(&quot;6&quot;,&quot;mno&quot;);
    m.put(&quot;7&quot;,&quot;pqrs&quot;);
    m.put(&quot;8&quot;,&quot;tuv&quot;);
    m.put(&quot;9&quot;,&quot;wxyz&quot;);
          
    letterCombo(m, digits, 0, &quot;&quot;, res);
    return res;
}

public void letterCombo(HashMap&lt;String,String&gt; m, String digits, int index, String s, List&lt;String&gt; res)
{
    if(index== digits.length()) { res.add(s); return;  }
    String c = &quot;&quot; + digits.charAt(index);
    String keys = m.get(c);
                                 
    for(int i=0;i &lt; keys.length();i++)
    {
        letterCombo(m, digits, index+1, s+keys.charAt(i), res);
    }
}


</code>
</pre>
</div>

<template id="my-label-button-code_26"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_27" name="code_27" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_27">
<code class="language-java">
// iterative approach

class BSTIterator {
    Stack&lt;TreeNode&gt; s= new Stack&lt;&gt;();
    TreeNode cur;
    
    public BSTIterator(TreeNode root) {
        cur = root;        
    }
    
    /** @return the next smallest number */
    public int next() {
        
        while(cur!=null)
        {
            s.push(cur);
            cur = cur.left;
        }
        
        cur = s.pop();
        int value = cur.val;
        
        cur = cur.right;
        return value;
    }
    
    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        return cur!=null || !s.isEmpty();
    }
}

// recursive approach

class BSTIterator {
    LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;();
    
    public BSTIterator(TreeNode root) {
        dfs(root, res);
    }
    
    public void dfs(TreeNode root, List&lt;Integer&gt; res)
    {
        if(root==null) return;
        dfs(root.left, res);
        res.add(root.val);
        dfs(root.right, res);
    }
    
    /** @return the next smallest number */
    public int next() {
        return res.remove();
    }
    
    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        return res.size() &gt; 0;
    }
}


</code>
</pre>
</div>

<template id="my-label-button-code_27"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_28" name="code_28" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_28">
<code class="language-java">
import java.util.List;

/* 後序遍歷可用來
(1)實現計算目錄內文件佔用硬盤的資料大小
(2) 也可從代達式樹建立postfix expression (Reverse Polish notation).
 &quot;ABC-*DE++&quot;. 
(3) 也可以用刪除節點，free記憶體，父節點只能在子節點記憶體free後，才能free自己的物件記憶體.
(4) 拷貝一個二元樹的過程，就是一個後序遍歷的過程.必須完全拷貝子樹後，才能拷貝父節點物件.

统计文件夹的大小过程如下：
若要知道某文件夹的大小，必须先知道该文件夹下所有文件的大小.
如果有子文件夹，若要知道该子文件夹大小，必须先知道子文件夹所有文件的大小。这是一个典型的后序遍历过程。

*/
public List&lt;Integer&gt; postorderTraversal(TreeNode root)
{
    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
    dfs(root, res);
    return res;
}

public void dfs(TreeNode root, List&lt;Integer&gt; res)
{
    if(root==null) return;
    dfs(root.left);
    dfs(root.right);
    res.add(root.val);
}

</code>
</pre>
</div>

<template id="my-label-button-code_28"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_29" name="code_29" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_29">
<code class="language-java">
import java.util.List; 

/* 
 前序遍歷可取得二元樹的拓排列資料. 前序先處理父節點，再來處理子節點.
 前序遍歷可用來實現目錄結構的顯示，也可從代達式樹建立prefix expression (Polish notation). &quot;+*A-BC+DE&quot;
 如果是文件夹，先输出文件夹名，然后再依次输出该文件夹下的所有文件(包括子文件夹). 
 如果有子文件夹，则再进入该子文件夹，输出该子文件夹下的所有文件名.
 这是一个典型的先序遍历过程.
*/

public List&lt;Integer&gt; preorderTraversal(TreeNode root)
{
    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
    dfs(root, res);
    return res;
}

public void dfs(TreeNode root, List&lt;Integer&gt; res)
{
    if(root==null) return;
    res.add(root.val);
    dfs(root.left);
    dfs(root.right);
}

</code>
</pre>
</div>

<template id="my-label-button-code_29"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_30" name="code_30" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_30">
<code class="language-java">

public List&lt;Integer&gt; getRow(int rowIndex) {
    // p(i,j) = p(i-1,j-1)+p(i-1,j)
    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
    res.add(1);
    
    for(int i=1;i&lt;=rowIndex;i++)
    {
        List&lt;Integer&gt; cur = new ArrayList&lt;&gt;();
        cur.add(1);
        for(int j=1;j&lt;res.size();j++)
        {
           cur.add(res.get(j-1)+ res.get(j));                
        }
        cur.add(1);
        
        res.clear();
        res = cur;            
    }
    
    return res;
    
}
</code>
</pre>
</div>

<template id="my-label-button-code_30"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_31" name="code_31" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_31">
<code class="language-java">
public static Node connect(Node root) {
    Node nextHead = new Node(0);
    nextHead.next = root;
    while(nextHead.next != null){
     Node tail = nextHead;
     Node n = nextHead.next;
     nextHead.next = null;
     for(; n != null; n = n.next){
      if(n.left != null){
       tail.next = n.left;
       tail = tail.next;
      }
      
      if(n.right != null){
       tail.next = n.right; 
       tail = tail.next;
      }
     }
    }
          return root;
   }
</code>
</pre>
</div>

<template id="my-label-button-code_31"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_32" name="code_32" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_32">
<code class="language-java">
/*空間 complexity 為 O(1) 的解法

選定二元樹的向右指標
填二元樹右Next

左節點層序Next指標遍歷: 
*/
    public Node connect(Node root) {
        if (root==null) return null;
        
        Node leftMost = root, node = null;
        
        while (leftMost.left!=null) {
            node = leftMost;
            while (node!=null) {
                node.left.next = node.right;
                if (node.next!= null) node.right.next = node.next.left;
                node = node.next;
            }
            // go to beginning node of next level
            leftMost = leftMost.left;
        }
        
        return root;         
    }

//暴力解: BFS 層序遍歷

    public Node connect(Node root) {
        if (root==null) return null;
        
        Queue&lt;Node&gt; q = new LinkedList&lt;&gt;();
        
        if(root!=null) q.offer(root);
        while(!q.isEmpty())
        {
            int size = q.size();
            Node prev = null;
            for(int i=0;i&lt;size;i++)
            {
                Node node = q.poll();                
                if(prev!=null) prev.next = node;                
                prev = node;
                
                if(node.left!=null) q.offer(node.left);
                if(node.right!=null) q.offer(node.right);
            }                        
        }
        return root;
    }

</code>
</pre>
</div>

<template id="my-label-button-code_32"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_33" name="code_33" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_33">
<code class="language-java">
import java.util.Stack;
//top-down, preorder travesal approach
public boolean hasPathSum(TreeNode root, int sum) {
    if(root==null) return false;
    
    sum-=root.val;
    
    if(root.left==null &amp;&amp; root.right==null)
        return sum==0;
    
    return hasPathSum(root.left, sum) | hasPathSum(root.right, sum);        
}

//iterative solution:

public boolean hasPathSum(TreeNode root, int sum) {
        Stack&lt;Object[]&gt; s = new Stack&lt;&gt;();
        
        if(root!=null) s.push(pair(root, sum));
    
        while(!s.isEmpty())
        {
            Object[] nodes = s.pop();
            TreeNode node = (TreeNode)nodes[0];
                                          
            Integer curSum = (Integer)nodes[1] -  node.val;
            
            if(node.left==null &amp;&amp; node.right==null &amp;&amp; curSum==0) return true;
            
            // you must push right node first before left node when you want to process left first and then right.
            // preorder traversal always process left first and then right.
            if(node.right!=null) s.push(pair(node.right,curSum) );
            if(node.left!=null) s.push(pair(node.left,curSum));
        }
    
    return false;
}

public Object[] pair(TreeNode a, Integer sum)
{
    return new Object[] { a, sum};
}
</code>
</pre>
</div>

<template id="my-label-button-code_33"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_34" name="code_34" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_34">
<code class="language-java">
    
  public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        }
        
        int left = depth(root.left);
        int right = depth(root.right);
        
        if (Math.abs(left - right) &gt; 1) {
            return false;
        }
       
      return isBalanced(root.left) &amp;&amp; isBalanced(root.right);   
    }
    
    public int depth(TreeNode root) {
        if (root == null) return 0;

        int left = depth(root.left);
        int right = depth(root.right);        
        return Math.max(left, right) + 1;
    }
    
    public int depthShort(TreeNode root) {
        if (root == null) return 0;

        return Math.max(depth(root.left), depth(root.right)) + 1;
    }
    
    HashMap&lt;TreeNode,Integer&gt; m = new HashMap&lt;&gt;();
    public int depthDP(TreeNode root) {
        if (root == null) return 0;

        if(m.containsKey(root)) return m.get(root);
            
        int left = depth(root.left);
        int right = depth(root.right);        
        
        m.put(root, Math.max(left, right) + 1);
        return m.get(root);
    }


// dfs approach
    public int dfsHeight (TreeNode root) {
        if (root == null) return 0;
        
        int leftHeight = dfsHeight (root.left);
        if (leftHeight == -1) return -1;
        int rightHeight = dfsHeight (root.right);
        if (rightHeight == -1 || Math.abs(leftHeight - rightHeight) &gt; 1)  return -1;
        
        return Math.max(leftHeight, rightHeight) + 1;
    }

    public boolean isBalanced(TreeNode root) {
        return dfsHeight (root) != -1;
    }

</code>
</pre>
</div>

<template id="my-label-button-code_34"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_35" name="code_35" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_35">
<code class="language-java">
public TreeNode sortedArrayToBST(int[] nums) {
    return createBSTFromArray(nums, 0, nums.length-1);
}

public TreeNode  createBSTFromArray(int[] nums, int start, int end)
{
    if(start &gt; end) return null; // stop condition
    
    int mid = (start+end)/2;        
    int value = nums[mid];        
    TreeNode node = new TreeNode(value);
    node.left = createBSTFromArray(nums, start, mid-1);
    node.right = createBSTFromArray(nums, mid+1, end);
    return node;
}
</code>
</pre>
</div>

<template id="my-label-button-code_35"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_36" name="code_36" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_36">
<code class="language-java">
public TreeNode buildTree(int[] inorder, int[] postorder)
{
  Map&lt;Integer,Integer&gt; m = new HashMap&lt;&gt;();
  
  for(int i=0;i&lt; inorder.length;i++) { m.put(inorder[i],i); }
  
  return buildTree(inorder, postorder, 0, inorder.length-1, 0, postorder.length-1, m);
}

/*               
 [1 2 3 7 8 9 5]
     
     
 [1 2 3 5 7 8 9]
 
 next subTree interval in recusive calls
 
 post left Tree (poStart, poStart + leftTreeLen -1 )
 post right Tree (poStart + leftTreeLen, poEnd -1 )
 
 in left Tree (inStart, rootIndex -1)
 in right Tree(rootIndex+1, inEnd)
 
*/

public TreeNode buildTree(int[] inorder, int[] postorder, int inStart, int inEnd, int poStart, int poEnd, Map&lt;Integer,Integer&gt; m)
{
 // When it's out of index boundary
 if(inStart &gt; inEnd || poStart &gt; poEnd) return null;
 
 TreeNode node = new TreeNode(postorder[poEnd]);
 int rootIndex = m.get(postorder[poEnd]);
 int leftTreeLen = rootIndex - inStart;
 int rightTreeLen = inEnd - rootIndex;
 
 node.left = buildTree(inorder, postorder,
        inStart, rootIndex -1,
        poStart, poStart + leftTreeLen -1, m);
        
 
 node.right = buildTree(inorder, postorder,
         rootIndex+1, inEnd,
         poStart + leftTreeLen, poEnd -1, m);
       

 return node;
}
</code>
</pre>
</div>

<template id="my-label-button-code_36"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_37" name="code_37" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_37">
<code class="language-java">
/*
區間長度公式為兩數差的絕對值+1.
公式不受基底起始索引值的影嚮.

中序陣列元素值對索引對照表對解中序陣列題可能有用.

中序陣列左右子樹大小:
零基底陣列表示是從左到右。索引值從0到n.
中序陣列右子樹的區間大小 inLeftTreeLen = 陣列右邊界索引值 -  中序當前根節點索引值.
中序陣列右子樹的區間大小 inRightTreeLen= 中序當前根節點索引值 - 陣列右邊界索引值.


停止或防止區間操作的條件:
某區間start 至 end，防止或停止區間外的操作可用 if(start &gt; end) 來檢查並停止.
如果有多個區間，則任何區間符合防止操作條件就可停止.

中序左右子樹區間範圍:
如果已知中序節點索引值rootIndex, 左子樹為 (inStart, rootIndex-1)，右子樹為(rootIndex+1, inEnd).

前序陣列左右子樹區間範圍:
 左子樹為(preStart+1, preEnd - 右子樹大小) , 右子樹為 (preEnd- 右子樹大小+1, preEnd)

後序陣列左右子樹區間範圍:
 左子樹為(postStart, postStart+左子樹大小-1) , 右子樹為 (poStart+左子樹大小, postEnd-1)

node.left = buildTree(inorder, postorder,
        inStart, rootIndex -1,
        poStart, poStart + leftTreeLen -1, m);
        
 
 node.right = buildTree(inorder, postorder,
         rootIndex+1, inEnd,
         poStart + leftTreeLen, poEnd -1, m);
       
*/

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        Map&lt;Integer,Integer&gt; inPos = new HashMap&lt;Integer,Integer&gt;();
        
        for(int i=0;i&lt; inorder.length;i++)
        {
            inPos.put(inorder[i], i);
        }
        
        return buildTree(inorder, preorder, 0, inorder.length-1, 0, preorder.length-1, inPos);
    }
    
    public TreeNode buildTree(int[] inorder, int[] preorder, int inStart, int inEnd, int preStart, int preEnd,  Map&lt;Integer,Integer&gt; inPos)
    {
        if(inStart &gt; inEnd || preStart &gt; preEnd ) return null;
        TreeNode node = new TreeNode(preorder[preStart]);
        int rootIndex = inPos.get(preorder[preStart]);  
        int rightTreeLen = inEnd - rootIndex;
        int leftTreeLen = rootIndex - inStart;
       
        node.left = buildTree(inorder, preorder, 
                              inStart, rootIndex-1, 
                               preStart+1,  preEnd - rightTreeLen, inPos);      
        node.right = buildTree(inorder, preorder, 
                              rootIndex + 1, inEnd,  
                               preEnd- rightTreeLen + 1, preEnd, inPos);
        
        return node;
    }
</code>
</pre>
</div>

<template id="my-label-button-code_37"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_38" name="code_38" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_38">
<code class="language-java">
import java.lang.Math;
public int maxDepth(TreeNode node)
{
    //bottom-up/postorder recusrive approach
    
    if(node==null) return 0;
    
    int leftMax = maxDepth(node.left);
    int rightMax = maxDepth(node.right);
    
    return Math.max(leftMax, rightMax) + 1;
}
</code>
</pre>
</div>

<template id="my-label-button-code_38"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_39" name="code_39" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_39">
<code class="language-java">
import java.util.List;

/*
 無限大樹無法使用dfs. dfs將無限地往下搜尋第一個或某路徑，而用光記憶體而出錯.
 無限大樹可用bfs一層一層搜，但必須有一個bounded branching factor限制最大範圍.
 
 深度為2的樹，無限多孩，二grand child樹。
 這種樹可用dfs，因為一個樹根節支只有兩層，但無法使用bfs，因無一層就無限多孩。

*/
//Recursive approach.
   public  List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        levelOrder(root, res, 0);
        return res;
    }
    
    public void levelOrder(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res, int level) {
        if(root==null) return;
        if(res.size()==level) res.add(new ArrayList&lt;Integer&gt;());
        
        res.get(level).add(root.val);

        levelOrder(root.left, res, level+1);
        levelOrder(root.right, res, level+1);
    }

// iterative approach
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        
        if(root!=null) q.offer(root);
        
        while(!q.isEmpty())
        {
            int size = q.size();
            List&lt;Integer&gt; l = new ArrayList&lt;&gt;();
            for(int i=0;i&lt;size;i++)
            {
                TreeNode node = q.poll();
                l.add(node.val);
                if(node.left!=null) q.offer(node.left);
                if(node.right!=null) q.offer(node.right);
            }
            
            res.add(l);
        }
        return res;
    }
</code>
</pre>
</div>

<template id="my-label-button-code_39"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_40" name="code_40" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_40">
<code class="language-java">

/*
   有效的鏡像對稱二元樹所需條件:
   (1) 樹根節點或子樹根節點與自已對稱，函式可以傳兩個同一根節點，自已比較自已.
   (2) 當前左節點值等於當前右節點值.
   (3) 當前左節點的右值與當前右節點的左值相等。反之  
        
例子:當前左右節點同時都空值時，當前節點也是有效鏡像二元子樹.
       當前左右節點只有一個為空值，代表不相等，不是有效鏡像二元子樹。    
       
*/
    public boolean isSymmetric(TreeNode root) {
        return isMirror(root, root);
    }
    
    public boolean isMirror(TreeNode left, TreeNode right)
    {
        if(left == null &amp;&amp; right == null) return true;
        if(left==null || right == null) return false;
        
        return (left.val == right.val) &amp;&amp; 
            isMirror(left.left, right.right) &amp;&amp;
            isMirror(left.right,right.left);
    }
</code>
</pre>
</div>

<template id="my-label-button-code_40"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>

<div id="code_41" name="code_41" class="center">
<a class=".title"></a>
<pre  style="overflow:hidden;"  data-label="my-label-button-code_41">
<code class="language-java">
public boolean isSameTree(TreeNode p, TreeNode q) {        
    if(p==null &amp;&amp; q==null) return true;        
    if(p==null || q==null) return false; // 01 10
    
    if(p.val != q.val) return false;
    
    return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);
}

public boolean isSameNode(TreeNode p, TreeNode q) {        
    if(p==null &amp;&amp; q==null) return true;        
    if(p==null || q==null) return false; // 01 10
    
    return (p.val == q.val);
}

public boolean isSameTreeIterative(TreeNode p, TreeNode q)
{
    Stack&lt;TreeNode&gt; s1 = new Stack&lt;&gt;();
    Stack&lt;TreeNode&gt; s2 = new Stack&lt;&gt;();
    
    s1.push(p);
    s2.push(q);
    
    while(!s1.isEmpty())
    {
        TreeNode a = s1.pop();
        TreeNode b = s2.pop();
        
        if(!isSameNode(a,b)) return false;   
        
        if(a!=null)
        {
            if(!isSameNode(a.left,b.left)) return false;                
            
            if(a.left!=null)
            {
                s1.push(a.left);
                s2.push(b.left);
            }

            if(!isSameNode(a.right,b.right)) return false;
            
            if(a.right!=null)
            {
                s1.push(a.right);
                s2.push(b.right);
            }
        }
        
        
        
    }
    return true;
    
}

</code>
</pre>
</div>

<template id="my-label-button-code_41"><button onclick="alert('This is an inline-handler');">Leetcode</button></template>


  
	</body>
</html>
