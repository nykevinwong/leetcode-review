Design HashSet

we will use separate chaining strategy to resolve hash collisions.

class MyHashSet {
    private LinkedList<Integer>[] bucketArray;
    private int keyRange = 769; // better to pick a prime number in order to reduce the potential collision.
    
    public MyHashSet() {
        this.bucketArray = new LinkedList[keyRange];
        for(int i=0; i < bucketArray.length;i++)
        {
            this.bucketArray[i] = new LinkedList<Integer>();
        }
    }
    
    protected int hash(int key)
    {
        return key % keyRange;
    }
    
    public void add(int key) {
        LinkedList<Integer> container = this.bucketArray[hash(key)];        
        if(!container.contains(key)) container.add(key);            
    }
    
    public void remove(int key) {        
        LinkedList<Integer> container = this.bucketArray[hash(key)];
        container.remove(new Integer(key)); // convert to object before removing.
    }
    
    public boolean contains(int key) {
        LinkedList<Integer> container = this.bucketArray[hash(key)];
        return container.contains(key);
    }
}

class TreeNode
{
    public TreeNode left, right;
    public int value;
    public TreeNode(int v) { value = v;}
}

class BinarySearchTree
{
    TreeNode root;
    
    public BinarySearchTree()
    {
        
    }
    
    public void add(int key) { root = add(root, key); }
    public boolean contains(int key) { return find(root, key)!=null; }
    public void remove(int key) { root = delete(root, key); }
    
    protected TreeNode add(TreeNode root, int key)
    {  // leetcode 701. Search in a BST.
        if(root==null) return new TreeNode(key);
        
        if(root.value > key)
        {
            root.left = add(root.left, key); 
        }
        else if(root.value < key)
        {
            root.right = add(root.right, key);             
        }        
        
        return root;
    }

    protected TreeNode find(TreeNode root, int key)
    {  // leetcode 701. insert in a BST.
        if(root==null) return null;
        
        if(root.value > key)
        {
            return find(root.left, key); // similar as add expect return statement
        }
        else if(root.value < key)
        {
            return find(root.right, key);             
        }
        
        return root;
    }
    
    
    protected TreeNode delete(TreeNode root, int key)
    {  // leetcode 450. Delete in a BST
        if(root==null) return null;
            
        if(root.value > key)
        {
            root.left = delete(root.left, key);
        }
        else if(root.value < key)
        {
            root.right = delete(root.right, key); // similar as add expect delete code.
        }
        else // found the key
        {
            if(root.left==null || root.right==null) return (root.left==null) ? root.right:root.left;
            TreeNode minOnRightLeft = root.right; // get the right subtree
            
            while(minOnRightLeft.left!=null) minOnRightLeft= minOnRightLeft.left;            
            
            root.value = minOnRightLeft.value;
            root.right = delete(root.right, minOnRightLeft.value);                
        }
        
        return root;
    }

    
}


/**
 * Your MyHashSet object will be instantiated and called as such:
 * MyHashSet obj = new MyHashSet();
 * obj.add(key);
 * obj.remove(key);
 * boolean param_3 = obj.contains(key);
 */